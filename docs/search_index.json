[
["index.html", "Biostatistikos pratybos 2018 m. pavasario semestras Pradžia Apie šią knygą Pastabos Žymėjimų reikšmės", " Biostatistikos pratybos 2018 m. pavasario semestras Vilmantas Gėgžna Pradžia Medžiaga atnaujinta: 2018-06-06 Šios svetainės-knygos turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. Tai reiškia, kad šios svetainės turinį galite naudoti nekomerciniais tikslais, nurodydami informacijos šaltinį taip, kaip tai apibrėžia licencijos sąlygos, bei nurodydami, jei buvo atlikti pakeitimai. Jei darote išvestinius kūrinius, juos privalote licencijuoti ta pačia licencija, kaip ir šios svetainės medžiaga. Nebent šalia konkrečios dalies nurodyta kitaip arba autorių teisės priklauso kitiems autoriams. Apie šią knygą Šiame tinklapyje esanti informacija yra pagalbinė medžiaga biostatistikos bei biometrijos dalykų pratyboms. Ji parengta naudojant „bookdown“ technologiją (https://bookdown.org/yihui/bookdown/) ir patekta elektroniniu „gitbook“ formatu (https://www.gitbook.com), todėl toliau bus vadinama knyga. Šių pratybų metu susipažinsime su statistinei analizei naudojamais įrankiais: Programa R; Patogesniam darbui su R skirta aplinka (programa) „RStudio“: \\(R \\neq RStudio\\)! Ataskaitų rengimui skirtomis R galimybėmis (papildiniais R Markdown, knitr); „Pasirink ir paspausk“ (anlg. point-and-click) principu veikiančiu papildiniu Rcmdr (pilnas pavadinimas R Commander), kuris R kodą generuoja pats; Įvairiais kitais statistinei analizei skirtais R papildiniais. Taip pat išmoksite praktiškai atlikti bazines statistines procedūras, pvz., statistiškai apibendrinti savo duomenis, apskaičiuoti pasikliauties intervalus, taikyti įvairius statistinius modelius (kad ir ką tai bereikštų ☺). Be to sužinosite, kas yra „normalumas“ ir kaip jis įvertinamas. ☺ „Visi dalykai būna sudėtingi prieš tai, kai tampa paprasti.“ („Everything is hard before it is easy.“) — Johann Wolfgang von Goethe Pastabos Pastaba 1: kiekvieno knygos skyriaus gale yra vieta, kurioje galite palikti komentarą, patarimą, pastabą ar pateikti klausimą. Būkite mandagūs, tolerantiški, supratingi, laikykitės raštvedybos ir kitų universiteto studentams prideramų taisyklių. Pastaba 2: ši knyga (ir joje esančios instrukcijos) orientuota į operacinės sistemos Windows vartotojus. Kitų sistemų vartotojams kai kurios instrukcijos gali šiek tiek skirtis. Pastaba 3: daugelis šioje knygoje rodomų pavyzdžių pateikti darant prielaidą, kad programoje R nustatyta lietuviškoji lokalė. Ją nustatanti programos R komanda (kurią reikia vykdyti kiekvieną kartą perkrovus programą): # Lokalės keitimas operacinėje sistemoje „Windows“ Sys.setlocale(locale = &quot;Lithuanian&quot;) Lokalė – tai nuo kalbos ir vietovės priklausančios programų, dokumentų bei teksto savybės1. Pvz., savaitės dienų pavadinimai. Jei programoje R nustatyta lokalė veikia neteisingai, įsitikinkite, kad jūsų kompiuterio operacinės sistemos lokalė taip pat yra lietuviška (kai kuriais atvejais, operacinės sistemos lokalė gali užgožti programoje R nustatytą lokalę). Žymėjimų reikšmės Greitosios klavišų kombinacijos (veikiančios programoje RStudio) bus žymimos šitaip: Ctrl + ↑. Knygoje naudojamų spalvotų dėžučių reikšmės: Svarbi informacija. Darbo planas, užduotys. Pastaba, rekomendacija, geros praktikos pavyzdys, patarimas. Pastaba. Pastaba, įspėjimas arba vengtini dalykai. Citatos „Tai nežinomo autoriaus citata.“ — Nežinomas autorius Su programos kodu susiję žymėjimai bus aptarti atskirai. Lankytojai: Šis paaiškinimas yra smarkiai supaprastintas. Tikslesnį galite rasti šiame žodyne (nuoroda).↩ "],
["labai-svarbu.html", "Labai svarbu", " Labai svarbu Dalyje „Labai svarbu“ nurodyta, ką privaloma žinoti kiekvienų pratybų ir kiekvieno atsiskaitymo metu. Labai svarbu (1) Kuo generalinė aibė (GA) skiriasi nuo imties? Kas yra aprašomoji statistika (mokslas) ir kas – statistinės išvados? Mokėti pagal svarbumą išdėlioti tyrimo ciklo dalis. Mokėti atpažinti kategorinius nominaliuosius, ranginius, skaitinius diskrečiuosius bei tolydžiuosius duomenis. Mokėti atpažinti situacijas, kai kintamieji, užrašyti skaičiais, iš tiesų yra kategoriniai. Kokia tvarkingos duomenų lentelės struktūra? Labai svarbu (2) Kas yra ir kam reikalingas UTF-8? Kokie galimi skirtukai (2 rūšys) tekstinėse bylose su duomenimis ir kaip juos atpažinti? Žinokite šešias R duomenų klases (numeric/double, integer, factor, ordered, logical, character) ir kokiems duomenų tipams jos tinkamos, bei kokiems – netinkamos. Labai svarbu (3) Kas yra kintamojo reikšmių skirstinys? Pagal kintamojo duomenų tipą (nominalusis-tolydusis) mokėkite pasirinkti tinkamą grafiką. Mokėkite pasirinkti tinkamą histogramos stulpelių skaičių ir branduolinio tankio grafiko branduolio plotį. Iš grafiko mokėkite nustatyti duomenų skirstinio centrą, sklaidą (kur didesnė, kur mažesnė), skirstinio viršūnių skaičių, asimetrijos buvimą/nebuvimą ir jos rūšį, imties dydį (didelė ar maža imtis), ar yra aiškių išskirčių. Žinokite, ar grafikas minėtuosius dalykus gali parodyti apskritai. Labai svarbu (4) Kas yra priklausomos ir nepriklausomos duomenų imtys? Kaip atpažinti? Kaip atrodo ilguoju ir plačiuoju formatu pateiktos duomenų lentelės ir kaip teoriškai vieno formato lentelė gali būti paversta į kito formato lentelę? Labai svarbu (5) Mokėti atpažinti duomenų tipus (nominalieji, ranginiai, diskretieji, tolydieji) ir patikrinti, ar jiems parinkta tinkama R duomenų klasė. Mokėti pagal duomenų tipą (nominalusis-tolydusis) parinkti tinkamas statistines suvestines. Žinoti, kas yra imties statistika ir kaip ją atskirti nuo GA parametro. Žinoti, kad imties dydį reikia nurodyti visada. Žinoti, ką mums parodo kvantiliai. Labai svarbu (6) Kokia turėtų būti duomenų analizės kodo struktūra? (Pagal 5.1.3 skyrių). Labai svarbu (7) Kas yra atsitiktinis dydis? Kas yra atsitiktinio dydžio skirstinys? Kas yra atsitiktinio dydžio kvantilis? Kokio eksperimento rezultatą modeliuoja binominis ir Puasono skirstiniai? Kokiems duomenims galima (korektiška) taikyti statistinių išvadų darymo metodus? (Kaip turi būti sudaryta imtis?) Kaip suprasti užrašus \\(P(X&lt;x)=0.05\\), \\(p = P(X=x)\\)? Pateikite biologinių pavyzdžių. Labai svarbu (8) Kas yra pasikliautinasis (pasikliauties) intervalas (PI)? Kokią informaciją jis mums suteikia? Dažniausiai naudojamas pasikliovimo lygmuo yra 95%. Ką mums šis dydis sako? Jei pasikliovimo lygmuo yra fiksuotas (tarkim, lygus 95%), kuris PI rodo didesnį tikslumą: ilgesnis ar trumpesnis? Ką reikia daryti siekiant išsaugoti pakankamai didelį pasikliovimo lygį, bet sumažinti vidurkio PI ilgį? Pastaba: PI – pasikliautinasis (pasikliauties) intervalas. PI ilgiu vadinsime skirtumą tarp viršutinio ir apatinio PI intervalo rėžių (t. y., viršutinės ir apatinės intervalo ribų). Labai svarbu (9) Tikrinant statistines hipotezes, ką bendruoju atveju teigia nulinė statistinė hipotezė? Kaip apibrėžiama \\(p\\) reikšmė, kuri gaunama tikrinant statistines hipotezes? Savais žodžiais paaiškinkite, ką parodo ši \\(p\\) reikšmė. Labai svarbu (10) Kaip išsirinkti tinkamą statistinį kriterijų, skirtą hipotezei apie grupių centro padėties lygybę tikrinti? (t, Welch F, Mann-Whitney-Wilcoxon kriterijai, ANOVA, post-hoc analizė ir t. t.) Labai svarbu (11) Kokia analizė naudojama norint ištirti, ar kategoriniai kintamieji yra susiję? Kada naudojama koreliacinė analizė? Labai svarbu (12) Kada naudojama regresinė analizė? Kuo skiriasi regresinė ir koreliacinė analizės? Kada kurią rinktis? Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["ivadas.html", "1. Įvadas 1.1 Duomenų analizės pagrindai 1.2 Programos R pradmenys", " 1. Įvadas 1.1 Duomenų analizės pagrindai Šiame skyriuje susipažinsime su svarbiausiomis duomenų analizės sąvokomis ir tuo, kur biostatistikos kurso kontekste yra šios pratybos. 1.1.1 Statistikos mokslas ir jo dalys Statistikos mokslą galima apibūdinti kaip tikslųjį mokslą (matematikos šaką) apie tyrimo planavimą, duomenų rinkimą, sisteminimą, analizavimą bei rezultatų interpretavimą. Biostatistika ir biometrija yra taikomosios statistikos šakos, orientuotos į medicininių ir biologinių duomenų analizę. Statistikos metodus galima suskirstyti į 3-4 pagrindines dalis (ryšys tarp šių dalių pavaizduotas pav. 1.1): Tyrimo planavimas (angl. (study/experimental) design) – prieš vykdant tyrimą, jis turi būti kruopščiai suplanuojamas. Suplanuojama ir tai, kaip bus sudaryta tiriamųjų imtis, kuri bus tinkama atsakyti į pagrindinį tyrimo klausimą. Nors šis aspektas akcentuojamas pav. 1.1, tačiau tai yra tik viena iš eksperimento plano dalių; Aprašomoji statistika (angl. descriptive statistics) – grafiniai ir skaitiniai duomenų sisteminimo metodai; Statistinių išvadų darymas (angl. inferential statistics) bei prognozavimas (angl. prediction) – analizės ir interpretavimo metodai, pagal imties duomenis leidžiantys daryti išvadas apie visą GA ir/arba prognozuoti. Pav. 1.1: Sąryšis tarp statistikos dalių, generalinės aibės ir imties. Mėlyna spalva pažymėti terminai bus paaiškinti kitame poskyryje. „Statistikos uždavinys – aiškiai pasakyti tiesą: (pakankamai) tiksliai ir suprantamai.“ — Stephen McCurdy 1.1.2 Generalinė aibė, imtis ir duomenys Statistikoje yra keli svarbūs terminai: generalinė aibė (populiacija), imtis bei duomenys (pav. 1.2). Pav. 1.2: Generalinė aibė, imtis ir duomenys. Iš visos tyrimo metu analizuojamos objektų visumos (generalinės aibės, GA) visiškai atsitiktinai arba kitu tikimybiniu būdu sudarome tiriamųjų imtį (paimame dalį GA). Tada išmatuojame ar užregistruojame vieną arba kelis mus dominančius tiriamųjų požymius ir taip gauname duomenis (duomenų imtį). Generalinė aibė (GA), arba populiacija,– tai statistinio tyrimo metu nagrinėjama objektų visuma. Imtis – tai į tyrimą patekusi GA dalis (į tyrimą patekę objektai). Duomenys – tai imties objektų savybių reikšmės. Savybės gali būti kokybinės (pvz., spalva) bei kiekybinės (pvz., svoris). Imties dydis – tai imtyje esančių elementų (objektų, tiriamųjų, stebėjimų) skaičius. Pavyzdys. GA – tai visi 4-5 m. amžiaus naminiai šunys, imtis – tai į tyrimą patekę 4-5 m. amžiaus naminiai šunys, duomenys – į tyrimą patekusių šunų kailio spalva: šviesi, tamsi, marga, … Statistiniam tyrimui tinkama imtis privalo būti pakankamo dydžio ir reprezentatyvi. Reprezentatyvi imtis yra tokia, kurioje pakankamai tiksliai atsispindi visos GA savybės. Tai tarsi maža GA kopija. Imtis turi būti reprezentatyvi tai GA, apie kurią daromos statistinės išvados. Kitu atveju išvados bus klaidingos. T. y., jei imtyje yra tik vyresni nei 60 m. amžiaus vyrai, tai didelis klausimas, ar ištyrę juos galime daryti išvadas apie visus žmones, tarp kurių yra ir moterys, vaikai, kūdikiai bei jaunimas. Per mažo dydžio imtys yra nereprezentatyvios ir iš jų padarytos išvados, tikėtina, bus klaidingos. Vien tik didelis imties dydis irgi negarantuoja reprezentatyvumo, jei imtis sudaryta netinkamu būdu. Kelios pastabos: Atkreipkite dėmesį į tai, kad terminas „populiacija“ statistikoje reiškia ne tą patį, ką biologijoje, todėl, vengiant dviprasmybės, Lietuvių kalba yra aprobuotas kitas statistinis terminas („populiacijos“ sinonimas) – generalinė aibė (GA). Terminas „imtis“ gali reikšti ir tiriamųjų imtį (pvz., į tyrimą įtraukti 4-5 m. amžiaus naminiai šunys) ir duomenų imtį (pvz., tyrimo metu užregistruota kiekvieno iš šių šunų kailio spalva). 1.1.3 Statistinio tyrimo ciklas Statistinio tyrimo eigą galime suskirstyti į 5 sąlygines dalis (pav. 1.3). Pav. 1.3: Statistinio tyrimo ciklas. Glaustas kiekvienos ciklo dalies apibūdinimas: Klausimas. Pirmiausia, iškeliame klausimą, susiformuluojame mokslinę problemą, kad žinotume, ką norime padaryti, į kokį klausimą atsakyti, kokią problemą išspręsti savo analize. (Žiūrėkite kitame poskyryje). Be klausimo nėra ir analizės tikslo. Planas. Kai jau žinome klausimą, galime susiplanuoti, kaip į jį atsakysime. Vėlesni tyrimo etapai negali atsverti ir ištaisyti prastai suplanuoto bei nekorektiškai atlikto tyrimo pasekmių. Duomenys. Surenkame duomenis, kurie yra tinkami atsakyti į išsikeltą klausimą. Duomenis parengiame analizei. Analizė. Padarome duomenų suvestines. Pagal klausimą ir duomenų savybes pasirenkame tinkamą tolimesnės analizės metodą. Atliekame šią analizę. Išvados. Grįsdami analizės rezultatais, padarome išvadas – atsakome į iškeltą klausimą. Įprastai gavus atsakymą į vieną klausimą, kyla dar keletas naujų klausimų. Tad toliau bandant atsakyti į naujuosius klausimus susidaro ciklas. Jei reikėtų pasirinkti, kas svarbiau atliekant tyrimą – analizės metodas, tinkami duomenys, tyrimo planas ar klausimas,– jūs turėtumėte aiškiai žinoti, kad pagal svarbą šie dalykai išsirikiuoja šitaip: klausimas (ir tikslas) → tyrimo planas → tinkami duomenys → analizės metodas. Jei neaišku kodėl – tada dar kartą perskaitykite kiekvienos statistinio tyrimo ciklo dalies apibūdinimą. 1.1.4 O koks, sakėte, klausimas? Pav. 1.4: Klausimas – pati svarbiausia duomenų analizės dalis, nes suteikia analizei tikslą. Prieš pradedant duomenų analizę, reikia aiškiai žinoti, kokiu tikslu ji yra daroma. Ir pagrindinis analizės tikslas – spręsti tam tikrą mokslinę, socialinę, verslo, medicininę, gamtinę ar kitokią realaus gyvenimo problemą bei atsakyti į tam tikrą specifinį klausimą, kuris buvo suformuluotas prieš atliekant analizę (pav. 1.4). Pvz., kuris šokoladas Lietuvos žmonėms labiau patinka (juodasis, pieniškas ar baltasis); kokią įtaką vienas papildomas euras, išleistas ledų reklamai, darytų įmonės pelnui; ar GMC studentai greičiau įsisavina kurso medžiagą, jei prie įprastos rašytinės medžiagos papildomai pateikiama video medžiaga; kurioje terpėje dumbliai greičiau auga; ar naujai kuriamas vaistas gali pailginti miego trukmę; ar pagal fenotipinius požymius galima atpažinti bakterijos genotipinius Gardnerella vaginalis pogrupius; ar kovų baidymas padeda reikšmingai sumažinti paukščių keliamą triukšmą Panevėžio mieste? Analizė, neturinti klausimo ir nesprendžianti problemos yra bevertė, nes neturi tikslo („analizė dėl analizės“). Tad tinkamas aiškiai ir konkrečiai suformuluotas klausimas – pati svarbiausia visos analizės dalis. Tinkamas aiškiai ir konkrečiai suformuluotas klausimas – pati svarbiausia tyrimo dalis. 1.1.5 Statistinio tyrimo eiga Tad statistiniam tyrimui būdinga eiga pavaizduota pav. 1.5. Pav. 1.5: Būdinga statistinio tyrimo eiga. Ši schema parengta Čekanavičiaus ir Murausko vadovėlyje „Statistika ir jos taikymai I“ pateiktos schemos pagrindu, papildomai pridėjus punktą „klausimo formulavimas“. Taip norėta akcentuoti, kad pirmiausia reikia nusistatyti tyrimo tikslą. Visgi, kai kurie eigos etapai gali persidengti, pvz., galutinį tyrimo klausimą galime susiformuluoti tik tada, kai tiksliai apsibrėžiame, kas yra mūsų GA (generalinė aibė). Šių pratybų metu mes mokysimės dirbti su jau surinktais duomenimis: juos parengti analizei, susisteminti ir statistiškai apibendrinti, patikrinti prielaidas apie duomenis, parinkti statistinės analizės modelį (metodą, testą), daryti statistines išvadas bei prognozuoti. 1.1.6 Kintamųjų tipai Statistikoje „kintamaisiais“ vadinamos tiriamųjų/objektų savybės. Duomenų analizės metodo pasirinkimas labai smarkiai priklausys nuo kintamojo prigimties. Pagal prigimtį statistiniai kintamieji skirstomi į 2 dideles grupes: kokybinius (kategorinius plačiąja prasme) ir kiekybinius. Šie, savo ruožtu, skaidomi į 4 pagrindinius tipus (pav. 1.6). Pav. 1.6: Pagrindiniai statistinių kintamųjų tipai. Kokybiniai (kategoriniai) kintamieji: nominalieji (angl. nominal variable) – tai tokie kintamieji, kurių reikšmių (vadinamos kategorijomis) išdėstymo tvarka nesvarbi, t. y., reikšmės natūralios eilės tvarkos neturi. Matavimo vienetų irgi neturi. Pvz., ląstelės spalva – violetinė, raudona, melsva, bespalvė, – ląstelės forma – apvali, kvadratinė, pailga, netaisyklinga. Kartais kategorijos užkoduojamos skaičiais, pvz., 0 – sveikas, 1 – serga, bet dėl to kintamasis netampa kiekybiniu. 0 ir 1 tai tik kategorijų kodai, kurių eilės tvarka nesvarbi. ranginiai (angl. ranked/ordered variable) – tai tokie kintamieji, kurių reikšmės (vadinamos kategorijomis) turi natūralią didėjimo ar mažėjimo tvarką, tačiau atstumas tarp gretimų reikšmių nėra pastovus ar tiksliai išmatuojamas. Įprastai matavimo vienetų neturi. Pvz., ląstelės dydžio kategorija – maža, vidutinė, didelė; savijauta – labai prasta, prasta, neutrali, gera, puiki. Ranginiams priklauso ir balais matuojami duomenys. Kiekybiniai kintamieji: diskretieji (angl. discrete variable) – tai tokie skaitiniai kintamieji, kurie yra suskaičiuojami. Jie turi baigtinį (suskaičiuojamą) galimų reikšmių skaičių ir atstumas tarp dviejų galimų gretimų reikšmių yra pastovus ir gali būti tiksliai išmatuotas. Paprasčiau sakant, kiekybiniai diskretieji kintamieji išreiškiami teigiamais ir neigiamais sveikaisiais skaičiais bei nuliu. Įprastai aprašo kieno nors skaičių, pvz., ląstelių skaičių, dantų skaičių, kėdžių skaičių, į paskaitą atėjusių studentų skaičių, sėkmingų bandymų skaičių, raudonų mėgintuvėlių skaičių; tolydieji (angl. continuous variable) – tai skaitiniai kintamieji, kurie įprastai yra išmatuojami ar užregistruojami (bet ne suskaičiuojami). Gali įgyti ir trupmeniniais skaičiais užrašomas reikšmes (tarkim, 2,2354), teoriškai gali būti išmatuoti daugybės skaitmenų po kablelio tikslumu. Pasirinktame reikšmių intervale tarp dviejų skaičių (tarkim, tarp 2,2 ir 2,4) gali įgyti be galo daug reikšmių, nes skaičių po kablelio gali būti be galo daug. Įprastai turi konkrečius matavimo vienetus, nors gali būti išreikšti ir santykiniais vienetais ar būti bedimensiai dydžiai. Pvz., ląstelės svoris kilogramais, ilgis centimetrais, trukmė sekundėmis (kai skaičiuojamos ir sekundžių dalys), regėjimo aštrumas dioptrijomis, santykis tarp ilgio (metrais) ir pločio (metrais), šviesos intensyvumas santykiniais vienetais. Įprastai tokius skaičius suapvaliname iki tam tikro tikslumo tik dėl to, kad negalime išmatuoti be galo tiksliai arba praktiniam naudojimui užtenka ir mažesnio baigtinio tikslumo. Visgi teoriškai matuojamas kintamasis išlieka tolydusis. Kokius veiksmus galima atlikti su skirtingų tipų kintamųjų reikšmėmis? Nominaliąsias reikšmes galima tik suskaičiuoti: pasakyti, kiek kokių reikšmių yra. Ranginiais – galima suskaičiuoti, išdėstyti eilės tvarka ir palyginti, kuri didesnė/mažesnė. Su kiekybinių kintamųjų reikšmėmis – skaičiais – galima atlikti iš principo visus matematinius veiksmus (suskaičiuoti, palyginti, sudėti, atimti, padauginti, padalinti, apskaičiuoti vidurkį, …). Kokie kintamieji atrodo kaip skaitiniai (kiekybiniai), bet iš tiesų yra kategoriniai? Kategorijos, užkoduotos skaičiais, vis tiek yra kategorijos (tad joms skaičiuoti vidurkį nėra prasmės). Balais matuojami kintamieji iš tiesų yra ranginiai. Visgi, jei jie gali įgyti pakankamai daug reikšmių ir jų vidurkis turi prasmę (turbūt žinote, kas yra sesijos pažymių vidurkis), dažnai interpretuojami kaip skaitiniai. Visgi reikia prisiminti, kad pagal prigimtį – tai iš eilės išdėliotos kategorijos (rangai). Užduotis 1.1 Kuriam iš keturių tipų (nominalieji, ranginiai, diskretieji, tolydieji) priklauso šie duomenys: Šokolado svoris (g); Šokolado skonis (neskanus, skanus, labai skanus); Šokolado pakuotės spalva; Šokolado lydymosi temperatūra (°C); Šokolado plytelių skaičius; Šokolado porėtumas (porėtas/neporėtas); Šokolado rūšis (juodasis, baltasis, pieniškas, mėtinis); Šokolade esančių riešutų skaičius. 1.1.7 Duomenų saugojimo formos Atliekant tyrimą svarbus dalykas yra nuspręsti, kokia forma rinksime ir saugosime duomenis. Mūsų pasirinkimas priklauso nuo tyrimo srities, sprendžiamo uždavinio ir duomenų sudėtingumo. Šio kurso metu daugiausiai dirbsime su dviem formomis – duomenų eilutėmis ir duomenų lentelėmis – tad siūlau skirti pakankamai daug laiko, kad tinkamai perprastumėte šias dvi struktūras. 1.1.8 Duomenų eilutės Duomenų eilutės – tai surinktų duomenų seka. Joje įrašomos vienõs užregistruotos tiriamųjų savybės (tarkim, apklaustųjų ūgio) reikšmės. Duomenų eilutės pavyzdys – išmatuoti kurso kolegų ūgiai (centimetrais): 180, 168, 171, 173, 185, 179, 164. Duomenų eilutę taip pat galima pavadinti statistiniu kintamuoju, nes reikšmės nėra fiksuotos, bet kinta. (PASTABA: vėliau susipažinsime su kompiuteriniu terminu „kintamasis“, tad atskirkite, kad tai panašūs, bet skirtingi dalykai). Analizei svarbu atpažinti tokias duomenų eilutes: statistinė eilutė – duomenys surašyti eilės tvarka, pagal tai, kada buvo surinkti ir užregistruoti; variacinė eilutė – duomenys išrikiuoti didėjimo (arba nemažėjimo, jei yra vienodų reikšmių) tvarka. 1.1.9 Duomenų lentelės Duomenų lentelės – yra statistiniam tyrimui svarbiausia duomenų saugojimo forma. Ji yra standartizuota ir pritaikyta darbui statistinėmis programomis. Tvarkingos duomenų lentelės sudarymo principas: viena eilutė skirta vienam tiriamajam, vienas stulpelis – vienai savybei (kintamajam), o langeliuose – kiekvieno tiriamojo savybių reikšmės (žiūrėti pav. 1.7). Pav. 1.7: Duomenų lentelės struktūra. Atkreipkite dėmesį, kad stulpelių pavadinimai nurodo tiriamųjų savybes. Be to, įprastai lentelė turi pavadinimą, kuris turėtų būti prasmingas ir apibendrinti lentelėje surinktus duomenis. Duomenų lentelė gali būti gaunama vienos ar kelių duomenų eilučių reikšmes surašius kaip stulpelius. Tik svarbu, kad pirma kiekvienos duomenų eilutės reikšmė būtų iš pirmo tiriamojo, antra – iš antro ir t.t. T. y., kad eilės tvarka atitiktų teisingai. Visgi, vykdant tyrimą, duomenis rekomenduoju rinkti iš karto duomenų lentelės pavidalu, papildomai pasidarant duomenų lentelės aprašymą. Aprašymas reikalingas tam, kad jūsų kolegos, vadovas arba jūs pats/pati po 6 mėnesių tiksliai žinotumėte, kokie duomenys šioje lentelėje. Aprašyme bent trumpai apibūdinkite tyrimą, jo tikslą, nurodykite duomenų rinkimo metodus ir prietaisus, pateikite kintamųjų aprašymą, kuriame nurodyti matavimo vienetai. Rekomendacija: surinktus duomenis iš karto surašykite į duomenų lentelės pavidalą + būtinai pasidarykite duomenų lentelės kintamųjų aprašymą. Žinodami šitiek „matematinės-statistinės“ teorijos galime pereiti prie kitos dalies – „kompiuterinės“ teorijos ir duomenų analizės programa R. 1.2 Programos R pradmenys Šiame poskyryje sužinosite, kas yra programa R, bei susipažinsite su darbo šia programa pradmenimis. Atkreipkite dėmesį į tai, kad taip pat skambantys terminai (pvz., objektas, kintamasis) statistikos ir kompiuterijos prasme gali turėti panašias, bet šiek tiek skirtingas reikšmes. Visgi tikiuosi, kad greit susigaudysite ir tai nekels problemų. 1.2.1 Apie programą R R – tai duomenų analizei skirta kompiuterinė programa, turinti ir interaktyvios duomenų analizės, ir programavimo galimybes. Pagal savo paskirtį R orientuota į (statistinę) duomenų analizę ir duomenų vaizdinimą. Tačiau programos funkcionalumą smarkiai išplečia daugybė (virš 14000!) papildinių, dar vadinamų paketais, kurie leidžia spręsti įvairioms mokslo šakoms aktualius skaičiavimo, duomenų pertvarkymo, parengimo analizei bei vaizdinimo uždavinius, kurti automatizuotas ataskaitas ir pateikti jas įvairiomis formomis, pvz., internetinio tinklapio ar Microsoft Word formatu, rašyti mokslinius straipsnius, net knygas! Ši mokomoji medžiaga taip pat sukurta naudojantis R. Programa R – GNU projekto dalis, yra visiškai nemokama ir laisvai platinama. Jos vystymu rūpinasi R fondas (The R Foundation). Daugiau informacijos apie programą rasite tinklapyje www.r-project.org. Jei programos dar neturite, skyriuje „[Reikiamos programos]“ rašoma, kaip ją parsisiųsti ir įsidiegti į savo kompiuterį. Įspėjimas: programa R nėra pakaitalas jūsų smegenų darbui. 1.2.2 Programos RStudio langai Programa RStudio yra patogesniam darbui su R skirta grafinė aplinka (angl. graphical user interface, GUI). Paveiksle 1.8 pavaizduoti pagrindiniai programos langai. Pav. 1.8: Programos RStudio langai. Jei programą atsidarote pirmą kartą, lango, pažymėto numeriu 2 (pav. 1.8) galite ir nematyti. Tai normalu. Kol kas visus tolimesnius pavyzdžius galite išsibandyti komandų lange (konsolėje), pažymėtame numeriu Nr. 1. Užduotis 1.2 Atsidarykite programą RStudio. Pažiūrėkite, ar matote visus keturis langus, vaizduojamus pav. 1.8. Jei trūksta lango Nr. 2, paspauskite Ctrl+Shift+N ir atsidarys R programos kodui rašyti ir išsaugoti skirtas langas („R Script“). 1.2.3 Pagrindiniai R kodo sintaksės elementai Turbūt pamenate lietuvių kalbos pamokas apie „sintaksę ir skyrybą“. Jų metu mokėtės rašyti sakinius, taisyklingai sujungti įvairias jų dalis, tokias kaip aplinkybės, bei taisyklingai jas atskirti tinkamais skyrybos ženklais. Kompiuterijoje taip pat yra terminas „sintaksė“, kuriuo nusakoma kompiuterinės kalbos rašymo taisyklių visuma. Sintaksė (kompiuterijoje) yra kompiuterinės kalbos rašymo taisyklių visuma. Jūsų uždavinys analizuojant šį poskyrį – išmokti atpažinti kelis pagrindinius R programos kodo sintaksės elementus bei susipažinti su šioje mokomojoje medžiagoje naudojamu jų spalviniu žymėjimu. R kodo komentarai (#) Vienas iš R kalbos elementų yra komentaras. Grotelių ženklas (#) šalia R komandų reiškia, kad tai komentaro pradžia. To, kas yra parašyta po grotelių, programa R neskaito. Šitokiu būdu galime rašyti pastabas patys sau: # Tai komentaras, kurio R neskaito Komentaro ženklas galioja iki eilutės pabaigos, o rašant iš naujos eilutės – nebegalioja, tad norint tęsti komentarą kitoje eilutėje reikia groteles rašyti iš naujo: # Tai komentaras, # kuris tęsiasi per # kelias eilutes Tam, kad būtų paprasčiau susigaudyti, modernios programos įprastai skirtingomis spalvomis paryškina įvairius R kodo elementus. Konkrečios spalvos ir paryškinimo būdas priklauso nuo naudojamos programos ir pasirinktų nustatymų. Šioje elektroninėje knygoje komentarai bus išryškinami tamsiai mėlyna spalva (kaip matote pavyzdyje virš šios pastraipos). Rezultatų ženklinimas (##) Šioje knygoje prieš rezultatus, kuriuos apskaičiuoja programa R, bus padedami du grotelių (t.y., komentaro) simboliai iš eilės (##) ir rezultatų tekstas bus nuspalvinamas pilkai: ## tai rezultatas, kurį pateikė R Pavyzdys: sudėjus 2 ir 3 (šią komandą parašome mes) atsakymas yra 5 (atsakymą apskaičiuoja ir parašo programa R): 2 + 3 ## [1] 5 Jei rezultatas bus apskaičiuojamas dirbant programa R, tai šių dviejų grotelių nepamatysite, nes dirbant programa ir taip aišku, kur jūsų parašyta komanda, o kur kompiuterio atsakymas. Užduotis 1.3 R komandų lange (konsolėje) parašykite matematinį veiksmą 3 + 2. Koks rezultatas? Ką jis reiškia? Elementų eilės numerių žymėjimas: [ ] Praeitame pavyzdyje pastebėjote, kad eilutės pradžioje laužtiniuose skliaustuose atsirado papildomas skaičius [1]. Jis nurodo tos eilutės pirmojo elemento (pavyzdyje jo reikšmė yra 5) numerį. Aišku, šiuo atveju užrašas [1] duoda mažai naudos. Tačiau yra labai patogus, kai atsakymo elementų yra daug ir jie netelpa į vieną eilutę. Tokiu atveju laužtiniuose skliaustuose nurodomas kiekvienos eilutės pirmojo elemento eilės numeris, pvz.: ## [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ## [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ## [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 ## [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 ## [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 ## [86] 95 96 97 98 99 100 Pavyzdyje matome, kad elemento, kurio eilės numeris yra [69] reikšmė yra 78. R funkcijos ir jų argumentai Viskas, kas vyksta programoje R – sudėtis, lango atidarymas, paveikslo nubraižymas, duomenų išsaugojimas, spalvos pakeitimas,– yra kokios nors funkcijos vykdymo rezultatas. Funkcijos – tai komandos, kurias duodame kompiuteriui. Jos rašomas kaip vienas žodis be tarpelių, kurio gale yra paprastieji apvalūs skliausteliai. Šioje knygoje jos bus paryškintos žydrai, kaip šiame pavyzdyje: r_funkcija() Pastaba: jūsų kompiuteryje funkcija r_funkcija() neveiks, nes tai tik pavyzdys. Komandos skliausteliuose rašome taip vadinamus funkcijos argumentus (terminai „funkcijos“, „argumentai“ – visai tokie, kaip per matematikos paskaitą): r_funkcija(argumento_reikšmė) Argumentai gali turėti pavadinimus ir šie bus pabraukti (kol kas nesijaudinkite, jei neaišku, kas argumentai ir t.t. Dabar svarbiausia, kad suprastumėte tik jų spalvinį žymėjimą): r_funkcija(argumento_pavadinimas = argumento_reikšmė) Pavyzdys, funkcija log(), kuri įprastai apskaičiuoja natūrinį logaritmą. Apskaičiuokime \\(ln(100)\\): log(100) ## [1] 4.60517 Funkcija log() turi argumentą x, tad galime užrašyti kitaip ir gauti tą patį rezultatą: log(x = 100) ## [1] 4.60517 Iš tiesų ši funkcija turi kelis argumentus, ir kai argumentų daug, jų parašymas funkcijos viduje suteikia aiškumo: log(100, base = 10) ## [1] 2 Turbūt supratote, kad buvo pakeistas logaritmo pagrindas („base“) į 10 ir apskaičiuota išraiška \\(log_{10}(100)\\). Jei norite daugiau sužinoti apie funkciją log(), komandų lange įrašykite ?log (prieš funkcijos pavadinimą padėkite klaustuką) ir pagalbos bei dokumentacijos lange „Help“ (pav. 1.8 langas Nr. 4) pamatysite aprašymą. Kitų elementų spalvinis žymėjimas Skaičiai, simbolių eilutės, loginiai kintamieji bus išryškinami jiems būdingomis spalvomis: objekto_pavadinimas 335 # skaičius &quot;simbolių eilutė (tekstas) rašoma kabutėse&quot; TRUE # Loginė reikšmė Programos kodas: blokais ir tekste Didesni kodo pavyzdžiai bus pateikiami blokais su spalvomis išryškintais elementais, kaip matėte ankstesniuose pavyzdžiuose: # Sudedame 5 bei 4 ir ištraukiame šaknį. # Atsakymas bus 3: sqrt(5 + 4) ## [1] 3 Kodo pavyzdžiai gali būti pateikiami ir toje pačioje eilutėje su tekstu, pvz., sqrt(5 + 4). Žinokite, kad tai programos kodas (t. y., R komandos). 1.2.4 R objektai Viskas, kas yra R atmintyje – vadinama objektais. Tai funkcijos, duomenų struktūros, simboliai ir kita (pav., 1.9). R objektai dar vadinami kintamaisiais (kompiuterijos prasme, angl. variable). Pav. 1.9: Kai kurie programos R objektų tipai. * – pagrindinės duomenų struktūros; ** – sudėtinės duomenų struktūros, sudarytos iš pagrindinių. Šiuo metu darbinėje R atmintyje esantys objektai išvardinti darbinės aplinkos lange „Environment“ (pav. 1.8 langas Nr. 3). Užduotis 1.4 Į konsolę nukopijuokite šį programos kodą x &lt;- 2 ir paspauskite klavišą „Enter“. Lange „Environment“ atsiras objektas, pavadinimu „x“. Jei norime, kad R’as konsolėje išvardintų objektų, šiuo metu esančių jo atmintyje, pavadinimus, galime naudoti komandą objects(): objects() # R&#39;as išvardija, kas jo darbinėje atmintyje Dažnai naudojamas komandos objects() sinonimas yra komanda ls(), kuri daro visiškai tą patį: ls() # R&#39;as išvardija, kas jo atmintyje Ši R’o atmintis įprastai vadinama darbine aplinka (angl. workspace arba environment). O išsaugota reikšmė gali būti ne tik vienas skaičius, bet ir žodžiai, vektoriai (skaičių ar kitokių reikšmių sekos), matricos, duomenų lentelės, netgi funkcijos. Kaip analizuojant R kodą atpažinti, kur įprastinė funkcija, o kur kitoks objektas? Pradiniam susigaudymui galima sakyti, kad po funkcijos rašomi paprastieji apvalieji skliausteliai ( ), pvz., sum(). Po kitokio objekto pavadinimo gali būti laužtiniai skliausteliai [ ], [[ ]] arba nieko nebūti. Objektų sukūrimas R objektai sukuriami naudojant priskyrimo operatorių &lt;- (įprastinis R naudotojo pasirinkimas) arba =. Rodyklė &lt;- susideda iš simbolių „mažiau“ ir „minus“ arba programoje RStudio įterpiama naudojant kombinaciją Alt+-. Kartais paspaudus šią kombinaciją įterpiamas operatorius =. Tokiu atveju programa mano, kad esamoje situacijoje šis operatorius yra tinkamesnis. Tai normalu. Sukurkime objektą objekto_pavadinimas kurio reikšmė būtų 4: # Skaitinės reikšmės priskyrimas objekto_pavadinimas &lt;- 4 Sakoma, kad objektui objekto_pavadinimas priskiriama reikšmė 4. Jei vėliau parašome šio kintamojo pavadinimą, įprastai atspausdinama jo reikšmė (tai vadinama spausdinimu pagal nutylėjimą): objekto_pavadinimas ## [1] 4 Taip pat tą patį rezultatą galime pasiekti naudodami komandą print() (šiuo atveju tai išreikštasis spausdinimas, nes parašome komandą): print(objekto_pavadinimas) ## [1] 4 Vėliau šią reikšmę galima panaudoti atliekant tolimesnius veiksmus. Priskirkime reikšmę: nupirkom_kiausiniu &lt;- 10 Atspausdinkime: nupirkom_kiausiniu ## [1] 10 Sukurkime dar vieną objektą: suvalgem_kiausiniu &lt;- 6 Atspausdinkime ir jį: suvalgem_kiausiniu ## [1] 6 Su šiais dviem objektais galime atlikti matematinius veiksmus tarsi tai būtų skaičiai, kuriuos priskyrėme: liko_kiausiniu &lt;- nupirkom_kiausiniu - suvalgem_kiausiniu Atspausdinkime rezultatą: liko_kiausiniu ## [1] 4 Reikšmes taip pat galima priskirti naudojant ir = simbolį: po_papildymo = liko_kiausiniu + 3 po_papildymo ## [1] 7 Užduotis 1.5 Naudodami operatorių &lt;- sukurkite objektus pavadinimais „a“, „b“ ir „c“ kurių reikšmės būtų atitinkamai 96, -6, 0.01. Visus šiuos objektus sudėkite. Ar rezultatas toks, kokio tikėjotės? Apie objektų pavadinimus Ar pamenat filmuką „Kung-fu Panda“? Jame kung-fu meistrai naudojo skirtingus kovos stilius: tigro, gervės, gyvatės… Panašiai ir rašant R kintamųjų pavadinimus, kuriuose siekiant aiškumo norima pavartoti kelis žodžius, naudojami įvairūs stiliai: DvikuprioKupranugarioStilius (žodžiai rašomi iš didžiosios raidės, be tarpų); taškuotojo.leopardo.stilius (žodžiai atskiriami taškais); šliaužiančios_gyvatės_stilius (žodžiai atskiriami apatiniais brūkšniais). Svarbu: programa R skirtingai reaguoja į didžiąsias ir mažąsias raides. Tad pavadinimai T ir t arba c ir C, arba mano_mama, mano_Mama ir mano_MAMA yra suprantami kaip skirtingi žodžiai. Skirtingas progrmų reagavimas į didžiąsias ir mažąsias raides angliškai vadinamas terminu „case sensitive“. Biostatistikos ir biometrijos pratybų metu dirbsime pagal „tidyverse“ sistemą. Todėl objektų pavadinimus rašysime pagal „tidyverse“ stiliaus gidą naudosime šliaužiančios_gyvatės_stilių: pavadinime tik mažosios raidės, skaičiai ir apatinis brūkšnys _; pirmasis simbolis pavadinime – visada raidė. Kaip kurti R objektų pavadinimus, kad vėliau nekiltų problemų? Naudotis „tidyverse“ stiliaus rekomendacijomis: pirmasis simbolis pavadinime privalo būti mažoji raidė; kiti simboliai – tik mažosios raidės, skaičiai ir apatiniai brūkšniai _. 1.2.5 Atominės R duomenų klasės Programa R yra skirta darbui su duomenimis. Pagal prigimtį duomenys būna skirtingų tipų. Tad bazinius tipus dabar ir aptarsime. R objektai turi savybę pavadinimu klasė (angl. class). Techniškai objektų savybės vadnamos atributais, angl. attributes. Programoje R yra 6 atomines (t. y., pagrindinės, pačios smulkiausios, į smulkesnes neskaidomos) objektų klasės (lentelė 1.1). Lentelė 1.1: Atominės R duomenų klasės. Nr. Klasė Pavadinimas Užrašymo pavyzdys 1. character Tekstas (ženklų eilutės). Dar vadinama „strings“. &quot;labas&quot;, &#39;A4&#39; 2. numeric Realieji skaičiai (dar vadinami „double“). 42, -0.6, 1.2e2, .3 3. integer Sveikieji skaičiai. 1L, -65L, 0L 4. complex Kompleksiniai skaičiai. 3 + 4i, -2i 5. logical Loginės reikšmės. TRUE, FALSE 6. raw Baitų sekos. (Plačiau nenagrinėsime, nes neaktualu). 1. Klasė „character“ Tai tekstas – ženklų ir simbolių eilutės. Dar vadinamos terminu „strings“. Klasės „character“ reikšmės sukuriamos tekstą ar simbolius parašius dvigubuose (&quot;...&quot;) ar viengubose ('...') „kompiuteristų“ kabutėse (o ne pagražintose kabutėse, pvz., „...“ arba ‘...’). Pvz., &quot;labas&quot;,&#39;A4&#39;. Šio kurso metu šios klasės nenaudosime ir ją pasiversime į kategoriniams duomenims saugoti skirtą klasę „factor“ (faktorius). 2. Klasė „numeric“ Tai realieji skaičiai, t. y., skaičiai su kableliu. Šios klasės objektai dar vadinami „double“ (nuo „double-precision floating-point format“). Skaičius, parašytas programoje R be papildomų nurodymų įprastai suprantamas kaip klasės „numeric“ atstovas, pvz., 0, 42 ar -3.2. Konsolėje parašykite class(42) ir įsitikinsite. Programoje R skaičiai rašomi tik su tašku, pvz., 10.66, o ne su kableliu 10,66. Taip yra todėl, kad tai, kas lietuviškai vadinama „kableliu“, angliškai užrašoma kaip taškas (žiūrėti pavyzdžius). Jei sveikoji skaičiaus dalis yra 0, tai jos galime nerašyti, pvz., .01 yra tas pats, kas 0.01, o -.2 atitinka -0.2. Šitoks užrašymas gali būti naudojamas ne tik programoje R, bet ir mokslinėje literatūroje. Realieji skaičiai gali būti užrašomi ir inžineriniu-moksliniu formatu naudojant simbolius \\(e\\) arba \\(E\\) (abiem atvejais ta pati reikšmė), kur 1e4 reiškia \\(1\\cdot10^4\\), o 2.3e-2 reiškia \\(2.3\\cdot10^{-2}\\). Pvz., 1e2, -1.2E-2. Kad ir kokiu būdu būtų užrašyti, skaičiai programoje RStudio yra išryškinami ta pačia skaičiams būdinga spalva (ji priklauso nuo pasirinktos spalvų schemos): -1.2E-2, 2, .06. Tas pats galioja ir kitoms dviems atominėms skaičių klasėms. (Šiame vadovėlyje žaliai išryškinami tik sveikieji skaičiai, pvz., lentelėje 1.1). 3. Klasė „integer“ Tai teigiami ir neigiami sveikieji skaičiai bei nulis. Norint, kad skaičius būtų saugomas kaip sveikasis, jo pabaigoje parašome L didžiąją raidę, pvz., 4L. Sveikasis skaičius kompiuterio atmintyje užima mažiau vietos nei realusis ar kompleksinis. Sveikasis skaičius įprastai gali būti ne mažesnis nei -2147483647 ir ne didesnis nei 2147483647. 4. Klasė „complex“ Tai kompleksiniai skaičiai. Sukuriami prie menamosios dalies skaitmenų prirašius i mažąją, pvz., 32 - 1i arba 3i. Šio kurso metu kompleksinių skaičių nenaudosime. 5. Klasė „logical“ Tai loginės reikšmės TRUE (taip, tiesa) ir FALSE (ne, netiesa). Atsiranda darant palyginimą arba sąlygos tikrinimą, pvz., 1 &lt; -1 (lyginame 1 ir -1) arba is.numeric(24) (tikriname, ar 24 priklauso klasei „numeric“). Loginės reikšmės gali būti užrašomos ir sutrumpintai (T arba F), bet visą laiką tik didžiosiomis raidėmis. 6. Klasė „raw“ Plačiau nenagrinėsime – ši klasė mums nebus reikalinga. Šio kurso metu mums reikalingiausios atominės duomenų klasės: numeric, integer bei sudėtingesnė klasė factor, nes jos skirtos statistiniams duomenis. 1.2.6 R duomenų struktūros Terminas „duomenų struktūra“ nurodo formą, kuria saugomi duomenys. Jei duomenis prilygintume mėgintuvėliams, tai duomenų struktūros būtų tam tikro tipo dėžutės ir laikikliai, skirti tam tikru būdu mėgintuvėlius išdėlioti ir saugoti. Programoje R yra 4 pagrindinės duomenų struktūros: atominis vektorius (vector) – tai tos pačios klasės duomenų reikšmių seka. Atominius vektorius sudaro tik atominių klasių duomenys. Ši duomenų struktūra atitinka „duomenų eilutę“ (statistinę ar variacinę) arba kintamąjį statistikos prasme. matrica (matrix) – programoje R, matrica yra vieno duomenų tipo (pvz., sveikųjų ar realiųjų skaičių, loginių, tekstinių) elementų, išdėliotų į fiksuotą eilučių ir stulpelių skaičių, rinkinys. T. y., vektoriaus reikšmės išdėliotos lentelės pavidalu eilutėmis ir stulpeliais. Skirtos tiesinės algebros uždaviniams spręsti, principinių komponentų, klasterinei ir panašioms analizėms. duomenų lentelė (data.frame) – tai R dvimatė duomenų struktūra (lentelė), kurios kiekviename stulpelyje gali būti skirtingo tipo duomenys, tačiau visi stulpeliai privalo būti vienodo ilgio. Tai pagrindinė duomenų struktūra, su kuria dirbsime šio kurso metu. sąrašas (list) – tai tokia duomenų struktūra, kurios kiekvienas elementas gali turėti skirtingo tipo duomenis, kurių ilgiai skirtingi. Kiekvienas sąrašo elementas yra tarsi atskiras konteineris, kuris gali talpinti skirtingas duomenų struktūras (vektorius, matricas, duomenų lenteles ar net kitus sąrašus). Tokiu būdu dažnai pateikiami statistinės analizės rezultatai. Dar viena mūsų kursui svarbi duomenų struktūra yra sudėtinė: faktorius (factor) – tai specialaus tipo vektorius, skirtas saugoti kategorinių kintamųjų reikšmes. Šios struktūros ypatybė ta, kad jos reikšmės kompiuterio atmintyje saugomos kaip sveikieji skaičiai (t.y., kategorijos kodai), o kategorijų pavadinimai (vadinami „lygiais“, angl. levels) – kaip tekstas. Tokiu būdų kategoriniai kintamieji kompiuterio atmintyje užima mažiau vietos nei tekstas. 1.2.7 R vektoriaus kūrimas R vektorius statistikoje atitinka duomenų eilutę. Kelios reikšmės į vektorių (t. y., į seką) sujungiamos naudojant komandą c() (c nuo žodžio combine arba concatenate). Reikšmės rašomos komandos skliausteliuose () ir atskirtus kableliais ,: c(6, 23, 33, 19) ## [1] 6 23 33 19 Jei tuos pačius skaičius parašysime R konsolėje be komandos c(), R pamanys, kad tai atskiri niekaip nesusiję elementai, nesupras, ką su jais norime daryti, ir išdidžiai pareikš „tai klaida!“ (Error): 6, 23, 33, 19 ## Error: &lt;text&gt;:1:2: unexpected &#39;,&#39; ## 1: 6, ## ^ Komanda c() į vektorių gali sujungti ne tik skaičius, bet ir kitokios klasės elementus: c(&quot;Man&quot;, &quot;puikiai&quot;, &quot;sekasi&quot;, &quot;.&quot;) ## [1] &quot;Man&quot; &quot;puikiai&quot; &quot;sekasi&quot; &quot;.&quot; Ar loginės reikšmės (angliškai vadinamos „logical“ arba „boolean“) c(TRUE, FALSE, FALSE, TRUE, TRUE) ## [1] TRUE FALSE FALSE TRUE TRUE Vektorių galime išsaugoti kaip objektą: vektorius &lt;- c(6, 23, 33, 19) Tada jį atspausdinti: vektorius ## [1] 6 23 33 19 Naudodami laužtinius skliaustus galime pasirinkti tam tikrus elementus, pvz., antrą: vektorius[2] ## [1] 23 Arba antrą ir ketvirtą: vektorius[c(2, 4)] ## [1] 23 19 Daugelis operacijų programoje R yra vektorizuotos, t. y., atliekamos kiekvienam elementui atskirai: vektorius + 100 ## [1] 106 123 133 119 Galime atlikti veiksmus su visais vektoriaus nariais iš karto: sum(vektorius) ## [1] 81 Daugiau apie matematinius veiksmus rašoma kitame poskyryje. 1.2.8 R kaip kalkuliatorius: operatoriai ir komandos Programoje R matematinius (ir kitokius) veiksmus atlieka simboliai, vadinami operatoriais (pvz., lentelėje 1.2), arba komandos, vadinamos funkcijomis (pvz., lentelėse 1.4, 1.5). Taip pat galima panaudoti ir konstantas, tokios kaip skaičius \\(\\pi\\) (lentelė 1.3). R operatoriai – tai funkcijos, užrašomos ne žodžiais, o specialiaisiais simboliais, tokiais kaip +, &lt;-, == ar %&gt;%. Lentelė 1.2: Matematinius veiksmus atliekantys R operatoriai Simbolis (operatorius) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas + Sudėtis 5 + 8 13 - Atimtis 5 - 7 -2 * Daugyba 3 * 4 12 / Dalyba 6 / 3 2 ^ Kėlimas laipsniu 3^2 9 ** Kėlimas laipsniu 3**2 9 %/% Sveikoji dalis (po dalybos) 7 %/% 3 2 %% Liekana (po dalybos) 7 %% 3 1 Veiksmai atliekami eilės tvarka, panašiai, kaip matematikoje: pirma veiksmai skliausteliuose; tada kėlimas laipsniu; tada daugyba, dalyba; tada sudėtis, atimtis. 2 * 3^2 # 2 * 9 ## [1] 18 (3 + 6)^2 - 9/3 # 9^2 - 3 ## [1] 78 21 %/% 2 ^ 2 # 21 %/% 4 ## [1] 5 Jei nesate tikri, kokia tvarka bus atlikti veiksmai – naudokite papildomus skliaustus. Tada tikrai bus aišku: (5 %/% 2) ^ 2 ## [1] 4 5 %/% (2 ^ 2) ## [1] 1 Jei yra pradžios skliaustai (, būtinai turi būti ir pabaigos skliaustai ). Lentelė 1.3: Matematinės konstantos Konstanta Reikšmė pi skaičius \\(\\pi = 3.1415926...\\) exp(1) skaičius \\(e = 2.71828...\\) Lentelė 1.4: R komandos, atliekančios dažnas matematines operacijas Funkcija (komanda) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas sqrt() Kvadratinė šaknis sqrt(4) 2 abs() Modulis (absoliučioji vertė) abs(-2) 2 sin(), cos(), tan() Trigonometrinės funkcijos (skliaustuose radianai). sin(pi/6) 0.5 exp() Eksponentė (\\(e^x\\)) exp(0) 1 log(), log2(), log10() Natūrinis (\\(\\ln{x}\\)), dvejetainis (\\(\\log_2{x}\\)) ir dešimtainis (\\(\\lg{x}\\)) logaritmai. log10(100) 2 factorial() Faktorialas (\\(4! = 4\\cdot3\\cdot2\\cdot1\\)) factorial(4) 24 choose() Binominis koeficientas \\(C^k_n\\). Taip pat žymimas \\(\\binom{n}{k} = {n! \\over k!(n-k)!}\\). choose(n = 5, k = 2) 10 Lentelė 1.5: R komandos, atliekančios apvalinimą. ¹Apvalinimas iki artimiausio sveikojo skaičiaus. Funkcija (komanda) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas round() Įprastinis apvalinimas (iki n skaičių po kablelio) round(8.275, digits = 2) 8.28 round(-8.275, digits = 2) -8.28 signif() Įprastinis apvalinimas (iki n reikšmingų skaičių) signif(8.275, digits = 2) 8.3 signif(0.0275, digits = 2) 0.028 ceiling() Apvalinimas¹ į didesnę pusę ceiling(8.275) 9 ceiling(-8.275) -8 floor() Apvalinimas¹ į mažesnę pusę floor(8.975) 8 floor(-8.975) -9 trunc() Apvalinimas¹ į nulio pusę trunc(9.99) 9 trunc(-9.99) -9 1.2.9 Specialieji simboliai Tam tikri žodžiai R kalboje yra specialieji simboliai, turintys tam tikrą paskirtį (žr. lentelėje 1.6). Parašius šiuos simbolius, programa juos atpažįsta ir įprastai netgi nudažo kita spalva. Lentelė 1.6: Specialieji simboliai. Simbolis Atliekamas palyginimas Rezultatas R komandų lange NA trūkstama reikšmė (angl., not available) NA NaN negalima skaitinė reikšmė (angl., NaN – not a numeric) NaN Inf begalybė Inf -Inf neigiama begalybė -Inf NULL tuščias narys; ištrinti NULL FALSE loginė reikšmė „netiesa“ FALSE F loginė reikšmė „netiesa“ (sutrumpintai) FALSE TRUE loginė reikšmė „tiesa“ TRUE T loginė reikšmė „tiesa“ (sutrumpintai) TRUE Pavyzdžiai, kaip gaunami arba užrašomi specialieji simboliai: 0/0 # ne skaičius (NaN - not a numeric) ## [1] NaN FALSE # loginė reikšmė „netiesa“ ## [1] FALSE F # loginė reikšmė „netiesa“ (sutrumpintai) ## [1] FALSE TRUE# loginė reikšmė „tiesa“ ## [1] TRUE T # loginė reikšmė „tiesa“ (sutrumpintai) ## [1] TRUE log(0) # neapibrėžtumas ## [1] -Inf 1.2.10 Skaičių sekų kūrimas Skaičių sekos gali būti sukuriamos keliais būdais: naudojant vieno dvitašio operatorių :. Pvz.: 3:21 sukuria seką nuo 3 iki 21 kas 1; naudojant funkciją seq() (nuo angliško žodžio sequence). Pvz.: seq(from = 1, to = 21, by = 5) sukuria seką nuo 1 iki 21 kas 5; seq(from = 1, to = 21, length.out = 4) sukuria seką nuo 1 iki 21, kurią sudaro 4 elementai; seq(from = 1, to = 21, along.with = 2:9) sukuria seką nuo 1 iki 21, kurią sudaro tiek pat elementų, kaip ir seką 2:9. sekų, kurių nariai skirstosi pagal įvairius statistinius dėsnius, kūrimas. Pvz.: rnorm(10, mean = 1, sd = 0.2) sukurs atsitiktinę seką iš 10 skaičių, pasiskirsčiusių pagal normalųjį skirstinį, kurio vidurkis 1, o standartinis nuokrypis – 0,2; rpois(10, lambda = 3) sukurs atsitiktinę seką iš 10 skaičių, pasiskirsčiusių pagal Puasono (Poisson) skirstinį, kurio parametras \\(\\lambda = 3\\); (plačiau apie šiuos dėsnius mokysimės būsimų paskaitų ir pratybų metu). Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["duomenu-isikelimas.html", "2. Duomenų įsikėlimas į R 2.1 Pasirengimas duomenų analizei 2.2 Duomenų nuskaitymas 2.3 Duomenų lentelės peržiūra", " 2. Duomenų įsikėlimas į R Šiame skyriuje bus mokoma į programas R/RStudio parengti darbui ir įsikelti duomenis. 2.1 Pasirengimas duomenų analizei Video epizodas 2.1 Pasirengimas duomenų analizei. RStudio projektų kūrimas, paketų užkrovimas. RStudio projektą su duomenimis galite parsisiųsti iš VMA (nuoroda ). 2.1.1 RStudio projektai RStudio projektai yra būdas tvarkingai organizuoti savo duomenų analizės darbus. Paveiksluose pateiktas darbo su RStudio projektais pradžiamokslis (pav. 2.1) bei pavaizduoti dalykai, į kuriuos reikia atkreipti dėmesį (pav. 2.2). Pav. 2.1: Darbo su RStudio projektais pagrindai. Pav. 2.2: RStudio projekto pavadinimas. Užkrovus RStudio projektą, matomas aplanko, kuriame yra projektas, pavadinimas (tarkime „Pratybos-2“. Jei projektas neužkrautas, matome užrašą „Project: (none). Jei užraše yra bylos plėtinio pavadinimas (.zip, .rar ar pan.), vadinasi, projektas užkrautas neteisingai, kils problemų dirbant. Plačiau apie projektus galite skaityti šiame tinklapyje (nuoroda ). 2.1.2 Lokalės ir UTF-8 standarto nustatymas Lokalė – tai nuo kalbos ir vietovės priklausančios programų, dokumentų bei teksto savybės2. Pvz., savaitės dienų pavadinimai. Tad jei dirbsite su duomenimis, kuriuose yra lietuviškų raidžių bei pavadinimų, vienas iš dalykų, kurį turite padaryti yra nusistatyti lietuviškąją lokalę. Žemiau pateiktas kodas, kaip tai padaryti sistemoje „Windows“. # Lokalės keitimas operacinėje sistemoje „Windows“ Sys.setlocale(locale = &quot;Lithuanian&quot;) Šį kodą reikia vykdyti kiekvieną kartą perkrovus programą R. UTF-8 – tai simbolių dekodavimo standartas, kuriuo kompiuteryje gali būti užrašomos ir lietuviškos raidės. Tad dirbant su lietuviškais simboliais įprastai reikia pasirinkti UTF-8 standartą. Kaip tai atlikti, rašoma priedo A skyriuje apie „RStudio“ konfigūravimą. Tai užtenka padaryti pirmą kartą įsidiegus programą. 2.1.3 R paketų užkrovimas R paketai, tai standartizuoti R papildiniai, kuriuose gali būti funkcijos, duomenys, dokumentacija ir kiti R priedai. Norint naudoti funkcijas esančias paketuose, šiuos reikia užkrauti. Paketai užkraunami naudojant funkciją library() („iš bibliotekos kompiuteryje užkrauk paketą…“) jos skliaustuose parašius paketo pavadinimą arba prie reikiamo paketo pavadinimo padėjus varnelę RStudio lange „Packages“. 2.2 Duomenų nuskaitymas Šiame skyriuje pademonstruosiu, kaip nuskaityti duomenis iš kelių dažnai pasitaikančių duomenų bylų formatų. Pav. 2.3: Pagrindiniai bylų su duomenimis formatai dirbant programa R. RStudio projektą su duomenimis, kurie demonstruojami video epizoduose, galite parsisiųsti iš VMA (nuoroda ). 2.2.1 „R“ objektų pavadinimai Į R atmintį keldami duomenis ir kurdami jų (R objektų) pavadinimus vadovaukitės tokiomis taisyklėmis: pirmasis simbolis privalo būti raidė; pavadinime gali būti tik mažosios raidės, skaičiai ir apatinis brūkšnys. Tokiu būdu išvengsite daugelio problemų. Plačiau galite skaityti tidyverse stiliaus gide, skyriuje apie R objektų pavadinimus (nuoroda ). 2.2.2 Programos R formatais išsaugotų duomenų nuskaitymas Video epizodas 2.2 Programos R paketuose esančių duomenų nuskaitymas. Video epizodas 2.3 Programos R formatais .RData bei .Rds išsaugotų duomenų nuskaitymas. 2.2.3 Duomenų užkrovimas iš R paketų Pav. 2.4: Duomenų iš R paketų užkrovimas. Šio tipo duomenys užkraunami naudojant komandą data(). Vos parašius šią komandą, RStudio ima siūlyti galimus duomenų rinkinių pavadinimus, kuriuos galima pasirinkti pele. Funkcija data() įprastai įvykdo tik pirminį įkėlimą ir rezervuoja pavadinimą R atmintyje, todėl matome užrašą „promise“. Galutinis įkėlimas į R atmintį įvyksta, kai su duomenimis atliekame kokį nors veiksmą, pavyzdžiui, panaudoję funkciją dim() nustatome duomenų lentelės eilučių ir stulpelių skaičių. 2.2.4 .RData formato bylų nuskaitymas Pav. 2.5: Programos R „.Rdata“ formato duomenų nuskaitymas. Bylų plėtinys gali būti .Rda, .RData, .Rdata ar analogiškas. Jei R atmintyje yra objektas (žiūrėti RStudio lange „Environment“) tokiu pat pavadinimu, kaip ir „.RData“ byloje, tai atidarius šią bylą senasis objektas iš atminties bus ištrintas ir pakeistas naujuoju, kuris yra atidaromoje byloje. Būkite atidūs, kad neprarastumėte svarbių duomenų. 2.2.5 .Rds formato bylų nuskaitymas Pav. 2.6: Programos R „.Rds“ formato duomenų nuskaitymas. Bylų plėtinys gali būti .Rds, .RDS, .rds ar analogiškas. 2.2.6 Tekstinio skirtukais atskirtų reikšmių formato nuskaitymas Tekstinėse bylose duomenų lentelės gali būti išsaugotos keliomis formomis. Nagrinėjant skirtukais atskirtų reikšmių formatą esminiai dalykai, kuriuos reikia pastebėti prieš nuskaitant duomenis: Sveikosios ir dešimtosios skaičiaus dalies skirtukas (angl., decimal separator). Juo gali būti arba taškas (., angl. period), arba kablelis (,, angl. comma); Stulpelių skirtukas (angl., field separator, delimiter). Juo gali būti kablelis, kabliataškis (angl., semicolon), tarpas, tabuliacija („ilgas tarpas“), vertikalus brūkšnys (|) ar kitoks simbolis, bet ne taškas. Vienas iš dažniausių tekstinių duomenų formatų – .csv (angl. comma sepatated values). Šios rūšies formatai būna 2 tipų: csv 1 („amerikietiškasis“) formatas, kuriame stulpelio skirtukas yra kablelis (,), o sveikosios ir dešimtosios skaičiaus dalių skirtukas yra taškas (.). csv 2 („europietiškasis“) formatas, kuriame stulpelio skirtukas – kabliataškis (;), o sveikosios ir dešimtosios dalių skirtukas – kablelis (,). Tekstinių bylų pavyzdžiai pateikti pav. 2.7. Pav. 2.7: Tekstinėse bylose skirtukais atskirtų reikšmių formatu saugomų duomenų pavyzdžiai. Video epizodas 2.4 Tekstinėse bylose esančių skirtukais atskirtų reikšmių formatu išsaugotų duomenų nuskaitymas naudojant RStudio langą „Import Dataset“ „From Text (base)…“ Pav. 2.8: Skirtukais atskirtų duomenų nuskaitymas iš tekstinių bylų naudojant RStudio langą „Import Dataset“ „From Text (base)…“ Jei skaičiai į programą R nuskaityti teisingai, tai programoje R tarp sveikosios ir dešimtosios dalies privalo būti taškas, o ne kablelis, pvz., 22.6. Paveiksle 2.8 rodoma, kaip nuskaityti duomenis naudojant RStudio. Šios programos lange „Environment“ \\((A_1)\\) spaudžiame mygtuką „Import Dataset“ \\((A_2)\\), po to „From Text (base)“ \\((A_3)\\). Tai bazinis (ne tidyverse), labai automatizuotas statistinei analizei tinkamas tekstinių duomenų nuskaitymo būdas. Ko gero, labiausiai suprantamas pradedantiesiems. Atsidariusiame lange susirandame aplanką su duomenimis ir pasirenkame tekstinių duomenų bylą \\((B)\\). Atsidaro nuskaitymo meniu, kuriame matome pirmąsias duomenų bylos eilutes \\((C_1)\\), pagal jas programa automatiškai parenka nuskaitymo parametrus ir juos įrašo parametrų pasirinkimo langeliuose \\((C_2)\\). Dažniausiai koreguoti nereikia. Jei reikia – pakereguojame. Apatiniame lange \\((C_3)\\) galime pasitikrinti, ar duomenys bus nuskaityti teisingai: stulpelių pavadinimai pajuodinti, o patys duomenys – atskiruose stulpeliuose, aiškiai atskirtuose tarpais. Belieka parašyti duomenų lentelės pavadinimą \\((C_4)\\), kuriame gali būti tik angliškos raidės, apatiniai brūkšniai ir skaičiai, pirmasis simbolis – raidė. Kitų simbolių, pvz., tarpų, taškų, naudoti nerekomenduoju. Uždedame varnelę ties užrašu „Strings as Factors“ \\((C_5)\\): tekstiniai kintamieji („strings“) bus paverčiami į faktorius („factors“) – statistinei analizei tinkamą kategorinių kintamųjų tipą. Galiausiai spaudžiame „Import“ \\((C_6)\\). RStudio konsolėje atspausdinamas duomenų nuskaitymui naudojamas programos kodas. Norėdami ji nusikopijuoti, galite žymeklį padėti konsolės lange ir klaviatūroje paspausti rodyklę į viršų ↑. Atsiras nuskaitymo kodas be papildomų nereikalingų simbolių, kurį patogu kopijuoti. 2.2.7 Funkcija fread() Funkcija yra fread() iš paketo data.table skirta efektyviam duomenų, išsaugotų tekstiniu skirtukais atskirtų reikšmių formatu, nuskaitymui Funkcijos privalumas tas, kad ji dažniausiai automatiškai atpažįstą daugelį standartinių parametrų: koks sveikosios ir dešimtosios dalies skirtukus (taškas ar kablelis), koks stulpelių skirtukus, ar lentelės stulpeliai turi pavadinimus, kiek pirmųjų eilučių reikia praleisti ir teisingai nuskaito duomenis. Be to ji yra labai greita, nes parašyta programavimo kalba – C++. Keliuose tolimesniuose pavyzdžiuose bus naudojami duomenys (arba jų fragmentai), pateikti šiame tinklapyje, duomenų aprašymą galite rasti čia. Užkrauname paketą: library(data.table) Pirmame pavyzdyje duomenys nuskaityti iš bylos, esančios mano kompiuteryje. Byloje stulpeliai neturi pavadinimų, pirmosios 3 eilutės – papildoma informacija (kaip matote, ji nenuskaitoma). Jūs šiuos duomenis galite atsisiųsti iš čia. # Nuskaitome duomenis kaip tekstą (eilutė po eilutės) tekstas &lt;- readLines(&quot;duomenys/Diseaseoutbreak.txt&quot;) # Atspausdiname 10 pirmų eilučių writeLines(tekstas[1:10]) ## Source: http://calcnet.mth.cmich.edu/org/spss/V16_materials/DataSets_v16/Diseaseoutbreak.dat ## Description: http://calcnet.mth.cmich.edu/org/spss/Prj_diseaseData.htm ## ## 1 33 1 1 0 1 ## 2 35 1 1 0 1 ## 3 6 1 1 0 0 ## 4 60 1 1 0 1 ## 5 18 3 1 1 0 ## 6 26 3 1 0 0 ## 7 6 3 1 0 0 # Duomenys nuskaityti iš bylos, esančios kompiuteryje. is_bylos &lt;- fread(&quot;duomenys/Diseaseoutbreak.txt&quot;) ## Warning in fread(&quot;duomenys/Diseaseoutbreak.txt&quot;): Stopped early on line 3. ## Expected 2 fields but found 0. Consider fill=TRUE and comment.char=. First ## discarded non-empty line: &lt;&lt;1 33 1 1 0 1&gt;&gt; head(is_bylos) ## Source: ## 1: Description: ## http://calcnet.mth.cmich.edu/org/spss/V16_materials/DataSets_v16/Diseaseoutbreak.dat ## 1: http://calcnet.mth.cmich.edu/org/spss/Prj_diseaseData.htm Antrame pavyzdyje duomenys nuskaityti iš bylos, esančios internete. Byloje stulpeliai neturi pavadinimų, tačiau praleistų eilučių bylos pradžioje nėra. # Duomenys nuskaityti iš bylos, esančios internete. is_interneto &lt;- fread(&quot;http://calcnet.mth.cmich.edu/org/spss/V16_materials/DataSets_v16/Diseaseoutbreak.txt&quot;) head(is_interneto) ## V1 V2 V3 V4 V5 V6 ## 1: 1 33 1 1 0 1 ## 2: 2 35 1 1 0 1 ## 3: 3 6 1 1 0 0 ## 4: 4 60 1 1 0 1 ## 5: 5 18 3 1 1 0 ## 6: 6 26 3 1 0 0 Trečiame pavyzdyje nukopijuotos 9 šių duomenų eilutės, ir parašytos kaip tekstas (kabutėse). Duomenų stulpeliams suteikiau pavadinimus. Jokių kitų parametrų nepateikiau, o duomenys nuskaityti teisingai. # Duomenys pateikti kaip tekstas, stulpeliai turi pavadinimus is_teksto &lt;- fread(&quot; Subject Age Class Sector Disease Account 1 33 1 1 0 1 2 35 1 1 0 1 3 6 1 1 0 0 4 60 1 1 0 1 5 18 3 1 1 0 6 26 3 1 0 0 7 6 3 1 0 0 8 31 2 1 1 1 9 26 2 1 1 0 &quot;) head(is_teksto) ## Subject Age Class Sector Disease Account ## 1: 1 33 1 1 0 1 ## 2: 2 35 1 1 0 1 ## 3: 3 6 1 1 0 0 ## 4: 4 60 1 1 0 1 ## 5: 5 18 3 1 1 0 ## 6: 6 26 3 1 0 0 Jei jūsų kompiuteryje yra įdiegtas paketas data.table, daugiau apie funkciją fread() galite sužinoti į R komandų langą suvedę: ?fread 2.3 Duomenų lentelės peržiūra Įsikėlus duomenis įprasta juos peržiūrėti. Tai daroma siekiant susipažinti su duomenimis, jų struktūra, bei patikrinti, ar jie buvo įkelti taip, kaip tikėjomės. 2.3.1 Duomenys, kuriuos naudosime Šio skyriaus pavyzdžiuose ir klausimuose naudosime duomenų lenteles iris, npk, swiss bei women, kurios yra R paketo datasets dalis. Daugiau apie lenteles rašoma jų dokumentacijoje, kuri atveriama pele pažymėjus lentelės pavadinimą, parašytą redaktoriaus lange arba konsolėje, ir paspaudus F1. Taip pat parašius tokią komandą: klaustuką ? ir po jo – lentelės pavadinimą, pvz., ?iris, ?npk ar ?swiss (vieną komandą vienu metu). Jei naudojate RStudio, aprašymai atsiras „Help“ kortelėje. Duomenis iš paketo užsikraukime naudodami funkciją data(): data(&quot;iris&quot;) data(&quot;npk&quot;) data(&quot;swiss&quot;) data(&quot;women&quot;) 2.3.2 Pagrindinės peržiūros funkcijos Įsikėlus duomenų lenteles, įprasta susipažinti su duomenų lentelės struktūra ir susidaryti įspūdį, koks jos turinys. Tam naudingos funkcijos, kurių skliaustuose nurodomas dominančios lentelės pavadinimas be kabučių: class() – rodyti duomenų lentelės R klasę. Jei yra kelios klasės, žiūrėkite į pirmąją. Įprastai lentelės skiriasi tik tuo, kaip yra atspausdinamos: įprastinė duomenų lentelė (klasė data.frame); „tibble“ duomenų lentelė (klasė tbl_df, oficiali tidyverse duomenų lentelės klasė iš paketo tibble); data.table klasės duomenų lentelė (iš paketo data.table. Šis paketas skirtas didelėms duomenų lentelėms, kai norima didelės spartos apdorojant duomenis). dim() – rodyti dimensiją: eilučių ir stulpelių skaičių lentelėje (galioja ES taisyklė – pirma eilutės, po to stulpeliai); glimpse() iš paketo dplyr (patogesnis str() analogas) – glaustai rodyti struktūrą: eilučių (Observations) ir stuplelių (Variables) skaičių, stulpeliuose esančių duomenų tipus ir kelias pirmąsias reikšmes; View() – peržiūrėti lentelę atskirame lange; head() – rodyti pirmąsias eilutes; tail() – rodyti paskutines eilutes; names() – rodyti kintamųjų pavadinimus; colnames() – rodyti stulpelių pavadinimus; rownames() – rodyti eilučių pavadinimus. Jei, tarkime, norime patyrinėti duomenų lentelę iris – štai keletas pavyzdžių, kaip naudoti šias funkcijas: library(dplyr) # Toliau lentelės pavadinimą rašome be kabučių, # nes „iris“ — „R“ atmintyje esantis objektas: dim(iris) head(iris) tail(iris) glimpse(iris) Užduotis 2.1 Naudodamiesi funkcijomis class(), dim(), glimpse(), head(), tail(), names(), colnames(), rownames(), View(), patyrinėkite duomenų lenteles iris, npk, swiss, women. Jos užkraunamos iš R paketo datasets. Atsakykite į klausimus: Kokia duomenų lentelės klasė? Ar „data.frame“? Kiek lentelėje objektų? Kiek kintamųjų? Kokie kintamųjų pavadinimai? Ar lentelė turi eilučių pavadinimus, ar tik eilučių numerius? 2.3.3 Kaip atpažinti stulpeliuose esančių duomenų klases? Kiekvienas stulpelis lentelėje yra tam tikro tipo statistinis kintamasis. R kiekvienam kintamajam – lentelės stulpeliui – suteikia R objekto klasę, kurią galime sužinoti keliais būdais. Jei duomenų lentelę atspausdinsime R Markdown dokumente dirbami Notebook režimu (kol kas nesimokėme), rezultatas bus panašus į tą, kuris pateiktas paveiksle 2.9. Pav. 2.9: Duomenų lentelė atspausdinta R Markdown dokumente dirbant Notebook režimu. Kintamųjų (lentelės stulpelių) klasės pateiktos po pavadinimais trikampiuose skliaustuose. Eilučių skaičius – lentelės apačioje („4 rows“). Naudodami funkciją glimpse(), gausime tokį rezultatą: ## Observations: 4 ## Variables: 6 ## $ lapu_skaicius &lt;int&gt; 24, 22, 28, 25 ## $ lapu_ilgis &lt;dbl&gt; 1.3, 1.6, 2.2, 1.1 ## $ kvapo_stiprumas &lt;ord&gt; silpnas, vidutinis, stiprus, stiprus ## $ ziedu_spalva &lt;fct&gt; raudona, geltona, geltona, balta ## $ ar_augo_lauke &lt;lgl&gt; FALSE, TRUE, TRUE, FALSE ## $ komentaras &lt;chr&gt; &quot;-&quot;, &quot;-&quot;, &quot;tirta ryte&quot;, &quot;-&quot; Čia R parašo eilučių (4) ir stulpelių (6) skaičių, išvardija kintamųjų pavadinimus (lapu_skaicius, lapu_ilgis, …), jų klases (int, num ir t.t.), kelias pirmąsias reikšmes (pvz., 24, 22, 28, …) Sutrumpinti duomenų lentelių R klasių žymėjimai: dbl (double) arba num (numeric) – realusis skaičius (skaičius su kableliu); int (integer) – sveikasis skaičius; fctr arba Factor – faktorius, kategorinis (nominalusis) kintamasis, kurio reikšmės neturi natūralios tvarkos; ord arba Ord.factor (ordered factor) – ranginis kintamasis (faktorius, kurio reikšmės turi eilės tvarką); lgl arba logi (logical) – loginis kintamasis; chr (character) – tekstas (simbolių eilutės). Galimos kitos rečiau pasitaikančios klasės, pvz., laiko ir datos formatai (pvz., POSIXct), kurių kol kas nenagrinėsime. Užduotis 2.2 Naudodami funkciją „glimpse()“, nustatykite duomenų lentelių iris, npk, swiss bei women stulpelių klases. 2.3.4 Teorinis duomenų tipas ir jam tinkama R klasė Statistikos kurso metu dirbsime tik su kiekybiniais (skaitiniais) ir su kategoriniais (nominaliaisiais ir ranginiais) kintamaisiais. R aplinkoje kintamiesiems turi būti parinktos tinkamos klasės. Tada R braižys tinkamus grafikus, atliks tinkamas statistines suvestines, leis atlikti tai duomenų klasei tinkamus statistinius testus. Teoriniai kintamųjų tipai ir jiems tinkamos R klasės: Kiekybiniams (skaitiniams): tolydiesiems tinka: klasė „numeric“ (dar vadinama „double“) – įprastinis pasirinkimas. klasė „integer“ – taip pat tinka; diskretiesiems tinka: klasė „integer“ – įprastinis pasirinkimas; klasė „numeric“ („double“) – taip pat tinka. Kokybiniams (kategoriniams): nominaliesiems – klasė „factor“; ranginiams – klasė „ordered“. Statistinei analizei klasės „logical“ bei „character“ įprastai yra netinkamos. Jos verčiamos į kategoriniams duomenims tinkamas klases. (Kintamųjų klasės keitimas – būsimų pratybų tema). Užduotis 2.3 Dar kartą patyrinėkite duomenų lenteles iris, npk, swiss bei women: Kas yra tiriamieji? (Skaitykite duomenų lentelės aprašyme – dokumentacijoje). Koks kintamojo tipas (tolydieji, diskretieji, ranginiai, nominalieji duomenys) turėtų tikti kiekvienam stulpeliui teoriškai? Atsakymą grįskite duomenų lentelės aprašyme (dokumentacijoje) pateikta informacija, bei funkcijos „glimpse()“ rezultatais. Kokiomis R objektų klasėmis išsaugoti šie kintamieji iš tiesų? Ar pagal teorinį kintamųjų tipą (nominalusis, ranginis, diskretusis, tolydusis) R klasės (factor, ordinal, numeric, integer ir kitos) parinktos tinkamai? Atsakymą apie kintamuosius surašykite į tokią lentelę: Lentelės pavadinimas Kintamojo pavadinimas Teorinis kintamojo duomenų tipas Kintamojo R klasė Ar klasė duomenims parinkta teisingai? … … … … … … … … … … Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. Šis paaiškinimas yra smarkiai supaprastintas. Tikslesnį galite rasti šiame žodyne (nuoroda ).↩ "],
["grafikai.html", "3. Grafinės suvestinės 3.1 Teorinė dalis 3.2 Sistema ggplot2: įvadas", " 3. Grafinės suvestinės 3.1 Teorinė dalis Šioje dalyje pateikta teorinė medžiaga apie dažnai statistinėms suvestinėms atlikti naudojamus grafikus. Peržiūrėkite šioje dalyje pateiktą video medžiagą, išnagrinėkite grafikus. Bet pirmiausia keletas svarbių sąvokų: Kintamojo reikšmių pasiskirstymas, arba skirstinys (angl. distribution), – tai būdas arba taisyklė, kaip išsidėsto mūsų tiriamo kintamojo reikšmės: kai kurios reikšmės pasitaiko dažniau, kai kurios rečiau, kai kurių gali apskritai nebūti. Statistinis dažnis (angl. frequency) parodo, kaip dažnai reikšmė pasitaiko duomenų eilutėje. Dažnių lentelė (angl. frequency table) – parodo, kaip dažnai kiekviena iš reikšmių pasitaiko arba kaip dažnai patenka į tam tikrą reikšmių intervalą. Reikšmių grupavimas į intervalus angliškai vadinamas binning, o tokio tipo intervalas – bin. Mediana (žymėsime Md) – tai reikšmė, duomenų eilutę dalinanti į 2 lygias dalis. Įprastai tai vidurinė duomenų eilutės reikšmė arba dviejų vidurinių reikšmių vidurkis. Moda (žymėsime Mo) – dažniausiai pasitaikanti duomenų eilutės reikšmė. Taip pat moda galima vadinti dažniausiai pasitaikančių reikšmių intervalą, jei duomenys grupuoti. Duomenų sklaidos matai parodo, ar duomenys nuo centro nutolę daug, ar nedaug. 3.1.1 Grafikai vieno kintamojo apibendrinimui Kategoriniams nominaliesiems, ranginiams ir diskretiesiems duomenims Video epizodas 3.1 Stulpelinė diagrama. Tolydiesiems duomenims Video epizodas 3.2 Histograma. Pav. 3.1: Pavyzdys, kaip analizuoti histogramą. Pav. 3.2: Histogramos grupavimo intervalo pločio parinkimas. A – per siauras intervalas (per didelis intervalų skaičius) išryškina triukšmą ir paslepia tendenciją. D – per platūs intervalai (per mažas intervalų skaičius) taip pat paslepia tikrąją tendenciją. B, C – tinkamai parinktas intervalų skaičius, matoma tendencija. B – geriausias variantas. Įprastai reikia tarp 5 ir 15 intervalų. Video epizodas 3.3 Branduolinio tankio diagrama. Pav. 3.3: Vienas duomenų taškas atvaizduotas branduoline kreive. Branduolinio tankio diagramoje vienas taškas aprašomas kreive, vadinama branduoliu, kuri ties centru aukščiausia, o į kraštus mažėja. Pavyzdyje (A, B, C, D) tai Gauso kreivės, kurios gali skirtis savo pločiu. Branduolio formą ir plotį pasirenka tyrėjas, visgi kiekvienam grafiko taškui aprašyti naudojami identiški branduoliai. Pav. 3.4: Branduolinio tankio diagramoje (BTD) atvaizduoti visi duomenų eilutės taškai. Svarbu pasirinkti tinkamą branduolio plotį. A – per siauri branduoliai ne pakankamai gerai suglotnina kreivę, matosi triukšmas, sunku įžiūrėti tendenciją; D – per platūs branduoliai per daug suglotnina duomenis, BTD smarkiai išeina už realių duomenų ribų, taip pat nesimato tikrosios tendencijos; B, C – pakankamai gerai parinktas branduolio plotis; C – geriausias variantas. Pav. 3.5: Informacijos branduolinio tankio (BTD) ir stačiakampėje diagramoje palyginimas. Abiejų tipų diagramose atvaizduoti tie patys duomenys. \\(Md\\) – mediana, \\(Q_1\\), \\(Q_3\\) – pirmasis ir trečiasis kvartiliai. Pav. 3.6: Branduolinio tankio diagramos (BTD) naudojimas grupių lyginimui. Iš grafiko matosi, kad S. pratensis augalai turėjo santykinai daugiau ilgesnių stiebų nei S. officinalis (nes mėlynas grafikas pasislinkęs į didesnių reikšmių pusę). Video epizodas 3.4 Stačiakampė diagrama (J.W. Tukey stiliaus). Video epizodas 3.5 Stačiakampė, smuikinė ir pasklaidytų taškų diagramos. 3.1.2 Diagramų palyginimas Šiame poskyryje bus palyginta informacija, kuri matosi skirtingų tipų vieno kintamojo suvestinėms skirtuose grafikuose. Apibendrintas diagramų palyginimas pateiktas lentelėje 3.1. Lentelė 3.1: Vieno kintamojo grafikų palyginimas Diagrama Centras¹ Sklaida Kelios viršūnės Asimetrija Imties dydis Būtini parametrai² Stulpelinė diagrama Moda\\(^*\\) Matosi Matosi Matosi Matosi tiksliai³ nėra Pasklaidyti taškai (matosi apytiksliai) Matosi Matosi Matosi Matosi preliminariai taškų pasklaidymo plotis Histograma Moda\\(^*\\) Matosi Matosi Matosi Matosi tiksliai³ grupavimo intervalų skaičius/ilgis Branduolinio tankio diagrama Moda\\(^*\\) Matosi Matosi Matosi Ne branduolio forma ir plotis Stačiakampė diagrama Mediana Matosi Ne Matosi Ne nėra Smuikinė diagrama Moda\\(^*\\) Matosi Matosi Matosi Ne branduolio forma ir plotis ¹ – centras, kuris matosi geriausiai arba matosi apskritai; ² – parametrai, kuriuos būtina pasirinkti prieš braižant grafiką; ³ – matosi tiksliai, jei y ašyje atidėtas atvejų skaičius, o ne procentai ar atvejų dalis. \\(^*\\) – tiksli pozicija priklauso nuo parinktų parametrų. Grafiniam informacijos palyginimui, pateiktam šio poskyrio grafikuose 3.7, 3.8, 3.9, 3.10, 3.11, 3.12, buvo dirbtinai sugeneruoti duomenys. Kintamasis „Reikšmė“ padalintas į 8 duomenų grupės (nuo A iki H). Grupė A yra kontrolinė. Visos kitos nuo jos skiriasi pagal vieną konkretų požymį: imties dydį (n): A grupėje n = 250 (didesnė grupė), B – n = 63 (keturis kartus mažesnė grupė); centro padėtį: A vidurkis yra 50 (vidutiniškai didesnės reikšmės), C – 40 (vidutiniškai mažesnės reikšmės); sklaidą: A standartinis nuokrypis (SD) yra 5 (mažesnė sklaida), D – 10 (didesnė sklaida); viršūnių skaičių: A viena viršūnė, E – dvi viršūnės; simetriją: A pasiskirstymas simetriškas, F – dešinioji asimetrija (skirstinio „uodega“ nutįsusi į didelių reikšmių pusę); simetriją: A pasiskirstymas simetriškas, G – kairioji asimetrija (skirstinio „uodega“ nutįsusi į mažų reikšmių pusę); išskirtis: A ryškių išskirčių nėra, H – yra du labai smarkiai nuo centro nutolę taškai. Peržvelkite žemiau pateiktus grafikus ir įvertinkite, kaip ši informacija juose matoma. Pav. 3.7: Grupių palyginimas duomenis atvaizduojant taškais. Visi taškai išsidėstę į vieną liniją. Kai taškai persidengia, grafikas tampa mažai informatyvus. Pav. 3.8: Grupių palyginimas duomenis atvaizduojant pasklaidytų taškų diagrama. Siekiant išvengti persidengimo, taškai pasklaidyti x ašiai lygiagrečia kryptimi. Pav. 3.9: Grupių palyginimas duomenis atvaizduojant histograma. Pav. 3.10: Grupių palyginimas duomenis atvaizduojant branduolinio tankio diagrama (BTD). Pav. 3.11: Grupių palyginimas duomenis atvaizduojant stačiakampe diagrama. Pav. 3.12: Grupių palyginimas duomenis atvaizduojant smuikine diagrama. 3.2 Sistema ggplot2: įvadas R papildinys ggplot2 yra tidyverse šeimos paketas, skirtas aukštos kokybės grafikams braižyti. Šis paketas veikia „grafikos gramatikos“ principais (angl. grammar of graphics, dvi pirmosios raidės „gg“ žodyje „ggplot“) – tai nuosekli grafikų konstravimo ir braižymo sistema. Paketo ggplot2 privalumas tai, kad ganėtinai mažomis pastangomis galima sukonstruoti ganėtinai gražius grafikus, yra daugybė paketų, išplečiančių galimybes, įrankių, supaprastinančių darbą su ggplot2 bei galimybė grafikus paversti interaktyviais (tokiais, kuriuos galima didinti, mažinti, sužinoti taškų koordinates). Grafikos gramatikos idėja. Bet kokioje žmonių kalboje sakinius sudaro įvairios kalbos dalys – daiktavardžiai, būdvardžiai, prieveiksmiai, veiksmažodžiai… Sakiniai konstruojami į vieną visumą pagal taisykles jungiant šias kalbos dalis. Analogiškai grafikus sudaro įvairūs elementai – duomenys, koordinačių sistema, ašys, geometrinės figūros, estetiniai elementai, tokie kaip spalvos, formos, linijų storiai, ir kiti komponentai. Tad sluoksnis po sluoksnio sudedant šiuos elementus galima sukonstruoti grafiką. Šio užsiėmimo tikslas – išmokti atlikti grafines duomenų suvestines naudojantis ggplot2 sistema. 3.2.1 Pasirengimas darbui Šioms pratyboms yra sukurtas RStudio projektas. Jį galite rasti VMA. Darbui reikalingi R paketai: ggplot2, plotly, ggedit, ggplotgui, easyPlot. # Diegimo instrukcijos # Diegimas iš saugyklos CRAN install.packages(c(&quot;ggplot2&quot;, &quot;plotly&quot;, &quot;ggedit&quot;, &quot;ggplotgui&quot;)) # `easyPlot` diegmimas iš saugyklos GitHub install.packages(&quot;devtools&quot;) devtools::install_github(&quot;majkamichal/easyPlot&quot;) Paketo ggplot2 dokumentacija internete: ggplot2.tidyverse.org/reference/ Pav. 3.13: Grafikų braižymo sistemos ggplot2 atmintinės miniatiūra. Esminę informaciją (su iliustracijomis) kaip naudoti ggplot2 rasite atmintinėje (nuoroda ), kurios pirmojo puslapio miniatiūrą matote paveiksle 3.13. Užduotis 3.1 Iš VMA parsisiųskite šioms pratyboms skirtą RStudio projektą (nuoroda) ir tinkamu būdu jį išsiarchyvuokite ir atsidarykite. Susikurkite naują „R Script“ dokumentą, ir projekto aplanke išsaugokite pavadinimu „ggplot2 grafikai.R“ . Dokumento viršuje užrašykite kodą, nustatantį lietuviškąją lokalę, pvz., Sys.setlocale(locale = &quot;Lithuanian&quot;) (kodas veiks tik Windows sistemoje. Taip pat pastebėkite, kad kabutės – „literatūrinės“, o ne „kompiuterinės“, todėl nusikopijavus, jas reikia pakeisti tinkamomis). Dokumentą išsaugokite. Patikrinkite, ar jūsų kompiuteryje yra visi reikiami R paketai. Jei ne – įsidiekite juos. Kol kas užsikrauti nereikia. Parsisiųskite ggplot2 atmintinę (nuoroda). Ją išsisaugokite projekto aplanke. Atsidarykite internetinę ggplot2 dokumentacijos versiją (nuoroda). Dokumentacijos nuorodą išsisaugokite projekto aplanke. Prieš pradėdami braižyti grafikus, privalome atlikti 2 veiksmus: Užsikrauti reikiamus paketus; Įsikelti duomenis. Užsikraukime paketus: library(ggplot2) library(dplyr) arba tiesiog: library(tidyverse) Įsikelkime duomenis trees (juodųjų vyšnių tyrimas), CO2 (žolinių augalų \\(CO_2\\) įsisavinimo tyrimas), BOD (biocheminis deguonies poreikis), iris (irisų tyrimas) ir peržvelkime juos: data(trees) glimpse(trees) ## Observations: 31 ## Variables: 3 ## $ Girth &lt;dbl&gt; 8.3, 8.6, 8.8, 10.5, 10.7, 10.8, 11.0, 11.0, 11.1, 11.2... ## $ Height &lt;dbl&gt; 70, 65, 63, 72, 81, 83, 66, 75, 80, 75, 79, 76, 76, 69,... ## $ Volume &lt;dbl&gt; 10.3, 10.3, 10.2, 16.4, 18.8, 19.7, 15.6, 18.2, 22.6, 1... data(CO2) glimpse(CO2) ## Observations: 84 ## Variables: 5 ## $ Plant &lt;ord&gt; Qn1, Qn1, Qn1, Qn1, Qn1, Qn1, Qn1, Qn2, Qn2, Qn2, Qn... ## $ Type &lt;fct&gt; Quebec, Quebec, Quebec, Quebec, Quebec, Quebec, Queb... ## $ Treatment &lt;fct&gt; nonchilled, nonchilled, nonchilled, nonchilled, nonc... ## $ conc &lt;dbl&gt; 95, 175, 250, 350, 500, 675, 1000, 95, 175, 250, 350... ## $ uptake &lt;dbl&gt; 16.0, 30.4, 34.8, 37.2, 35.3, 39.2, 39.7, 13.6, 27.3... data(BOD) glimpse(BOD) ## Observations: 6 ## Variables: 2 ## $ Time &lt;dbl&gt; 1, 2, 3, 4, 5, 7 ## $ demand &lt;dbl&gt; 8.3, 10.3, 19.0, 16.0, 15.6, 19.8 data(iris) glimpse(iris) ## Observations: 150 ## Variables: 5 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,... ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1,... ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5,... ## $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1,... ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, s... Konsolėje įrašę ?trees, ?CO2, ?BOD bei ?iris (vieną komandą vienu metu), duomenų aprašymus galime pamatyti „Help“ lange. Užduotis 3.2 Užsikraukite reikiamus paketus: Dokumente „ggplot2 grafikai.R“ susikurkite skyrių „Paketų užkrovimas“. Šiam tikslui naudinga greitoji klavišų kombinacija Ctrl+Shift+R. Parašykite paketus užkraunantį programos kodą; Kodą įvykdykite (vien parašymas paketų neužkrauna) paspausdami „Run“ mygtuką arba greitąją klavišų kombinaciją Ctrl+Enter. Prieš tai atliekant, žymeklis turi mirksėti eilutėje su komandomis arba komandos turi būti pažymėtos pele; Iš R paketo datasets įsikelkite duomenis trees, CO2, BOD, iris. Susikurkite skyrių „Duomenų nuskaitymas“; Kodą įrašykite šiame skyriuje. Patyrinėkite duomenų struktūrą naudodami glimpse() ir View(). Kodą įrašykite skyriuje „Duomenų peržiūra“. Peržvelkite duomenų lentelių aprašymus dokumentacijoje. Pakeitimus dokumente „ggplot2 grafikai.R“ išsaugokite (nuo šiol tai darykite nuolat). 3.2.2 Pirmasis grafikas Naudodami duomenų lentelę „trees“, nusibraižykime grafiką, kuriame vaizduojama, kaip nuo medžio storio (Girth) priklauso medienos tūris (Volume): ggplot(data = trees, mapping = aes(x = Girth, y = Volume)) + geom_point() Šis grafikas vadinamas sklaidos diagrama. Užduotis 3.3 Dokumente „ggplot2 grafikai.R“ susikurkite naują skyrių, pasivadinkite jį „Pirmasis grafikas“. Į dokumentą nusikopijuokite grafiko braižymui skirtą kodą ir nusibraižykite pavyzdyje parodytą grafiką: Geriausia, kad, prieš vykdant kodą, kursorius mirksėtų ties žodžiu „ggplot“ arba pele būtų pažymėtos visos grafiką braižančios komandos (nuo „ggplot“ iki „geom_point“); Grafikas atsiras „Plots“ kortelėje; Jūsų kompiuteryje grafiko tema bus standartinė – pilka (vadovėlyje – balta). Dokumentą su kodu išsaugokite: Turėdami kodą, grafiką bet kada galėsite susigeneruoti iš naujo. 3.2.3 Kaip konstruojami „ggplot2“ grafikai? Sistemos ggplot2 grafikai braižomi taip vadinamais sluoksniais. Praeito poskyrio programos kode matome tokius elementus: funkciją ggplot() – ggplot2 grafikai įprastai pradedami braižyti parašius funkciją ggplot(), kuri sugeneruoja pradinius grafiko sluoksnius. Funkcijos skliaustuose nurodomi elementai, bendri visiems sluoksniams; argumentą data – šioje vietoje nurodoma duomenų lentelė. Dauguma tidyverse šeimos funkcijų pasižymi tuo, kad pirmasis argumentas yra duomenų lentelė. ggplot() – viena iš jų; mapping (liet. išdėstymas) – tai argumentas, kuriame aprašoma, kaip duomenys bus išdėstyti. Išdėstymas nurodomas funkcijos aes() (nuo angl. aesthetics, liet. estetika) skliaustuose. Pirmojo grafiko pavyzdyje x ašyje išdėstytos kintamojo „Girth“ reikšmės, y ašyje – „Volume“ reikšmės. funkcijos aes() skliaustuose kintamųjų pavadinimai nurodomi be kabučių. Tai būdinga daugeliui kitų tidyverse funkcijų ir rodo, kad funkcija labiau skirta interaktyviai analizei, o ne programavimui. To mums ir reikia; funkciją geom_point() – tai grafiko sluoksnis, kuris nurodo, kad duomenys bus atvaizduoti geometrinėmis figūromis – taškais. operatorių „+“ – sluoksniai (grafiką kuriančios R komandos) sujungiami naudojant pliuso ženklą. Pliuso ženklas privalo būti eilutės gale arba viduryje, bet ne pradžioje. Sistemos ggplot2 sluoksnių sujungimas: Norint sujungti kelis ggplot2 sluoksnius (komandas), naudojamas „+“ ženklas; Po šio ženklo, kita komanda įprastai rašoma iš naujos eilutės; „+“ rašomas arba tarp gretimų komandų toje pačioje eilutėje, arba eilutės gale. Pliuso ženklas negali būti eilutės pradžioje – tai sintaksės klaida. BLOGAI: ggplot() + kita_ggplot2_komanda() GERAI: ggplot() + kita_ggplot2_komanda() GERAI (bet nerekomenduojama, jei jungiama daug komandų): ggplot() + kita_ggplot2_komanda() + trečia_ggplot2_komanda() Užduotis 3.4 Naudodami duomenų lentelę CO2 ir aukščiau pateiktą pavyzdį, nubraižykite, kaip anglies dioksido įsisavinimas (uptake) priklauso nuo šios medžiagos koncentracijos ore (conc). Jums tereikia nusikopijuoti kodą ir pakeisti duomenų lentelės bei kintamųjų pavadinimus. Didžiosios ir mažosios raidės – svarbu. Programos kodą išsaugokite. 3.2.4 Funkcija ggplot() Funkcija ggplot() įprastai yra pirmoji ggplot2 grafiko konstravimo sekoje. Jos skliaustuose nurodomi elementai, bendri visiems sluoksniams. Įprastai tai yra duomenų lentelė ir kintamųjų išdėstymas, nors šiuos du dalykus galima nurodyti kiekvienam sluoksniui atskirai. Turint duomenis ir kintamųjų reikšmių išdėstymo komandą, ggplot() parenka koordinačių sistemą, ašis, jų ribas bei numatytąją grafiko temą, tačiau nei taškų, nei linijų, nei kitų geometrinių figūrų nebraižo (tam reikalingi kiti sluoksniai): ggplot(data = trees, mapping = aes(x = Girth, y = Volume)) Dažnai R naudotojai argumentų pavadinimų data ir mapping nerašo, tad kodas sutrumpėja: ggplot(trees, aes(x = Girth, y = Volume)) Užduotis 3.5 Parašykite kodą ggplot(BOD, aes(x = Time, y = demand)): Kas nubraižyta grafike? Kodėl nėra nei linijos, nei taškų? Atsakymą pakomentuokite jūsų projekte esančiame dokumente šalia programos kodo. 3.2.5 Geomai: geometrinės figūros Sistemos ggplot2 sluoksnių elementai sudedami pliuso ženklu „+“ sujungiant kelias grafiką formuojančias komandas (sluoksnius). Funkcija ggplot() pagal nurodytus duomenis sukuria tik numatytąją koordinačių sistemą ir ašis (kaip matote pavyzdyje aukščiau). Jei norime atvaizduoti duomenis, turime pridėti papildomą elementą – geometrinę figūrą („geomą“). Tai atlieka funkcijos, prasidedančios užrašu geom_. „Receptas“, kaip sukurti paprastą ggplot2 histogramą: ggplot(duomenys, aes(x = kintamasis1)) + geom_histogram(bins = 15) Parametras bins – histogramos stulpelių skaičius. „Receptas“, kaip sukurti paprastą ggplot2 sklaidos diagramą: ggplot(duomenys, aes(x = kintamasis1, y = kintamasis2)) + geom_point() Pastebėkite, kad kai kuriais atvejais reikia nurodyti ir x, ir y kintamuosius, kai kuriais tik x. Tai priklauso nuo to, kokio tipo grafiką siekiame nubraižyti. Dažniausiai naudojamos geometrinės figūros, kai: nurodytas tiktai x ir jis yra kategorinis/diskretusis: geom_bar() (stulpelinė diagrama). Parodo, kaip pasiskirsto vieno kategorinio arba diskrečiojo kintamojo reikšmės. nurodytas x yra kategorinis/diskretusis, o y – tolydusis kintamasis: geom_col() (stulpelinė diagrama). Nubraižo stulpelinę diagramą, kai iš anksto žinomi kiekvienos grupės stulpelių aukščiai (pvz., jei norime atspausdinti dažnių lentelę). nurodytas tiktai x ir jis yra tolydusis: geom_density() (branduolinio tikimybės tankio diagrama, BTD); geom_histogram() (histograma). Parodo, kaip pasiskirsto vieno tolydžiojo kintamojo reikšmės. nurodytas x yra kategorinis/diskretusis, o y – tolydusis: geom_boxplot() (stačiakampė diagrama); geom_violin() (smuikinė diagrama); geom_jitter() (pasklaidytų taškų diagrama); Parodo, kaip tolydžiojo kintamojo reikšmės pasiskirsto kiekvienos kategorinio kintamojo grupės viduje arba kaip tolydžiųjų reikšmių pasiskirstymas priklauso nuo kategorinio kintamojo grupės. nurodyti x ir y yra tolydieji: geom_point() (sklaidos diagrama); geom_line() (linijų diagrama); geom_jitter() (pasklaidytų taškų diagrama). Parodo, kaip tarpusavyje susijusios (ar vienos nuo kitų priklauso) dviejų tolydžiųjų kintamųjų reikšmės. Štai keletas pavyzdžių (pavyzdžiuose color – apvado spalva, fill – užpildo spalva): X – kategorinis/diskretusis: ggplot(CO2, aes(x = Type)) + geom_bar(fill = &quot;red4&quot;) Abejose grupėse po 42 atvejus, todėl abu stulpeliai vienodo aukščio. Atkreipkite dėmesį, kad funkcija pati suskaičiavo, kiek kokios grupės narių yra imtyje, ir pagal tai parinko stulpelių aukštį. X – kategorinis/diskretusis, o Y – skaičius (dažnių lentelės spausdinimas): # Sukuriama dažnių lentelė darbuotojai &lt;- data.frame( darbingumas = factor( x = c(&quot;prastas&quot;, &quot;vidutinis&quot;, &quot;didelis&quot;), levels = c(&quot;prastas&quot;, &quot;vidutinis&quot;, &quot;didelis&quot;)), skaičius = c(5, 27, 46)) # Atspausdiname lentelę print(darbuotojai) ## darbingumas skaičius ## 1 prastas 5 ## 2 vidutinis 27 ## 3 didelis 46 # Grafikas ggplot(darbuotojai, aes(x = darbingumas, y = skaičius)) + geom_col() Atkreipkite dėmesį, kad funkcijai buvo nurodyta, kokio aukščio stulpelius brėžti. X – tolydusis: ggplot(CO2, aes(x = conc)) + geom_density(fill = &quot;skyblue&quot;) ggplot(CO2, aes(x = conc)) + geom_density(fill = &quot;skyblue3&quot;) + geom_rug(color = &quot;red&quot;) # Kiekvieną tašką brūkšneliu pažymi po grafiku ggplot(CO2, aes(x = conc)) + geom_histogram(bins = 7, color = &quot;black&quot;) bins – histogramos stulpelių skaičius. X ir Y – tolydieji: ggplot(BOD, aes(x = Time, y = demand)) + geom_point() ggplot(BOD, aes(x = Time, y = demand)) + geom_line() ggplot(BOD, aes(x = Time, y = demand)) + geom_line() + geom_point(color = &quot;purple&quot;, size = 4) X – kategorinis/diskretusis, Y – tolydusis: ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_boxplot() set.seed(123456) ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_jitter(width = .15) width – taškų pasklaidymo plotis. ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_violin() Užduotis 3.6 Grafikų analizė. Parinkite ir nubraižykite po grafiką, kuris galėtų atsakyti į šiuos klausimus (kiekvienam klausimui sukurkite atskirą poskyrį R Script dokumente): Duomenys iris: Kaip pasiskirsto kintamojo Sepal.Width reikšmės visoje imtyje? Kaip pasiskirsto kintamojo Petal.Width reikšmės visoje imtyje? (Parinkite kito tipo grafiką); Koks irisų rūšių skirstinys imtyje? Kurios rūšies daugiausiai? Kaip Sepal.Length priklauso nuo Petal.Length? Kaip Petal.Length reikšmės pasiskirsto pagal rūšis? Kurios rūšies pogrupyje kintamojo Sepal.Width reikšmės įprastai yra didžiausios? Duomenys npk (iš R paketo datasets). Nubraižykite kintamojo „yield“: histogramą: geometrinę figūrą kuriančios funkcijos (geom_histogram()) skliaustuose nurodykite parametrus bins = 6, color = &quot;black&quot; (ar pastebite, kad čia kabutės, ne „kompiuterinės“, o „literatūrinės“?); analizuodami šį grafiką nustatykite, kiek imtyje yra reikšmių, mažesnių už 65? branduolinio tankio grafiką; geometrinę figūrą kuriančios funkcijos (geom_density()) skliaustuose nurodykite parametrus adjust = 1.5, fill = &quot;green4&quot;; analizuodami grafiką preliminariai įvertinkite, kokios reikšmės labiausiai tikėtinos. Atsakymą pateikite kaip intervalą tarp dviejų sveikųjų skaičių (pavyzdžiui, 126-127); ką daro parametras „adjust“? (Paeksperimentuokite). stačiakampę diagramą (x ašyje atidėkite kintamojo „block“ reikšmes): Eilės tvarka išvardinkite blokus nuo turinčio didžiausią iki turinčio mažiausią duomenų centro padėtį; Eilės tvarka išvardinkite blokus nuo pasižyminčio didžiausia iki pasižyminčio mažiausia sklaida (naudokite išskirtims atsparų sklaidos matą – IQR); Kuris blokas pasižymi didžiausia asimetrija? punkto c stačiakampių diagramų grafiką papildykite pasklaidytų taškų diagrama (geom_jitter(width = 0.1)): Įvertinkite grupių dydžius kiekviename bloke; Ką daro parametras width? Žemiau – kitos savaitės pratybų medžiaga (kuri gali šiek tiek keistis). 3.2.6 Estetika: kintamojo reikšmių išdėstymas Kintamųjų reikšmės gali būti atvaizduotos įvairiomis grafiko savybėmis: padėtimi x bei y ašyse, spalvomis, taškų dydžiais, linijos storiais, taškų formomis… Šie dalykai vadinami estetiniais elementais arba estetiniu išdėstymu (angl. aesthetics). Kintamojo reikšmių išdėstymas nurodomas funkcijos aes() skliaustuose. pvz., vietovę (Type), kuri gali būti Kvebekas arba Misisipė, atvaizduosime spalvomis: ggplot(data = CO2, mapping = aes(x = conc, y = uptake, color = Type)) + geom_point() Medžio aukštį atvaizduosime ir spalvomis, ir taško dydžiais: ggplot(data = trees, mapping = aes(x = Girth, y = Volume, color = Height, size = Height)) + geom_point() Matote – mažas ir tamsiai mėlynas, didelis ir žydras. Atkreipkite dėmesį, kad faktoriams automatiškai parenkama diskrečioji spalvų skalė, o skaitiniams kintamiesiems – tolydžioji. Estetinių savybių rūšys Kokios gali būti estetinės savybės? Tai priklauso nuo parinktos geometrinės figūros: kiekvienos figūros dokumentacijoje aprašyti galimi estetiniai elementai. Dažniausiai naudojami šie: x, y – išdėstymas x ir y ašyse; color, colour – pagrindinė spalva arba apvado spalva (ir amerikietiška, ir britiška rašyba tinka); fill – užpildo spalva; alpha – (ne)skaidrumas/(ne)permatomumas: 1 – visiškai nepermatomas, 0 – visiškai skaidrus; shape, pch – taško forma (pch – point character); size – dydis; stroke – „potepio“ storis (pvz., taško apvado linijos storis); linetype, lty – linijos tipas; linewidth, lwd – linijos storis; group – grupavimas, pvz., braižant linijas, skaičiuojant vidurkius. Jei pasirenkate vieną iš aukščiau aprašytų estetinių elementų, grupavimas vykdomas automatiškai; kiti. Ne visos geometrinės figūros turi užpildo spalvą (parametrą „fill“). Plačiau apie šiuos grafinius elementus (su iliustracijomis) rašoma: http://ggplot2.tidyverse.org/articles/ggplot2-specs.html http://www.cookbook-r.com/Graphs/Shapes_and_line_types/ Užduotis 3.7 Parašykite kodą ?geom_point. Atsidariusioje dokumentacijoje susiraskite skiltį „Aesthetics“. Pažiūrėkite, kokie estetiniai elementai gali būti panaudoti braižant taškus? Kurie iš jų privalomi? (Pažymėta pajuodintai). Pirmo punkto užduotį pakartokite su ?geom_line. Nubraižykite sklaidos diagramas. Duomenų lentelės trees kintamųjų „Height“ ir „Girth“ išdėstykite x ir y ašyse, o „Volume“: spalvomis; (ne)skaidrumo skalėje. Kur nurodoma, kaip išdėstyti reikšmes? Pavyzdyje – iriso rūšių išdėstymas spalvomis. Visiems sluoksniams bendras išdėstymas nurodomas funkcijoje ggplot(): ggplot(iris, aes(x = Sepal.Width, y = Petal.Width, color = Species)) + geom_point() Vien tik konkrečiam sluoksniui būdingus išdėstymo elementus galima nurodyti to sluoksnio funkcijos skliaustuose: ggplot(iris, aes(x = Sepal.Width, y = Petal.Width)) + geom_point(aes(color = Species)) Kiekviename sluoksnyje galime patikslinti arba pakeisti, kokiu būdu bus pasirenkamos spalvos. Tad tai, kas parašyta ggplot() skliaustuose (šiuo atveju – savybė color), bus ignoruojama: ggplot(iris, aes(x = Sepal.Width, y = Petal.Width, color = Species)) + geom_point(aes(color = Petal.Width)) Be abejo, visus estetinio išdėstymo elementus galima nurodyti ir vien tik konkretaus sluoksnio viduje: ggplot(iris) + geom_point(aes(x = Sepal.Width, y = Petal.Width, color = Species)) Analogiškai galima elgtis ir su duomenimis. Kiekvienam sluoksniui gali būti atskiri duomenys ir atskiras išdėstymas. Visgi, atkreipkite dėmesį, kokiu būdu ir kurioje vietoje nurodomi duomenys (t.y., po išdėstymo): ggplot() + geom_point(aes(x = Sepal.Width, y = Petal.Width, color = Species), data = iris) Užduotis 3.8 Nusibraižykite pirmus du poskyrio „Kur nurodoma, kaip išdėstyti reikšmes?“ grafikus papildomai pridėdami geom_line() sluoksnį: Kuo linijos skiriasi nuo taškų? Imkime pirmąjį punkto 1. grafiką, kuriame atvaizduota sklaidos diagrama ir naudojama duomenų lentelė iris. Spalvomis išdėstytos rūšys, išdėstymas nurodytas funkcijos ggplot(), o ne geom_point() skliaustuose. Susikurkite naują duomenų lentelę naudodami šį kodą: iris2 &lt;- filter(iris, Species %in% c(&quot;setosa&quot;, &quot;virginica&quot;)) (programos kodas, kurį galite nusikopijuoti, yra žemiau. Čia – „literatūrinės“ kabutės); kodas palieka tik tas duomenų eilutes, kuriose setosa ir virginica rūšių duomenys. taškų funkciją modifikuokite taip:geom_point(data = iris2). Likusio kodo nekeiskite: Pagal kuriuos duomenis (iris ar iris2) buvo nubraižytas grafikas? Kur nurodytas estetinis išdėstymas, kuris buvo panaudotas braižant taškus: funkcijos geom_point() ar ggplot() skliaustuose? prie b. punkto grafiko pridėkite geom_line(): Kelių spalvų linijas ir kelių spalvų taškus matote? iris2 &lt;- filter(iris, Species %in% c(&quot;setosa&quot;, &quot;virginica&quot;)) Parametro group svarba Parametras group įprastai reikalingas braižant linijas ar norint kitu tikslu sugrupuoti duomenų reikšmes. Nenurodžius jo, ggplot2 ne visada linijas braižo teisingai. Šiuo atveju vienai spalvų grupei per visus taškus automatiškai braižoma viena linija: ggplot(data = CO2, mapping = aes(x = conc, y = uptake, color = Type)) + geom_line() + geom_point() O šiuo atveju išreikštai nurodome, kad vienam augalui (o ne vienai spalvai) turi būti viena linija: ggplot(data = CO2, mapping = aes(x = conc, y = uptake, color = Type, group = Plant)) + geom_line() + geom_point() Užduotis 3.9 Iš paketo MASS užsikraukite duomenų lentelę Rabbit. Nubraižykite kraujospūdžio pokyčio priklausomybę nuo vaisto dozės. Priklausomybė turi būti pavaizduota ir linijomis, ir taškais. Skirtingomis spalvomis nusibraižykite kontrolinę ir vaisto gavusią grupes. Kiekviena linija turi vaizduoti atskirą eksperimentą (kintamasis Run). Svarbu perskaityti duomenų lentelės aprašymą. Duomenų lentelę reiktų peržvelgti naudojant funkcijas glimpse(), View() bei summary() (pažiūrėkite, kaip aprašomos kategorinių kintamųjų reikšmės). Preliminariai įvertinkite, kas įprastai įvyksta su kraujospūdžiu didinant vaisto dozę. Kuo skiriasi kontrolinės ir tiriamosios grupės atsakas: kai vaisto dozė \\(\\lt 100\\mu g\\); kai vaisto dozė \\(\\gt 100\\mu g\\). Ties kokia vaisto doze spalvomis pavaizduotos grupės skiriasi labiausiai? 3.2.7 Estetika: fiksuoto dydžio reikšmės parinkimas Estetikos elementų reikšmes galima parinkti 2 būdais: estetikos elementų reikšmes išdėstyti pagal kintamųjų reikšmes naudojant funkciją aes(); nurodyti konkrečią estetinio elemento reikšmę kiekviename sluoksnyje atskirai (t. y., nebe funkcijos ggplot() ir nebe funkcijos aes() skliaustuose. Peržvelkite skyriaus „Geomai: geometrinės figūros“ pavyzdžius, kuriuose vaizduojami spalvoti grafikai, dar kartą). Spalvos gali būti pasirenkamos keliais būdais: a. nurodant spalvos numerį nuo 1 iki 8 (būdas atėjo iš bazinės *R* grafikų braižymo sistemos); b. nurodant anglišką spalvos pavadinimą kabutėse, pvz., `&quot;green&quot;`{.r}. Visi *R* esantys spalvų pavadinimai atspausdinami suvedus `colors()`{.r}, spalvų demonstracija -- `demo(&quot;colors&quot;)`{.r} (spausdami „Enter“ matysite vis kitą paveikslą. Siūlau paveikslus smarkiai pasididinti); c. nurodant šešioliktainį spalvos kodą *RGB* sistemoje (*red, green, blue*), pvz., `&quot;#12ff6d&quot;`{.r} (*12* -- raudonos, *ff* -- žalios, *6d* -- mėlynos spalvos intensyvumas). - galimos šešioliktainių skaičių reikšmės: 0, 1, 2, ..., 9, a, b, c, d, e, f. Jei norite pamatyti, kaip atrodo spalva, funkcijos scales::show_col() kabutėse įrašykite spalvos kodą arba pavadinimą, pvz., scales::show_col(&quot;#12ff6d&quot;) arba scales::show_col(5). Pastaba: jei paketas yra įdiegtas kompiuteryje, dvigubo dvitaškio operatorius :: leidžia naudoti funkciją iš to paketo, paketo neužsikrovus (paketo_pavadinimas::funkcijos_pavadinimas()). Pvz., iš paketo scales naudojame funkciją show_col(). Pavyzdys. Konkrečios spalvos parinkimas. ggplot(iris, aes(x = Sepal.Width, y = Petal.Width)) + geom_point(color = &quot;red4&quot;) Spalvos ir permatomumo lygio parinkimas: ggplot(iris, aes(x = Sepal.Width, y = Petal.Width)) + geom_point(color = &quot;red4&quot;, alpha = .3) Padidinę taškų permatomumą, galime matyti, kuriuose vietose taškai persidengia (tamsesnės vietos – daugiau taškų). Užduotis 3.10 ) Duomenų lentelė iris. Pagal kintamojo Petal.Width reikšmes nusibraižykite branduolinio tankio diagramas. Kiekviena rūšis turi būti atvaizduota skirtingo užpildo spalvomis, tačiau apvado spalva privalo būti mėlyna, apvado linija – pastorinta, o užpildo spalva – permatoma. 3.2.8 Grafikas – tai R objektas Sistemos ggplot2 komandos kuria objektą (jo klasė „ggplot“, o pagal savo vidinę struktūrą – tai ilgas grafiką aprašantis sąrašas), kurį atspausdinus ekrane matome grafiką. Bet kuriame grafiko konstravimo etape šį objektą galima išsaugoti R atmintyje: # Sukuriama tik koordinačių sistema ir ašys grafikas &lt;- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) Parašius objekto su grafiku pavadinimą, grafikas atspausdinamas: grafikas Atspausdinti galime ir išreikštai parašę print(): print(grafikas) Vėliau prie šio objekto galima pridėti kitus ggplot2 sluoksnius: # Pridedami taškai grafikas2 &lt;- grafikas + geom_point() grafikas2 Anksčiau išbandėme, kaip atrodo taškais atvaizduoti duomenys, dabar galime išbandyti linijas: # Pridedamos linijos grafikas3 &lt;- grafikas + geom_line() grafikas3 Grafiką aprašantį objektą galime išsaugoti arba kaip įprastinį R objektą, arba kaip aukštos kokybės grafiką (apie tai bus rašoma vėliau). Užduotis 3.11 Šitokiu principu, kai sukuriama dalis grafiko ir priskiriama objektui, o kita dalis tik pridedama norint parodyti skirtumą, parašyta ir ggplot2 atmintinėje. Atsidarykite šią atmintinę (ją jau atsisiuntėte) ir pirmame puslapyje susiraskite skiltį „ONE VARIABLE continuous“. Ką turite padaryti, kad pavyzdžio c + geom_dotplot() kodas veiktų? Užrašykite visą grafiką sudarantį kodą. Patiems kurti nereikia! Susiraskite, visas atsakymas parašytas atmintinėje. 3.2.9 Facetės: subgrafikai Palyginus su kitomis R grafikų braižymo sistemomis, netgi su kitomis programomis, labai didelis ggplot2 privalumas yra galimybė duomenis atvaizduoti subgrafikais, vadinamais facetėmis. Facetės – tai subgrafikai, į kuriuos duomenys yra išskirstomi pagal kategorinių kintamųjų reikšmes. Yra 2 facečių tipai: facet_wrap() – subgrafikus išrikiuoja į kiek galima labiau kvadratinę išdėstymo schemą; facet_grid() – subgrafikus išdėsto eilutėmis ir stulpeliais pagal nurodytų kintamųjų reikšmes. Facečių sluoksnis pridedamas pridedant vieną iš aukščiau minėtų funkcijų. Naudojimas: facet_wrap() skliaustuose rašoma: bangelė ~ ir kintamojo pavadinimas (pvz., ~ A). jei norima išskirstyti pagal kelis kintamuosius, naudojamas + ženklas (pvz., ~ A + B); facet_grid() skliaustuose rašoma: į eilutes išskaidančio kintamojo pavadinimas, bangelė ~ ir į stulpelius išskaidančio kintamojo pavadinimas (pvz., A ~ B). jei norime vienos eilutės arba vieno stulpelio, vietoje kintamojo pavadinimo rašome tašką (pvz., . ~ A – viena eilutė, A ~ . – vienas stulpelis); jei kintamųjų daugiau, galima naudoti + ženklą (pvz., A ~ B + C); galioja ES taisyklė: pirma nurodomos eilutės, po to – stulpeliai. Pavyzdžiai: graf &lt;- ggplot(CO2, aes(x = conc, y = uptake, color = Type, group = Plant)) + geom_line() + geom_point() # facet_wrap — vienas kintamasis graf + facet_wrap(~ Type) # facet_wrap — vienas keli kintamieji graf + facet_wrap(~ Type + Treatment) Pažvelkite į šį grafiką dar kartą. Kokia iš jo nauda biologine prasme? Misisipės augalai auga pietuose. Kvebeko – šiaurėje (pažiūrėkite žemėlapyje, kur yra šios teritorijos). Iš grafiko galime įtarti, kad pietiniai augalai prasčiau toleruoja šaltį: „Mississippi“ ir „chilled“ (atvėsinta) facetėje įsisavinimas mažiausias. Ar šitokia interpretacija jums atrodo logiška? Panagrinėkime kitus facečių sudarymo variantus. # facet_wrap — vienas keli kintamieji, # nurodomas stulpelių skaičius. graf + facet_wrap(~ Type + Treatment, ncol = 3) # facet_grid graf + facet_grid(Type ~ Treatment) # facet_grid — viena eilutė graf + facet_grid(. ~ Treatment) # facet_grid — vienas stulpelis graf + facet_grid(Treatment ~ .) Programoje R užrašai, kuriuose kintamieji pasirenkami naudojant bangelę (~), vadinami „modelio formule“ arba tiesiog „formule“. Jie naudojami daugelyje statistinės analizės funkcijų. Daugiau informacijos suvedus komandas: ?`~` arba ?formula. Modelio formulė – tai kintamųjų pasirinkimo būdas naudojant bangelę „~“. Užduotis 3.12 Iš R paketų užsikraukite lentelę iris ir peržvelkite ją naudodami glimpse(). Jei reikia, peržvelkite lentelės aprašymą. Nusibraižykite sklaidos diagramą pagal Sepal.Width ir Petal.Length. Spalvas parinkite ir į facetes suskirstykite pagal Species. Pagal kintamojo Petal.Length reikšmes nusibraižykite branduolinio tankio diagramas. Kiekviena rūšis turi būti atvaizduota skirtingo užpildo spalvos grafiku ir atskirose facetėse, išdėstytose į vieną eilutę. Iš R paketo datasets užsikraukite lentelę npk. Nubraižykite grafiką, kurio pavyzdys žemiau. Patarimai: Kintamųjų block ir yield reikšmes išdėstykite x ir y ašyse; Spalvas išdėstykite pagal P; Į facetes suskirstykite pagal N, P ir K; Facečių funkcijos viduje po formulės parašykite kodą labeller = label_both. Atkreipkite dėmesį, ką jis daro; Reikiamoje vietoje padėkite kablelį. 3.2.10 Pavadinimai Grafikuose galima nurodyti/pakeisti grafiko, ašių, legendų pavadinimus. Šiam tikslui daugiausiai galimybių turi funkcija labs(). Pavyzdys, kaip ji naudojama: ggplot() + labs(x = &quot;x ašies pavadinimas&quot;, y = &quot;y ašies pavadinimas&quot;, title = &quot;Grafiko pavadinimas&quot;, subtitle = &quot;Paantraštė&quot;, caption = &quot;&lt; Aprašymas &gt;&quot;, # Kiekvieno estetinio išdėstymo legenda color = &quot;Spalvų legenda&quot;, # nesimato fill = &quot;Užpildo spalvų legenda&quot;, # nesimato shape = &quot;Formų legenda&quot;, # nesimato size = &quot;dydžių legenda&quot; # nesimato ) Iliustracijai susikurkime „ggplot“ objektą: gg &lt;- ggplot(iris, aes(x = Sepal.Length, fill = Species, color = Species)) + geom_density(alpha = 0.3, adjust = 1.5) gg + labs(x = &quot;x ašis&quot;, y = &quot;y ašis&quot;) gg + labs(x = &quot;x ašis&quot;, y = &quot;y ašis&quot;, fill = &quot;Spalvų legenda&quot;, color = &quot;Spalvų legenda&quot;) ` gg + labs(title = &quot;Pavadinimas&quot;, x = &quot;x ašis&quot;, y = &quot;y ašis&quot;, fill = &quot;Užpildo spalvų legenda&quot;, color = &quot;Apvado spalvų legenda&quot;) Grafiko pavadinimas gali būti nurodomas naudojant funkciją ggtitle(&quot;...&quot;). gg + ggtitle(&quot;Grafiko pavadinimas&quot;) Ašių ir legendų pavadinimai – nurodyti naudojant funkcijas: labs(x = &quot;...&quot;, y = &quot;...&quot;, color = &quot;...&quot;, fill = &quot;...&quot;); xlab(&quot;...&quot;); ylab(&quot;...&quot;). gg + ylab(&quot;&lt;&lt; Pasikeitė pavadinimas Y &gt;&gt;&quot;) Užduotis 3.13 Duomenys trees. Pagal kintamojo Height reikšmes nubrėžkite histogramą: Parinkite tinkamą grupavimo intervalų skaičių, parinkite tinkamą apvado ir užpildo spalvą, apvadą pastorinkite; Grafikui suteikite pavadinimą, ašių pavadinimus sulietuvinkite, paantraštėje turi būti parašyta „Sukūrė: “ ir jūsų vardas, aprašyme turi būti įrašyta šiandienos data. 3.2.11 Temos Grafiko tema – tai visos nuo duomenų nepriklausomos grafiko savybės, tokios kaip fono ar ašių linijų spalva, šriftas. Temas aprašančios funkcijos prasideda theme_...(), kur vietoje daugtaškio parašomas temos pavadinimas. Mano mėgstamas pasirinkimas – juodai balta tema, kurią sukuria funkcija theme_bw(). Standartinė tema theme_grey(). Daugiau temų – ggplot2 atmintinėje bei pakete ggthemes (pavyzdžių rasite paspaudę šią nuorodą). gg + theme_grey() gg + theme_bw() gg + theme_dark() Užduotis 3.14 Užsikraukite duomenų lentelę Orange (apelsinmedžiai) iš paketo datasets: Sistema ggplot2 nusibraižykite sklaidos diagramą, kurios x ašyje būtų kintamojo age reikšmės, o y ašyje – circumference. Po to nusibraižykite tokį patį grafiką, kaip 1 punkte, tik papildomai spalvomis atvaizduokite kintamojo Tree reikšmes. Grafiką priskirkite objektui gg3. Objekte gg3 esantį grafiką patobulinkite pridėdami lietuviškus spalvų legendos ir ašių pavadinimus bei grafiko pavadinimą; Išbandykite visas 8 ggplot2 atmintinėje esančias temas (vieną temą vienu metu). 3.2.12 Temos nustatymas visiems grafikams Temą galima nustatyti visiems grafikams iš karto naudojant funkciją theme_set() ir joje nurodant temą aprašančią funkciją: # Standartinė pilka ggplot2 tema theme_set(theme_grey()) gg # Klasikinė tema theme_set(theme_classic()) gg # Juodai balta tema theme_set(theme_bw()) gg Užduotis 3.15 Naudodamiesi lentele iris, nusibraižykite pasklaidytų taškų diagramą. Naudodamiesi šiuo grafiku išbandykite, kaip veikia funkcija theme_set(). 3.2.13 Ženklinimai ir pažymėjimai Į sistemos „ggplot2“ grafikus galima įterpti įvairių ženklinimo elementų, linijų, rodyklių, kvadratų, etikečių užrašų. Apie tai plačiau atmintinėje ir dokumentacijos tinklapyje. Horizontali linija. gg + geom_hline(yintercept = 0.5, lwd = 1) Vertikali linija. gg + geom_vline(xintercept = 6, color = &quot;blue&quot;) Užduotis 3.16 Grafike, kuris rodomas šio skyriaus pavyzdyje, atidėkite raudoną brūkšniuotą horizontalią ženklinimo liniją ties x = 5. 3.2.14 Statistinės transformacijos Ar pastebėjote, kad naudojant geom_bar(), geom_histogram(), geom_density() ir panašias funkcijas nurodomos tik x reikšmės. Tuo tarpu y reikšmės apskaičiuojamos funkcijos viduje ir nubraižomos grafike. Viena iš statistines transformacijas vykdančių funkcijų yra geom_smooth() braižanti tendencijos linijas. ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + geom_smooth(method = &quot;lm&quot;) Čia „lm“ reiškia linear model, t. y, nubraižoma geriausiai taškus apibūdinanti tiesė. Užduotis 3.17 Naudodami duomenų lentelę iris nubrėžkite sklaidos diagramą. Rūšis pažymėkite skirtingomis spalvomis. Pridėkite tendencijos liniją. Kaip ji atrodo? 3.2.15 Koordinačių sistemos Sistemoje ggplot2 funkcijos, kurios prasideda coord_, pakeičia koordinačių sistemą. Pvz., coord_flip() sukeičia x ir y ašis vietomis. coord_polar() grafiką nubraižo polinėje koordinačių sistemoje ir taip stulpelinė diagrama tampa skrituline. Daugiau apie šias funkcijas skaitykite atmintinėje ir dokumentacijos tinklapyje. bar &lt;- ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL) bar + coord_flip() bar + coord_polar() Užduotis 3.18 Naudodamiesi lentele CO2, nubrėžkite stačiakampę diagramą. Prie grafiko kodo pridėkite coord_flip(). Kaip atrodo grafikas? Naudodamiesi lentele iris, nubrėžkite sklaidos diagramą. Prie grafiko kodo pridėkite coord_equal(). Kaip pasikeitė grafikas? Pabandykite padidinti arba sumažinti šį grafiką. Ką pastebite? 3.2.16 Grafikų išsaugojimas Grafikų išsaugojimui gali būti naudojama funkcija ggsave() arba RStudio „Plots“ lango mygtukas „Export“ (pav. 3.14). Pav. 3.14: Grafikų išsaugojimo meniu. Užduotis 3.19 Sukurkite ggplot2 grafiką. Jis turi atsirasti RStudio „Plots“ lange (kodą spausdinkite konsolėje). Naudodami mygtuką „Export“, grafiką išsaugokite: kaip bylą kietajame diske „.jpg“ formatu. Išsaugotą grafiką atsidarykite. į iškarpinę (angl. clipboard). Tada įklijuokite į „Word“ (ar analogišką) dokumentą spausdami Ctrl+V. Ar pavyko tai atlikti? 3.2.17 Šablonas ggplot2 grafikui Sistemos ggplot2 grafikas gali būti sukurtas naudojant tokią „formulę“, kur didžiosiomis raidėmis parašyta kodo dalis turėtų būti pakeista pagal poreikius: ggplot(data = &lt;DUOMENYS&gt;) + GEOM_FUNKCIJA( mapping = aes(&lt;ESTETINIS_IŠDĖSTYMAS&gt;), stat = &lt;STATISTINĖ_TRANSFORMACIJA&gt;, position = &lt;POZICIJA&gt; ) + KOORDINAČIŲ_SISTEMOS_FUNKCIJA() + FACEČIŲ_FUNKCIJA() + PAVADINIMŲ_FUNKCIJA() + SKALIŲ_FUNKCIJA() + KITI_ELEMENTAI() + PAGRINDINĖ_TEMA() + TEMOS_KOREKCIJOS() Jums dar nežinomas ggplot2 galimybes siūlau atrasti naudojant grafinius įrankius „easyPlot“, „ggplotgui“ bei „ggedit“ kurie aprašyti žemiau. 3.2.18 Paketas plotly ir interaktyvūs grafikai Papildinys plotly yra R paketas, kuriuo kuriami interaktyvūs grafikai. Šiame pakete yra funkcija ggplotly(), kuri įprastus ggplot2 grafikus paverčia interaktyviais (kuriuos galima padidinti, sumažinti, identifikuoti taškų koordinates). library(plotly) grafikas &lt;- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + geom_point() Grafikas atspausdintas ekrane įprastiniu būdu: grafikas Grafikas, ekrane atspausdintas naudojant ggplotly(), tampa interaktyvus. Jis atsiranda nebe „Plots“, o „Viewer“ lange: ggplotly(grafikas) Pav. 3.15: Interaktyvus grafikas. Užvedus pelės žymeklį virš taško, pasirodo jo koordinatės. Paspaudus veislės pavadinimą legendoje vieną kartą, tos veislės taškai išjungiami arba vėl įjungiami. Paspaudus legendos reikšmę du kartus – išjungiamos kitų veislių taškai. Veikia taškų priartinimo funkcija. # ```{block2, type=“task”} Užduotis 3.20 Užduoties (kurios numeris 3.14) metu sukurtą ggplot2 grafiką atspausdinkite naudodami funkciją ggplotly() (paketas plotly privalo būti užkrautas): Nustatykite pasirinkto taško koordinates. Naudodami iris duomenis nubraižykite sklaidos diagramą, kurioje rūšys vaizduojamos skirtingomis spalvomis: Nustatykite pasirinkto taško koordinates. Legendoje 2 kartus spragtelkite pele užrašą „virginica“. Kas nutiko? Vieną kartą spragtelkite legendos užrašą „setosa“. Kas nutiko? Paspauskite pagrindinį pelės klavišą kur nors grafike ir jį laikydami pelę nutempkite į šalį. Kas nutiko? Paspauskite mygtuką su nameliu. Kas nutiko? Kuo skiriasi ggolot2 grafikas, atspausdintas įprastu būdu, nuo grafiko, atspausdinto naudojant funkciją ggplotly()? 3.2.19 Įrankis easyPlot Įrankis easyPlot yra shiny3 programėlė, kuri skirta kurti nesudėtingus ggplot2 grafikus. Yra 2 šio įrankio versijos: internetinė versija http://www.michalm.net/shiny/easyPlot/ R paketas, įdiegiamas iš saugykols „GitHub“ (devtools::install_github(&quot;majkamichal/easyPlot&quot;)). Įrankio naudojimas. Užkraunamas paketas easyPlot, tada įrankis atidaromas naudojant funkciją tokiu pačiu pavadinimu easyPlot(). Funkcijos skliaustai gali būti tušti, jei duomenis norite įkelti vėliau (nerekomenduoju): easyPlot::easyPlot() Bet geriau duomenis nurodyti iš karto funkcijos skliaustuose. Šiam įrankiui reikia, kad duomenų lentelėje būtų bent 2 stulpeliai. Duomenų lentelės pavadinimas nurodomas kabutėse: easyPlot::easyPlot(&quot;iris&quot;) Atsidaręs įrankio langas atrodo maždaug taip, kaip vaizduojama pav. 3.16 bei 3.17. Jei langas per mažas, rekomenduoju paspausti mygtuką „Open in Browser“ ir grafiką konstruoti interneto naršyklėje atsidariusiame lange. Pav. 3.16: Įranko „easyPlot“ lango viršus: pagrindinė meniu juosta ir grafikas. Pav. 3.17: Įranko „easyPlot“ lango apačia: valdikliai ir programos kodas. Įrankis generuoja programos kodą, kurį, baigus kurti grafiką, nusikopijuokite į R ir išsaugokite. Kodas pateikiamas įrankio lango viduje. Paleidus įrankį, programa R blokuojama iki tol, kol įrankis veikia. Darbas įrankiu baigiamas paspaudus išjungimo mygtuką (arba uždarius įrankio langą). Užduotis 3.21 Duomenys CO2: Duomenų lentelę CO2 įsikelkite į easyPlot. Įrankio langą pasididinkite per visą ekraną arba atsidarykite naršyklės lange („Open in Browser“ mygtukas); Viršutinėje juostoje pasirinkite vieną iš norimų grafikų tipų: „Scatterplot“, „Histogram“, „Boxplot“, „Bargraph“. Patyrinėkite šio įrankio galimybes keisdami grafiko parinktis; Nusibraižykite histogramą iš 7 stulpelių raudonu užpildu ir mėlynu stulpelių apvadu. Kiekvieno augalo tipo (Type) histogramas išdėstykite facetėmis viena žemiau kitos. Lango apačioje yra vieta su programos kodu. Konstruodami grafiką stebėkite, kaip keičiasi kodas. Kai susikonstruosite norimą grafiką, nukopijuokite šį kodą ir įklijuokite į RStudio atidarytą dokumentą. Uždarykite įrankio langą paspausdami uždarymo mygtuko ikoną. Papildomai uždarykite įrankio langą, jei jis neužsidarė. Naudodami RStudio, atspausdinkite grafiką. 3.2.20 Įrankis ggplot GUI Įrankis ggplotgui („ggplot GUI“) yra shiny programėlė, kuri taip pat skirta kurti paprastus ggplot2 grafikus. Šis įrankis vėlgi turi 2 versijas: internetinė versija https://site.shinyserver.dck.gmw.rug.nl/ggplotgui/ R paketas, įdiegiamas iš saugyklos CRAN (install.packages(&quot;ggplotgui&quot;)). Įrankio naudojimas. Užkraunamas paketas ggplotgui, tada įrankis atidaromas naudojant funkciją ggplot_shiny(). Funkcijos skliaustai gali būti tušti, jei duomenis norite įkelti vėliau (nerekomenduoju): ggplotgui::ggplot_shiny() Visgi, geriausia nurodyti duomenų lentelės, kurią norite vizualizuoti, pavadinimą (be kabučių): ggplotgui::ggplot_shiny(iris) Atsidaro įrankio langas, kuriame pasirinkite reikiamą kortelę (pav. 3.18, pav. 3.19). Jei langas per mažas, rekomenduoju paspausti mygtuką „Open in Browser“ ir grafiką konstruoti interneto naršyklėje atsidariusiame lange. Pav. 3.18: Įrankio „ggplotgui“ langas: „ggplot2“ grafiko kortelė ir valdikliai. Pav. 3.19: Įrankis „ggplotgui“: interaktyvaus „plotly“ grafiko kortelė. Pav. 3.20: Įrankis „ggplotgui“: programos kodo kortelė. Įrankis generuoja programos kodą, kurį, sukūrę norimą grafiką, nusikopijuokite į R ir išsaugokite. Kodas pateikiamas kortelėje „R-code“ (pav. 3.20). Paleidus įrankį, programa R blokuojama iki tol, kol įrankis veikia. Uždarius įrankio langą, darbas įrankiu baigiamas. Užduotis 3.22 Duomenys CO2: Duomenų lentelę CO2 įsikelkite į ggplotgui. Įrankio langą pasididinkite per visą ekraną arba atsidarykite naršyklės lange („Open in Browser“ mygtukas); Viršutinėje juostoje pasirinkite kortelę „ggplot“. Susikurkite norimą branduolinio tankio grafiką; Grafikui suteikite pavadinimą, jis turėtų būti 16 šrifto dydžio; X ir Y ašims suteikite lietuviškus pavadinimus; padidinkite permatomumą iki 60%; Kortelėje „Plotly“ galite matyti, kaip atrodo interaktyvi grafiko versija (ją galite padidinti-sumažinti ir t.t.); Kortelėje „R-code“ parašytas programos kodas: grafiko kūrimui, interaktyviam spausdinimui bei saugojimui. Konstruodami grafiką stebėkite, kaip keičiasi kodas. Kai susikonstruosite norimą grafiką, nukopijuokite šį kodą ir įklijuokite į RStudio atidarytą dokumentą. Išjungimo mygtuko nėra, tad tiesiog uždarykite įrankio langą. Kol langas atidarytas, tol R bus blokuojamas; Naudodami RStudio atspausdinkite grafiką „Plots“ lange. Tam nukopijuotame kode duomenų lentelės pavadinimą „df“ reikia pakeisti į tikrąjį (t. y. CO2, be kabučių); Grafiką nukopijuokite į iškrapinę ir įklijuokite į „Word“ tipo dokumentą. Dokumentą išsaugokite. 3.2.21 Įrankis ggedit Įrankis ggedit yra shiny programėlė, skirta redaguoti ggplot2 grafikus – ypač spalvų sluoksnį ir temą. Įrankio naudojimas. Sukurkite ggplot2 grafiką, jį išsaugokite kaip R objektą. Pvz.: p &lt;- ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + geom_point(aes(color = Species)) + geom_smooth() Įsitikinkite, kad įrankis ggedit įdiegtas jūsų kompiuteryje. Tada panaudokite jį: pnew &lt;- ggedit::ggedit(p) Atsivers langas (jei jis per mažas, siūlau jį atsidaryti naršyklėje paspaudus „Open in Browser“ mygtuką) panašus į atvaizduotąjį pav. 3.21. Paspaudus reikiamus meniu juostos mygtukus, galima atidaryti spalvų sluoksnio (pav. 3.22) ir temos (pav. 3.23) redagavimo langus. Pav. 3.21: Įrankio „ggedit“ pagrindinio lango fragmentas. Pav. 3.22: Įrankis „ggedit“: spalvų sluoksnio redagavimo langas. Pav. 3.23: Įrankis „ggedit“: temos redagavimo langas. Darbas įrankiu baigiamas paspaudus mygtuką „Done“ (pav. 3.21). Tada sukuriamas programos kodas, kurį galime atsispausdinti. Atkreipkite dėmesį, kad tai ne visas kodas grafikui sukurti, o tik jo dalis, kurią sukūrė ar pakoregavo įrankis. Gaunamo kodo pavyzdys: print(pnew) ## ## 1 ## geom_point(mapping=aes(colour=Species),stroke=1,alpha=0.3,size=9,shape=22)+geom_smooth(alpha=0.23,weight=0,linetype=2,size=2,fill=&#39;#DEA5A5&#39;,colour=&#39;#4876FF&#39;)+ ## scale_colour_manual(values=c(&#39;#FA8072&#39;,&#39;#45CC3B&#39;,&#39;#6495ED&#39;))+ ## theme() Šį kodą rekomenduojama pertvarkyti tam, kad jis taptų tvarkingesnis: Kodą nusikopijuojame į langą, kuriame galime jį redaguoti (pvz., į R Script langą); Visą nukopijuotą kodą pažymime pele, tada spaudžiame greitųjų „RStudio“ klavišų kombinacijas: pirma Ctrl+Shift+A (kodą padalins per kelias eilutes, sudės tarpus beveik visur, kur jų reikia), po to Ctrl+I (kiekvieną kodo eilutę reikiamu atstumu atitrauks nuo krašto). Tada tinkamai sudėkite reikiamas savo pradinio ir „ggedit“ sugeneruoto kodo dalis: # Reikalinga pradinio kodo dalis: ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + # Įrankiu „ggedit“ pakoreguotas kodas: geom_point( mapping = aes(colour = Species), stroke = 1, alpha = 0.3, size = 9, shape = 22 ) + geom_smooth( alpha = 0.23, weight = 0, linetype = 2, size = 2, fill = &#39;#DEA5A5&#39;, colour = &#39;#4876FF&#39; ) + scale_colour_manual(values = c(&#39;#FA8072&#39;, &#39;#45CC3B&#39;, &#39;#6495ED&#39;)) + theme() Daugiau informacijos apie įrankį ir video pamokų galite rasti adresu: https://www.r-statistics.com/2016/11/ggedit-interactive-ggplot-aesthetic-and-theme-editor/ https://metrumresearchgroup.github.io/ggedit/ Užduotis 3.23 Duomenų lentelė CO2: sukurkite branduolinio tankio diagramą, kuria lyginami duomenų pogrupiai; šios diagramos spalvas pakoreguokite naudodami įrankį „ggedit“; baigę korekcijas paspauskite „Close“ mygtuką; sutvarkykite pateiktą kodą; ši kodą sujunkite su pradinio grafiko kodu, kad gautumėte rezultatą, kurį matėte įrankyje „ggedit“; Galutinį grafiką atspausdinkite. 3.2.22 Kelių grafikų išdėliojimas greta Norint išdėlioti kelis ggplot grafikus greta, naudinga funkcija plot_grid() iš paketo cowplot. Šiame skyriuje bus pademonstruota, kad tokia funkcija yra, o daugiau informacijos funkcijos dokumentacijoje: ?cowplot::plot_grid. grafikas_a &lt;- ggplot(BOD, aes(Time, demand)) + geom_line() grafikas_b &lt;- ggplot(iris, aes(Sepal.Width, Petal.Length, color = Species)) + geom_point() cowplot::plot_grid(grafikas_a, grafikas_b, rel_widths = c(2, 3), labels = &quot;AUTO&quot;) cowplot::plot_grid(grafikas_a, grafikas_b, nrow = 2, labels = &quot;AUTO&quot;) Jei šis variantas neatlieka to, ko jums reikia, gali būti naudingos šios instrukcijos: „Laying out multiple plots on a page“; „Multiple plots in one page“; „ggplot2 - Easy Way to Mix Multiple Graphs on The Same Page“. Taip pat galimas variantas kelis grafikus išsaugoti ir įsikelti į grafikos apdorojimo programas ir jose pasidaryti tai, ko reikia. Profesionalioms programoms tinka PDF formatu (vektorinė grafika, dėl kurios neprarandama kokybė) išsaugoti grafikai. 3.2.23 Resursai: ggplot2 Skyrius apie ggplot2 (pradedantiesiems): http://r4ds.had.co.nz/data-visualisation.html Atmintinė: https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf Oficiali ggplot2 dokumentacija: http://ggplot2.tidyverse.org/reference/ Įrankis, skirtas mokytis ir tirti ggplot2 savybes: http://databall.co/shiny/shinyggplot/ Grafikų galerija su programos kodu http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html Mokomoji medžiaga http://r-statistics.co/ggplot2-Tutorial-With-R.html ggplot2 papildantys paketai http://www.ggplot2-exts.org/ggrepel.html Įrankis „easyPlot“ http://www.michalm.net/shiny/easyPlot/ Įrankių darbui su ggplot2 saugykla: https://www.showmeshiny.com/category/visualization/ggplot2/ Resursų sąrašas: https://gist.github.com/Pakillo/c2c7ea11c528cc2ee20f Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. „Shiny“ yra R paketas, skirtas kurti interaktyvias tinklapio pavidalo programėles, įprastai skirtas įvairioms duomenų analizės temoms. Daugiau informacijos https://shiny.rstudio.com/↩ "],
["skaitines-suvestines.html", "4. Skaitinės suvestinės 4.1 Teorinė dalis 4.2 Pasirengimas praktinei daliai 4.3 Suvestinės baziniu R būdu 4.4 Operatorius %&gt;% 4.5 Suvestinės tidyverse būdu", " 4. Skaitinės suvestinės Šio užsiėmimo tikslas – išmokti pagal duomenų savybes parinkti skaitines duomenų suvestines ir jas programa R atlikti visai duomenų lentelei ir jos pogrupiams. 4.1 Teorinė dalis 4.1.1 Aprašomoji statistika Aprašomoji statistika – yra statistikos mokslo dalis. Jos esmė – atlikti skaitines bei grafines duomenų suvestines, kurios glaustai perteikia esminius duomenų bruožus. 4.1.2 GA parametrai ir imties statistikos Jeigu atliekant statistinius skaičiavimus naudojami visos generalinės aibės (GA) duomenys, tada rezultatą – apskaičiuotąją GA charakteristiką – vadiname generalinės aibės parametru (pvz., GA vidurkis). Jei analogiškiems skaičiavimams naudojami imties duomenys, tada rezultatą – imties charakteristiką – vadiname imties statistika (pvz., imties vidurkis). Generalinė aibė → parametras. Imtis → statistika. 4.1.3 Aprašomosios statistikos Imties statistikas galima skirstyti į kelias grupes (pav. 4.1): Pav. 4.1: Imties statistikų rūšys. Šiame skyriuje mus domina aprašomosios statistikos. Aprašomosios statistikos – charakteristikos, skirtos glaustai apibūdinti imties duomenis. Aprašomųjų statistikų pavyzdžių pateikta pav. 4.2. Įverčiai – tai, pagal turimus imties duomenis, geriausias spėjimas, koks yra tikrasis GA parametras (pvz., tikrasis vidurkis). Būna 2 rūšių: taškiniai įverčiai; intervaliniai įverčiai (pvz., pasikliauties intervalai). Statistinių kriterijų statistikos – tai dydžiai, kurių pagalba tikrinamos statistinės hipotezės ir daromos statistinės išvados (pvz., t statistika Stjudento t teste). Pav. 4.2: Aprašomųjų statistikų ir kitų skaitinių suvestinių pavyzdžiai. * – kitos suvestinės. 4.1.4 Imties dydis – jį privaloma pateikti ataskaitoje Imties dydis, tai statistika, kurią privaloma nurodyti kiekvienoje duomenų analizės ataskaitoje. 4.1.5 Kaip statistiškai aprašyti vieno kintamojo reikšmes? Prieš atliekant vieno kintamojo suvestines, reikia nustatyti kintamojo duomenų tipą. Panagrinėkime du kraštutinumus – nominaliuosius ir tolydžiuosius duomenis. Šiais atvejais – įprasti tokie pasirinkimai: Kategoriniams nominaliesiems duomenims nurodoma: imties dydis; dažnių lentelės. Tolydiesiems duomenims: imties dydis; duomenų centras (įprastai vidurkis arba mediana); duomenų sklaida (įprastai SD, kvantiliai, MAD arba IQR). Jei duomenys ranginiai arba skaitiniai diskretieji, jiems gali tikti ir tolydžiųjų, ir diskrečiųjų duomenų aprašymo metodai. Įvertinus, į ką – tolydžiuosius ar diskrečiuosius duomenis – konkretus kintamasis panašesnis, parenkamas aprašomosios statistikos metodas. Įprasti pasirinkimai: Ranginiams duomenims: imties dydis; dažnių lentelė; mediana; kiti centrą (pvz., vidurkis) ir sklaidą (pvz., SD) aprašantys dydžiai naudojami tik tada, jei jie turi prasmę. Diskretiesiems skaitiniams duomenims: imties dydis; duomenų centras; duomenų sklaida; dažnių lentelė (įprasta, kai skirtingų reikšmių mažai). 4.1.6 Kaip pasirinkti tolydiesiems duomenims tinkamas suvestines? Kai jau nustatėme, kad duomenys tolydieji, toliau žiūrime į duomenų pasiskirstymo formą ir įvertiname, ar yra išskirčių. Tokiu būdu nustatome, kokios statistikos geriausiai apibūdina duomenų centrą ir sklaidą (išsidėstymą apie tą centrą): Jei duomenys simetriški ir be ryškių išskirčių, įprastai centrui apibūdinti naudojamas aritmetinis vidurkis ir sklaidai – standartinis nuokrypis (SD). Jei duomenys smarkiai asimetriški arba turi ryškių išskirčių, labiau tinka išskirtims ir nukrypimams atsparios (robastiškos) statistikos: centrui – mediana, sklaidai – kvartiliai, MAD (medianinis absoliutusis nuokrypis nuo medianos), IQR (tarpkvartilinis plotis). Galutinėje ataskaitoje tyrėjo nuožiūra pasirenkamas vienas labiausiai tinkantis centro padėties ir vienas sklaidos aprašymo būdas. Taip pat nurodomas ir imties dydis. Statistiškai aprašant tolydžiuosius duomenis įprasta apibūdinti imties dydį, duomenų centro padėtį ir sklaidą. 4.1.7 Kvantiliai ir kvartiliai Kvantilis (pažymėkime raide \\(q\\)) – \\(\\beta\\)-tosios eilės kvantilis yra reikšmė, kuri variacinę eilutę dalina į \\(\\beta \\times 100\\) ir \\((1-\\beta) \\times 100\\) procentinių dalių. Čia \\(\\beta\\) yra dalis – skaičius tarp 0 ir 1 \\((0 &lt; \\beta &lt; 1)\\). Atkreipkite dėmesį, kad kvantilis matuojamas tais pačiais matavimo vienetais, kaip ir tiriamieji duomenys: jei matuojame ilgį centimetrais, tai kvantilis yra tam tikras ilgis centimetrais, jei masę kilogramais, tai ir kvantilis bus tam tikra masė kilogramais. Pvz., jei kvantilis \\(q_{\\beta=0.2} = 35 \\mu m\\) (įprastai bus žymimas tiesiog \\(q_{0.2} = 35 \\mu m\\)), tai reiškia, kad 20% mūsų imtyje esančių tiriamųjų yra mažesni už \\(35 \\mu m\\) ir 80% didesni už šį kvantilį. Tai pat pastebėkite, jog skaičius \\(\\beta\\) šalia kvantilio nurodo, kuri imties narių dalis yra mažesnė už kvantilio reikšmę. Kvantilis \\(q_{0.5}\\) yra plačiausiai naudojamas ir turi specialų pavadinimą – mediana \\((Md)\\). Tai skaičius, variacinę eilutę dalinantis į dvi lygias dalis santykiu 50%:50%. Kvartiliai – tai kvantiliai, dalijantys variacinę duomenų eilutę į 4 lygias dalis. Įprastai žymimi \\(Q_1\\), \\(Md\\), \\(Q_3\\). 4.1.8 Statistinis dažnis ir dažnių lentelės Kintamojo reikšmės dažnis \\(f_i\\) – tai skaičius, nurodantis, kiek kartų reikšmė \\(x_i\\) pasikartojo duomenų eilutėje kinta intervale nuo 0 iki \\(+\\infty\\). Kintamojo reikšmės santykinis dažnis \\(\\frac {f_i}{n}\\) – tai skaičius, nurodantis, kurią duomenų eilutės dalį sudaro reikšmė \\(x_i\\). Įprastai tai skaičius tarp 0 ir 1 \\(\\left(0 \\le \\frac{f_i}{n} \\le 1 \\right)\\). Gali būti išreikštas ir procentais. Čia \\(n\\) – visas elementų skaičius (imties dydis). Kintamojo reikšmių dažnių lentelėse nurodoma, kiek kartų kiekviena diskrečiojo ar kategorinio kintamojo reikšmė pasikartojo. Dažnių lentelės – tai pagrindinės kategorinių duomenų suvestinės. 4.2 Pasirengimas praktinei daliai 4.2.1 Paketai ir RStudio projektas Darbui reikalingi R paketai: tidyverse, dplyr, Hmisc, DescTools, psych, descriptr, Rcmdr (bei jo priedai). Papildomai reikia atsinaujinti darbui su R Commander skirtus paketus: # R Commander papildiniai install.packages(&quot;devtools&quot;) install.packages(&quot;RcmdrPlugin.EZR&quot;) install.packages(&quot;RcmdrPlugin.KMggplot2&quot;) devtools::install_github(&quot;GegznaV/RcmdrPlugin.EZR@unmodified_Rcmdr_menu&quot;) devtools::install_github(&quot;GegznaV/biostat&quot;) devtools::install_github(&quot;GegznaV/RcmdrPlugin.biostat&quot;) RStudio projekto šablonas (atsisiųsti ). Atsisiųskite, aplanką persivadinkite į „Pratybos-4“. Projekte yra R Commander konfigūravimo nurodymai. Atsidarę projektą galėsite užsikrauti „Rcmdr“ (R Commander) 3 langų režimu. Prieš diegdami naujus paketus, įsitikinkite, kad atidarytas tik vienas „RStudio“ langas ir jame išjungtas projektas (turite matyti „Project: (none)“). 4.2.2 Duomenys Šio skyriaus pavyzdžiuose naudosime sumažintą duomenų lentelės iris variantą – paimsime tik pirmą („Sepal.Length“) ir paskutinį („Species“) stulpelius: iris2 &lt;- dplyr::select(iris, Sepal.Length, Species) head(iris2) ## Sepal.Length Species ## 1 5.1 setosa ## 2 4.9 setosa ## 3 4.7 setosa ## 4 4.6 setosa ## 5 5.0 setosa ## 6 5.4 setosa glimpse(iris2) ## Observations: 150 ## Variables: 2 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,... ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, s... Kita duomenų lentelė pavyzdys_3 bus sukurta naudojant programos kodą: pavyzdys_3 &lt;- data.frame( lapu_skaicius = c(24L, 22L, 28L, 25L, 25L), lapu_ilgis = c(1.3, NA, 2.2, 1.1, 1.6), kvapo_stiprumas = ordered(c(&quot;silpnas&quot;, &quot;vidutinis&quot;, &quot;stiprus&quot;, &quot;stiprus&quot;, NA)), ziedu_spalva = factor(c(&quot;raudona&quot;, &quot;geltona&quot;, &quot;geltona&quot;, &quot;balta&quot;, &quot;balta&quot;)), ar_augo_lauke = c(FALSE, TRUE, TRUE, FALSE, TRUE), komentaras = c(&quot;-&quot;, &quot;-&quot;, &quot;tirta ryte&quot;, &quot;-&quot;, &quot;-&quot;), stringsAsFactors = FALSE # Uždraudžiam tekstą versti į kategorinį kintamąjį ) print(pavyzdys_3) ## lapu_skaicius lapu_ilgis kvapo_stiprumas ziedu_spalva ar_augo_lauke ## 1 24 1.3 silpnas raudona FALSE ## 2 22 NA vidutinis geltona TRUE ## 3 28 2.2 stiprus geltona TRUE ## 4 25 1.1 stiprus balta FALSE ## 5 25 1.6 &lt;NA&gt; balta TRUE ## komentaras ## 1 - ## 2 - ## 3 tirta ryte ## 4 - ## 5 - glimpse(pavyzdys_3) ## Observations: 5 ## Variables: 6 ## $ lapu_skaicius &lt;int&gt; 24, 22, 28, 25, 25 ## $ lapu_ilgis &lt;dbl&gt; 1.3, NA, 2.2, 1.1, 1.6 ## $ kvapo_stiprumas &lt;ord&gt; silpnas, vidutinis, stiprus, stiprus, NA ## $ ziedu_spalva &lt;fct&gt; raudona, geltona, geltona, balta, balta ## $ ar_augo_lauke &lt;lgl&gt; FALSE, TRUE, TRUE, FALSE, TRUE ## $ komentaras &lt;chr&gt; &quot;-&quot;, &quot;-&quot;, &quot;tirta ryte&quot;, &quot;-&quot;, &quot;-&quot; Užduotis 4.1 Naudodami funkciją dplyr::glimpse() prisiminkime esminius duomenų lentelės iris bruožus. 4.3 Suvestinės baziniu R būdu 4.3.1 Funkcija summary() Funkcija summary() suvestinę atlieka kiekvienam duomenų lentelės kintamajam atskirai. Pastebėkite, kad suvestinės tipas parenkamas pagal kintamojo tipą. summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## summary(pavyzdys_3) ## lapu_skaicius lapu_ilgis kvapo_stiprumas ziedu_spalva ## Min. :22.0 Min. :1.10 silpnas :1 balta :2 ## 1st Qu.:24.0 1st Qu.:1.25 stiprus :2 geltona:2 ## Median :25.0 Median :1.45 vidutinis:1 raudona:1 ## Mean :24.8 Mean :1.55 NA&#39;s :1 ## 3rd Qu.:25.0 3rd Qu.:1.75 ## Max. :28.0 Max. :2.20 ## NA&#39;s :1 ## ar_augo_lauke komentaras ## Mode :logical Length:5 ## FALSE:2 Class :character ## TRUE :3 Mode :character ## ## ## ## Kiekybiniams kintamiesiems pateikiama penkiaskaitė suvestinė ir vidurkis bei nurodoma, kiek yra praleistų reikšmių (NA – praleista, neįrašyta reikšmė, angl. not available). Kategoriniams kintamiesiems išvardijamos kategorijos ir jų dažnis. Jei kategorijų daugiau nei 5, išvardijamos penkios pirmosios kategorijos, o ties kitomis parašoma “Others:” ir parašoma, kiek kitose kategorijose yra narių. Atkreipkite dėmesį, jog loginio kintamojo suvestinėje parašoma kintamojo klasė „Mode :logical“ ir nurodomas TRUE ir FALSE reikšmių skaičius. Tuo tarpu, simbolių eilutėms (character) nurodoma klasė „Class :character“ ir reikšmių skaičius, detalesnė suvestinė apskritai neatliekama. Užduotis 4.2 Naudodami funkciją summary() atlikite duomenų lentelių BOD, chickwts, Orange bei swiss kintamųjų reikšmių suvestines. Atidžiai peržvelkite rezultatus. Įsitikinkite, kad suprantate visus niuansus. 4.3.2 Hmisc::describe() Kitas būdas padaryti visos duomenų lentelės kintamųjų suvestinę – naudoti funkciją describe() iš paketo Hmisc. Ši funkcija duomenis aprašo dviem būdais pagal unikalių (angl. distinct) reikšmių skaičių: arba kaip tolydžiuosius kintamuosius (jei reikšmių daug), arba kaip diskrečiuosius (jei reikšmių mažai). Užsikraukime paketą: library(Hmisc) Išbandykime funkciją: Hmisc::describe(iris2) ## iris2 ## ## 2 Variables 150 Observations ## --------------------------------------------------------------------------- ## Sepal.Length ## n missing distinct Info Mean Gmd .05 .10 ## 150 0 35 0.998 5.843 0.9462 4.600 4.800 ## .25 .50 .75 .90 .95 ## 5.100 5.800 6.400 6.900 7.255 ## ## lowest : 4.3 4.4 4.5 4.6 4.7, highest: 7.3 7.4 7.6 7.7 7.9 ## --------------------------------------------------------------------------- ## Species ## n missing distinct ## 150 0 3 ## ## Value setosa versicolor virginica ## Frequency 50 50 50 ## Proportion 0.333 0.333 0.333 ## --------------------------------------------------------------------------- Suvestinės elementai: Viršuje pateikiamas duomenų lentelės pavadinimas, kintamųjų (stulpelių) ir stebėjimų (eilučių) skaičius; Brūkšniais (-----) atskirtos kiekvieno kintamojo suvestinės; Kintamojo suvestinėje parašomas kintamojo pavadinimas (pvz., Species); Toliau nurodomos šios aprašomosios statistikos (visiems kintamiesiems): n – stebėjimų skaičius (be praleistų reikšmių); missing – praleistų reikšmių skaičius; distinct – unikalių (nepasikartojančių) reikšmių skaičius; Tik tolydiesiems kintamiesiems: Info – santykinės informacijos matas, susijęs su kintamojo tolydumu. Kinta nuo 0 iki 1. Jei visos reikšmės vienodos – lygus 0. Tikslus mato apibrėžimas pateiktas funkcijos dokumentacijoje; Mean – aritmetinis vidurkis; Gmd (Gini mean difference) – vidutinis absoliutusis skirtumas tarp dviejų atsitiktinai paimtų taškų (išskirtims atsparus duomenų sklaidos matas); .05, .10, … , .95 – 5%, 10%, …, 95% procentiliai; lowest, highest – po penkias didžiausias ir mažiausias reikšmes (gali padėti nustatyti, ar kuri nors reikšmė yra aiški išskirtis); Tik diskretiesiems (tarp jų ir kategoriniams): Dažnių lentelė, kurioje išvardijamos: Value – kintamųjų reikšmės; Frequency – absoliutieji dažniai; Proportion – proporcijos (santykiniai dažniai). Tikslus funkcijos elgesys aprašytas dokumentacijoje (komanda ?Hmisc::describe). Užduotis 4.3 Naudodami funkciją Hmisc::describe() atlikite duomenų lentelių BOD, chickwts, Orange bei swiss kintamųjų reikšmių suvestines. Panagrinėkite rezultatus. Įsitikinkite, kad visa atspausdinta informacija jums aiški. 4.3.3 psych::describe() Dar vienas būdas greitai aprašyti duomenis – naudoti funkciją describe() iš paketo psych. Ji skirta tik skaitiniams duomenims. Šį kartą paketo neužsikrausime, o naudosime operatorių ::. Funkcijos naudojimo šablonas: # Bazinis naudojimas psych::describe(duomenu_lentelė) # Skaičiuojamos papildomos statistikos psych::describe(duomenu_lentelė, quant = c(.05, .25, .75, .95), IQR = TRUE) Pavyzdys 1: psych::describe(iris) ## vars n mean sd median trimmed mad min max range skew ## Sepal.Length 1 150 5.84 0.83 5.80 5.81 1.04 4.3 7.9 3.6 0.31 ## Sepal.Width 2 150 3.06 0.44 3.00 3.04 0.44 2.0 4.4 2.4 0.31 ## Petal.Length 3 150 3.76 1.77 4.35 3.76 1.85 1.0 6.9 5.9 -0.27 ## Petal.Width 4 150 1.20 0.76 1.30 1.18 1.04 0.1 2.5 2.4 -0.10 ## Species* 5 150 2.00 0.82 2.00 2.00 1.48 1.0 3.0 2.0 0.00 ## kurtosis se ## Sepal.Length -0.61 0.07 ## Sepal.Width 0.14 0.04 ## Petal.Length -1.42 0.14 ## Petal.Width -1.36 0.06 ## Species* -1.52 0.07 Suvestinės elementai: Eilutėse – kintamųjų pavadinimai. Pavadinimai su žvaigždute _(*)_ reiškia, kad kintamieji – ne skaitiniai ir tik interpretuojami, kaip skaitiniai. Tik retais atvejais šios eilutės yra prasmingos; vars – kintamojo eilės numeris; n – stebėjimų skaičius (be praleistų reikšmių); mean – aritmetinis vidurkis; sd – standartinis nuokrypis (apibūdina duomenų sklaidą); trimmed – 10% nupjautinis vidurkis (atmetama po 5% didžiausių ir mažiausių reikšmių ir iš likusių skaičiuojamas vidurkis); median – mediana; mad – išskirtims atsparus sklaidos matas – absoliutaus nuokrypio nuo medianos mediana (angl. median absolute deviation from the median); minimum – mažiausia reikšmė; maximum – didžiausia reikšmė; skew (skewness) – asimetrijos koeficientas: jei \\(0\\pm0,5\\) – duomenys (daugmaž) simetriški, \\(&lt;0\\) – neigiama asimetrija, \\(&gt;0\\) – teigiama asimetrija.; kurtosis (excess kurtosis) – eksceso koeficientas: skirstinio formą apibūdinantis matas. Kai \\(0\\) – tai skirstinio lėkštumas/smailumas toks, kaip normaliojo skirstinio; se (standard error of mean) – standartinė vidurkio paklaida (vidurkių standartinis nuokrypis, apibūdina vidurkių sklaidą). Pavyzdys 2: Pavyzdys skaičiuojant papildomas statistikas. psych::describe(iris, quant = c(.05, .25, .75, .95), IQR = TRUE) ## vars n mean sd median trimmed mad min max range skew ## Sepal.Length 1 150 5.84 0.83 5.80 5.81 1.04 4.3 7.9 3.6 0.31 ## Sepal.Width 2 150 3.06 0.44 3.00 3.04 0.44 2.0 4.4 2.4 0.31 ## Petal.Length 3 150 3.76 1.77 4.35 3.76 1.85 1.0 6.9 5.9 -0.27 ## Petal.Width 4 150 1.20 0.76 1.30 1.18 1.04 0.1 2.5 2.4 -0.10 ## Species* 5 150 2.00 0.82 2.00 2.00 1.48 1.0 3.0 2.0 0.00 ## kurtosis se IQR Q0.05 Q0.25 Q0.75 Q0.95 ## Sepal.Length -0.61 0.07 1.3 4.60 5.1 6.4 7.25 ## Sepal.Width 0.14 0.04 0.5 2.34 2.8 3.3 3.80 ## Petal.Length -1.42 0.14 3.5 1.30 1.6 5.1 6.10 ## Petal.Width -1.36 0.06 1.5 0.20 0.3 1.8 2.30 ## Species* -1.52 0.07 2.0 1.00 1.0 3.0 3.00 Papildomai skaičiuojami nurodyti kvantiliai (.25 → Q0.25 → 25% procentilis ir t.t.) bei tarpkvartilinis atstumas (IQR). Užduotis 4.4 Naudodami funkciją psych::describe() atlikite duomenų lentelių BOD, chickwts, Orange bei swiss kintamųjų reikšmių suvestines. 4.3.4 psych::describeBy(): skaitinės suvestinės pogrupiams Norėdami aprašyti kiekvieną pogrupį atskirai galime naudodami funkciją psych::describeBy(). Kaip ir psych::describe(), ši funkcija tinka tik skaitinių kintamųjų aprašymui. Naudojimo šablonas: # Naudojimo principas psych::describeBy(duomenys, group = duomenys $ faktoriaus_pavadinimas, mat = TRUE, digits = 15) Čia: duomenys – duomenų lentelės pavadinimas; faktoriaus_pavadinimas – kategorinio kintamojo iš duomenų lentelės pavadinimas; mat = TRUE – atsakymą pateikti duomenų lentelės pavidalu; digits – iki kiek skaičių po kablelio suapvalinti atsakymą. Funkcijos psych::describe() ir psych::describeBy() tinka tik skaitinių kintamųjų aprašymui. Žvaigždute pažymėti kintamieji nėra skaitiniai, tad jų aprašymo interpretacija miglota. Pavyzdys 1: psych::describeBy(iris, group = iris$Species, mat = TRUE) ## item group1 vars n mean sd median trimmed ## Sepal.Length1 1 setosa 1 50 5.006 0.3524897 5.00 5.0025 ## Sepal.Length2 2 versicolor 1 50 5.936 0.5161711 5.90 5.9375 ## Sepal.Length3 3 virginica 1 50 6.588 0.6358796 6.50 6.5725 ## Sepal.Width1 4 setosa 2 50 3.428 0.3790644 3.40 3.4150 ## Sepal.Width2 5 versicolor 2 50 2.770 0.3137983 2.80 2.7800 ## Sepal.Width3 6 virginica 2 50 2.974 0.3224966 3.00 2.9625 ## Petal.Length1 7 setosa 3 50 1.462 0.1736640 1.50 1.4600 ## Petal.Length2 8 versicolor 3 50 4.260 0.4699110 4.35 4.2925 ## Petal.Length3 9 virginica 3 50 5.552 0.5518947 5.55 5.5100 ## Petal.Width1 10 setosa 4 50 0.246 0.1053856 0.20 0.2375 ## Petal.Width2 11 versicolor 4 50 1.326 0.1977527 1.30 1.3250 ## Petal.Width3 12 virginica 4 50 2.026 0.2746501 2.00 2.0325 ## Species*1 13 setosa 5 50 1.000 0.0000000 1.00 1.0000 ## Species*2 14 versicolor 5 50 2.000 0.0000000 2.00 2.0000 ## Species*3 15 virginica 5 50 3.000 0.0000000 3.00 3.0000 ## mad min max range skew kurtosis se ## Sepal.Length1 0.29652 4.3 5.8 1.5 0.11297784 -0.4508724 0.04984957 ## Sepal.Length2 0.51891 4.9 7.0 2.1 0.09913926 -0.6939138 0.07299762 ## Sepal.Length3 0.59304 4.9 7.9 3.0 0.11102862 -0.2032597 0.08992695 ## Sepal.Width1 0.37065 2.3 4.4 2.1 0.03872946 0.5959507 0.05360780 ## Sepal.Width2 0.29652 2.0 3.4 1.4 -0.34136443 -0.5493203 0.04437778 ## Sepal.Width3 0.29652 2.2 3.8 1.6 0.34428489 0.3803832 0.04560791 ## Petal.Length1 0.14826 1.0 1.9 0.9 0.10009538 0.6539303 0.02455980 ## Petal.Length2 0.51891 3.0 5.1 2.1 -0.57060243 -0.1902555 0.06645545 ## Petal.Length3 0.66717 4.5 6.9 2.4 0.51691747 -0.3651161 0.07804970 ## Petal.Width1 0.00000 0.1 0.6 0.5 1.17963278 1.2587179 0.01490377 ## Petal.Width2 0.22239 1.0 1.8 0.8 -0.02933377 -0.5873144 0.02796645 ## Petal.Width3 0.29652 1.4 2.5 1.1 -0.12181190 -0.7539586 0.03884138 ## Species*1 0.00000 1.0 1.0 0.0 NaN NaN 0.00000000 ## Species*2 0.00000 2.0 2.0 0.0 NaN NaN 0.00000000 ## Species*3 0.00000 3.0 3.0 0.0 NaN NaN 0.00000000 Užduotis 4.5 Naudodami funkciją psych::describeBy() atlikite duomenų lentelių chickwts, OrchardSprays bei PlantGrowth kintamųjų reikšmių suvestines pogrupiais. 4.4 Operatorius %&gt;% Viena iš pageidaujamų programos kodo savybių – galimybė kuo greičiau suprasti, kas tuo kodu vykdoma. Šiam tikslui sukurtas operatorius %&gt;%. Tai funkcijų jungimo į grandinę operatorius („pypkė“, angl. pipe operator). Vykdyti interaktyvią analizę moderniais programos R paketais (tokiais kaip dplyr, tidyr, …) bei nenaudoti operatoriaus %&gt;% – tiesiog neįsivaizduojama. Jis yra toks populiarus, kad netgi RStudio turi specialią sparčiųjų klavišų kombinaciją operatoriui įterpti (Ctrl+Shift+M). Ilgasis operatoriaus vardas – funkcijų jungimo į grandinę operatorius %&gt;% (angliškai pipeline operator). Tačiau mes jį vadinsime jungimo operatoriumi (arba kodiniu pavadinimu „pypkė“, angliškai pipe). Operatorius %&gt;% yra pritaikytas dirbti su daugeliu tidyverse sistemos funkcijų. Operatorius %&gt;% yra paketo magrittr dalis. Dėl patogumo, jis taip pat užkraunamas su kitais paketais, pvz., dplyr ir tidyr. Štai iliustracija, kaip naudojamas operatorius: # Užkraunamas paketas `magrittr` library(magrittr) # Operatoriaus naudojimo PRINCIPAS # Komanda: funkcija(duomenys) # Gali būti pakeista į: duomenys %&gt;% funkcija() Arba: # Ilgesnė komanda, kurioje funkcijos naudojamos įdėtiniu būdu: (funkcija_3(funkcija_2(funkcija_1(duomenys))) # Ta pati komanda, užrašyta funkcijas jungiant į grandinę: duomenys %&gt;% funkcija_1() %&gt;% funkcija_2() %&gt;% funkcija_3() Ką operatorius %&gt;% padaro? Ogi kairėje operatoriaus pusėje esančius duomenis paverčia pirmu dešinėje pusėje esančios funkcijos argumentu. Jei grandinėje funkcijų yra daugiau, tai, tarkime, išraiškos duomenys %&gt;% funkcija_1() rezultatas yra pradiniai duomenys funkcijai funkcija_2(). Šitaip R programos kodas tampa žymiai lengviau suprantamas. Išnagrinėkime tolimesnius šio skyriaus pavyzdžius ir įsitikinsime patys. Paprastas pavyzdys su vektoriumi: # Įprastinis užrašymas sum(c(1, 2, 3)) ## [1] 6 # Naudojant %&gt;% c(1, 2, 3) %&gt;% sum() ## [1] 6 Paprastas pavyzdys su duomenų lentele: # Įprastinis užrašymas head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # Naudojant %&gt;% iris %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Pavyzdys, kai funkcijoje yra papildomų argumentų: # Įprastinis užrašymas head(iris, 3) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa # Naudojant %&gt;% iris %&gt;% head(3) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa Toliau bus pateiktas sudėtingas pavyzdys. Jame bus naudojamos funkcijos iš paketo dplyr. Nagrinėdami jį galėsite įvertinti, ar operatorius %&gt;% iš tiesų pagerina programos kodo įskaitomumą. # Užkraunamas paketas `dplyr` library(dplyr) # Pavyzdys A: įprastinis užrašymas įdėtiniu (funkcija funkcijoje) būdu: summarise( mutate( filter(iris, Species == &quot;setosa&quot;), Length = Sepal.Length + Petal.Length ), mean = mean(Length) ) ## mean ## 1 6.468 Jei įdėtiniu būdu užrašoma daug funkcijų, kurios taip pat turi argumentų, užrašas tampa sudėtingas suprasti. Be to padidėja tikimybė padaryti klaidą. Tad pažiūrėkime į kitą pavyzdį. # Pavyzdys B: naudojamas %&gt;% operatorius: iris %&gt;% filter(Species == &quot;setosa&quot;) %&gt;% mutate(Length = Sepal.Length + Petal.Length) %&gt;% summarise(mean = mean(Length)) ## mean ## 1 6.468 Abiejų pavyzdžių rezultatas tas pats. Nors kol kas jums galbūt dar neaišku, ką daro funkcijos, tačiau pavyzdyje B bent jau suprantama taikomų funkcijų eiga (pirma filter(), po to mutate(), dar po to summarise()) ir kurie argumentai kuriai funkcijai priklauso. Nors atidžiau pažiūrėję gal netgi ir numanysite, ką pateiktas programos kodas daro. O atveju A – tai būtų žymiai sudėtingesnė užduotis. (Kodas: pasirenkama tik setosa rūšies narius, sudedami taurėlapių ir vainiklapių ilgiai ir apskaičiuojamas jų vidurkis.) Beje, galimas ir dar vienas užrašymo būdas, bet tam naudojami tarpiniai kintamieji. # Pavyzdys C (naudojami tarpiniai kintamieji): tik_setosa &lt;- filter(iris, Species == &quot;setosa&quot;) tik_setosa2 &lt;- mutate(tik_setosa, Length = Sepal.Length + Petal.Length) ilgio_vidurkis &lt;- summarise(tik_setosa2, mean = mean(Length)) ilgio_vidurkis ## mean ## 1 6.468 Užduotis 4.6 Šias R kodo eilutes užrašykite naudodami operatorių %&gt;%: summary(iris); mean(23:30); tail(iris, n = 20); summary(tail(data.table::fread(“http://calcnet.mth.cmich.edu/org/spss/V16_materials/DataSets_v16/Diseaseoutbreak.txt”))); mean(c(log(20*pi, base = 16), NA, 14, 24), na.rm = TRUE); Daugiau apie šį operatorių ir jo „brolius“: Paketo magrittr tinklapyje http://magrittr.tidyverse.org/; Vadovėlyje „R for Data Science“ http://r4ds.had.co.nz/pipes.html. 4.5 Suvestinės tidyverse būdu Sistemoje tidyverse, statistinėms suvestinėms daryti naudojamos šios funkcijos iš paketo dplyr: summarise() arba summarize() – viena iš pagrindinių dplyr funkcijų, skirta darbui su viena duomenų lentele. Ji skirta suvestinių skaičiavimui, tad duomenų lentelės dydį redukuoja iki suvestinėms reikalingo dydžio lentelės. Rezultatas yra duomenų lentelė (ne sąrašas ar matrica); count() – dažnių lentelių sudarymas (suvestinių funkcija, kurios rezultatas – dažnių lentelė); group_by() – eilučių grupavimas (vėliau skaičiavimai, pvz., naudojant summarise(), bus vykdomi kiekvienai grupei atskirai); ungroup() – grupavimo panaikinimas. Dažnių lentelės sudarymas: # Naudojimo principas (pavadinimai be kabučių) duomenu_lentele %&gt;% count(kategorinio_kintamojo_pavadinimas, kategorinio_kintamojo_pavadinimas_2) Suvestinė visai imčiai: # Naudojimo principas (pavadinimai be kabučių) duomenu_lentele %&gt;% summarise(rezultato_pavadinimas = suvestines_funkcija(kintamojo_pavadinimas)) Suvestinės pogrupiams: # Naudojimo principas (pavadinimai be kabučių) duomenu_lentele %&gt;% group_by(kategorinio_kintamojo_pavadinimas, kategorinio_kintamojo_pavadinimas_2) %&gt;% summarise(rezultato_pavadinimas = suvestines_funkcija(kintamojo_pavadinimas)) PASTABA. Paketo dplyr funkcijos, tokios kaip count() ar n(), šiuo metu nerodo grupių, kurių dažnis lygus 0. 4.5.1 Suvestinių funkcijos naudojamos su summarise() Tam, kad suvestinių funkciją būtų galima naudoti summarise() skliaustuose, ji turi tenkinti tokias sąlygas: Funkcija turi būti skirta darbui su duomenų eilutėmis – vektoriais, o ne kito tipo duomenimis; Funkcijos rezultatas turi būti lygiai vienas skaičius. Kitu atveju summarise() rodys klaidą. Naudingos suvestinių funkcijos, tinkamos naudoti su summarise() (vietoje taško reikia įrašyti kintamojo pavadinimą): Duomenų centras: mean(.) – vidurkis; mean(., trim = .10) – 10% nupjautinis vidurkis. Skaičių galima keisti nuo 0 iki 0.5; median(.) – mediana; DescTools::Hmean(.) – harmoninis vidurkis; DescTools::Gmean(.) – geometrinis vidurkis. Sklaida: sd(.) – standartinis nuokrypis, var(.) – dispersija; IQR(.) – IQR; mad(.) – MAD. Kitos padėties statistikos: min(.) – mažiausia reikšmė; max(.) – didžiausia reikšmė; quantile(. , probs = 0.25), quantile(. , probs = 0.75) – 25% ir 75% procentiliai. Skaičių probs galima keisti nuo 0 iki 1. Pozicija (eilučių atžvilgiu): first(.) – pirmoji reikšmė pagal eilę lentelėje; last(.) – paskutinė reikšmė pagal eilę lentelėje; nth(. , n = 2) – n-toji reikšmė pagal eilę lentelėje (šiuo atveju – antroji reikšmė). Skaičius, dydis: n() – imties arba grupės dydis. Pastebėkite, kad skliaustuose nieko nerašoma; n_distinct() – unikalių (nepasikartojančių) reikšmių skaičius; sum(is.na(.)) – trūkstamų reikšmių skaičius; sum(!is.na(.)) – netrūkstamų reikšmių skaičius. Skirstinio forma: DescTools::Kurt() – eksceso koeficientas (angl., excess kurtosis); DescTools::Skew() – asimetrijos koeficientas (angl., skewness). Jei duomenyse yra trūkstamų reikšmių, tai daugumos iš šių funkcijų skliaustuose galima nurodyti: na.rm = TRUE. Taip bus daromos suvestinės prieš tai pašalinus trūkstamas reikšmes. Alternatyva – papildomai naudoti funkciją na.omit(), pvz., sd(na.omit(x)). 4.5.2 Pavyzdžiai Dažnių lentelė pagal Species: iris_suvestine1 &lt;- iris %&gt;% count(Species) iris_suvestine1 ## # A tibble: 3 x 2 ## Species n ## &lt;fct&gt; &lt;int&gt; ## 1 setosa 50 ## 2 versicolor 50 ## 3 virginica 50 Suvestinėms visai imčiai naudojamos tik Sepal.Length reikšmės (nors jomis apsiriboti nebūtina): iris_suvestine2 &lt;- iris %&gt;% summarise(vidurkis = mean(Sepal.Length), st_nuokrypis = sd(Sepal.Length), mediana = median(Sepal.Length), mad = mad(Sepal.Length), harmoninis_vid = DescTools::Hmean(Sepal.Length), imties_dydis = n() ) iris_suvestine2 ## vidurkis st_nuokrypis mediana mad harmoninis_vid imties_dydis ## 1 5.843333 0.8280661 5.8 1.03782 5.728905 150 Suvestinės pogrupiams – papildomai pridedama tik viena eilutė su group_by() (taip nurodoma, pagal ką sudaryti grupes): iris_suvestine3 &lt;- iris %&gt;% group_by(Species) %&gt;% summarise(vidurkis = mean(Sepal.Length), st_nuokrypis = sd(Sepal.Length), mediana = median(Sepal.Length), mad = mad(Sepal.Length), harmoninis_vid = DescTools::Hmean(Sepal.Length), imties_dydis = n() ) iris_suvestine3 ## # A tibble: 3 x 7 ## Species vidurkis st_nuokrypis mediana mad harmoninis_vid imties_dydis ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 setosa 5.01 0.352 5 0.297 4.98 50 ## 2 versico~ 5.94 0.516 5.9 0.519 5.89 50 ## 3 virgini~ 6.59 0.636 6.5 0.593 6.53 50 Užduotis 4.7 Naudodami funkciją tidyverse sistemos būdą, atlikite duomenų lentelių BOD, chickwts, OrchardSprays bei PlantGrowth kintamųjų reikšmių suvestines pogrupiais: Iš pradžių kiekvienam kintamajam (visai imčiai, ne pogrupiams) atlikite suvestines atskirai. Būtinai įvertinkite, kokia simetrija/asimetrija. Po to pasirinkite vieną kategorinį kintamąjį ir suvestines atlikite visiems likusiems kintamiesiems skaidydami į pogrupius. Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["duomenu-parengimas.html", "5. Duomenų pertvarkymas ir parengimas analizei 5.1 Teorinė dalis 5.2 Pasirengimas praktinei daliai 5.3 Duomenų lentelės klasės keitimas 5.4 Duomenų lentelės eilutės 5.5 Duomenų lentelės stulpeliai (kintamieji) 5.6 Lentelės formos keitimas 5.7 Kelių duomenų lentelių sujungimas", " 5. Duomenų pertvarkymas ir parengimas analizei 5.1 Teorinė dalis 5.1.1 Priklausomų ir nepriklausomų imčių duomenys Pav. 5.1: Kelių eksperimento imčių derinimas: priklausomos ir nepriklausomos duomenų imtys. Šalia schemos pavaizduotos duomenų lentelės, kokia forma programai R turėtų būti pateikiami priklausomų ir nepriklausomų imčių duomenys. Žymėjimai: Gr. – grupė (imtis), A, B – imčių (grupių) pavadinimai, X – kintamojo, kurį stebime/tiriame reikšmės. 5.1.2 Ilgasis ir platusis duomenų lentelių formatai Pav. 5.2: Duomenys plačiuoju (visa lentelė) ir ilguoju (tik keliolika pirmųjų eilučių) formatu. 5.1.3 Duomenų analizės dokumento struktūra Kiekviename dokumente, kuriame yra duomenų analizės kodas, šis kodas turi būti organizuotas į dalis tokia eilės tvarka: Programos kodas, užkraunantis visus reikiamus paketus. Programos kodas, kuris parenka pagrindinius nustatymus. Programos kodas, kuris įkelia reikiamus duomenis. Likusią analizės dalį atliekantis kodas. Analizės kodo dalys eilės tvarka: Paketų užkrovimas; Nustatymai; Duomenų įkėlimas; Visa kita. 5.1.4 Apie duomenų pertvarkymą ir „tidyverse“ Duomenų lentelių pertvarkymui dažnai naudojamos tidyverse sistemos funkcijos iš paketų dplyr (jei norite išgirsti, kaip tariama, į Google Translate) įrašykite „d-ply-r“) ir tidyr („tidy-r“). Paketas dplyr (d – nuo data frame, ply – nuo apply (taikyti), r – nuo programos R) suteikia lanksčią duomenų manipuliavimo „gramatiką“ ir yra pritaikytas efektyviam darbui su duomenų lentelėmis. Tinklapis ir dokumentacija: http://dplyr.tidyverse.org/ Paketo tidyr (tidy – padaryti tvarkingu, r – nuo programos R) funkcijos skirtos patogiam duomenų lentelių vertimui į tvarkingą formą (t. y., ne tiesiog keisti forma, bet versti į tokias lenteles, kur vienoje eilutėje – vienas stebėjimas, viename stulpelyje – vienas kintamasis, viename langelyje – vienas duomuo). Tinklapis ir dokumentacija: http://tidyr.tidyverse.org/ 5.2 Pasirengimas praktinei daliai 5.2.1 Paketai ir RStudio projektas Darbui reikalingi R paketai: tidyverse, dplyr, descriptr, Rcmdr (bei jo priedai). Papildomai reikia atsinaujinti darbui su R Commander skirtus paketus: install.packages(&quot;devtools&quot;) # R Commander papildiniai install.packages(&quot;RcmdrPlugin.EZR&quot;) install.packages(&quot;RcmdrPlugin.KMggplot2&quot;) devtools::install_github(&quot;GegznaV/RcmdrPlugin.EZR@unmodified_Rcmdr_menu&quot;) devtools::install_github(&quot;GegznaV/biostat&quot;) devtools::install_github(&quot;GegznaV/RcmdrPlugin.biostat&quot;) RStudio projekto šablonas (atsisiųsti). Atsisiųskite, aplanką persivadinkite į „Pratybos-5“. Projekte yra R Commander konfigūravimo nurodymai. Atsidarę projektą galėsite užsikrauti „Rcmdr“ (R Commander) 3 langų režimu. Prieš diegdami naujus paketus, įsitikinkite, kad atidarytas tik vienas „RStudio“ langas ir jame išjungtas projektas (turite matyti „Project: (none)“). Toliau reikia užsikrauti pagrindinius tidyverse paketus: library(tidyverse) Užduotis 5.1 Įsidiekite reikiamus atnaujinimus; Parsisiųskite šioms pratyboms skirtą projektą; Atsidarykite projektą ir užsikraukite reikiamus R paketus. 5.3 Duomenų lentelės klasės keitimas Klasės patikrinimas gali būti vykdomas naudojant funkciją class(), arba funkcijas, kurios prasideda is_*() arba is.*() (kurios analogiškos as*() funkcijoms): is.data.frame(); is_tibble(); is.matrix(). Klasės keitimas vykdomas funkcijomis, kurios prasideda as_*() arba as.*(): as.data.frame() – vertimas į standartinę duomenų lentelę (data.frame); as_tibble(), as_data_frame() – vertimas į tibble tipo duomenų lentelę (ją tiesiog kitaip atspausdina); as.matrix() – vertimas į matricą. Atkreipkite dėmesį, kad „is…“ funkcijos tikrina, o „as…“ funkcijos – keičia. # Atsitiktinai pasirenkame 5 eilutes set.seed(123456) iris_small &lt;- sample_n(iris, 5) class(iris_small) ## [1] &quot;data.frame&quot; Pavyzdžiai: „is…“ funkcijos is.data.frame(iris_small) ## [1] TRUE is_tibble(iris_small) ## [1] FALSE is.matrix(iris_small) ## [1] FALSE Pavyzdžiai: „as…“ funkcijos as.matrix(iris_small) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 120 &quot;6.0&quot; &quot;2.2&quot; &quot;5.0&quot; &quot;1.5&quot; &quot;virginica&quot; ## 113 &quot;6.8&quot; &quot;3.0&quot; &quot;5.5&quot; &quot;2.1&quot; &quot;virginica&quot; ## 58 &quot;4.9&quot; &quot;2.4&quot; &quot;3.3&quot; &quot;1.0&quot; &quot;versicolor&quot; ## 51 &quot;7.0&quot; &quot;3.2&quot; &quot;4.7&quot; &quot;1.4&quot; &quot;versicolor&quot; ## 53 &quot;6.9&quot; &quot;3.1&quot; &quot;4.9&quot; &quot;1.5&quot; &quot;versicolor&quot; Visas reikšmes pavertė į tą patį tipą – tekstą. as_data_frame(iris_small) ## # A tibble: 5 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 6 2.2 5 1.5 virginica ## 2 6.8 3 5.5 2.1 virginica ## 3 4.9 2.4 3.3 1 versicolor ## 4 7 3.2 4.7 1.4 versicolor ## 5 6.9 3.1 4.9 1.5 versicolor Atspausdino įprastai. as_tibble(iris_small) ## # A tibble: 5 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 6 2.2 5 1.5 virginica ## 2 6.8 3 5.5 2.1 virginica ## 3 4.9 2.4 3.3 1 versicolor ## 4 7 3.2 4.7 1.4 versicolor ## 5 6.9 3.1 4.9 1.5 versicolor Atspausdino kitaip. Skirtumas pasimato, kai duomenų lentelės didelės. as_tibble(iris) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows Užduotis 5.2 Užsikraukite duomenų lentelę swiss. Atspausdinkite ją konsolėje. Pakeiskite ją į „tibble“ tipo lentelę. Vėl atspausdinkite konsolėje (bet ne redaktoriaus lange). Ką pastebite? Užsikraukite duomenų lentelę Freedman iš paketo car. Vėl atlikite tą pačią užduotį. Kai atrodo praleistos reikšmės (NA)? Kaip pažymimi skaičiai, kurie yra 1000 ar didesni? Kaip sulygiuojami skaičiai, turintys kablelį? 5.4 Duomenų lentelės eilutės 5.4.1 Eilučių pavadinimai Bazinės R funkcijos darbui su eilučių pavadinimais: rownames() – parodo eilučių pavadinimus; rownames(data) &lt;- c(&quot;new&quot;, &quot;row&quot;, &quot;names&quot;) – priskiria naujus eilučių pavadinimus. Tidyverse funkcijos: rownames_to_column() arba tibble::rownames_to_column() – eilučių pavadinimus perkelia į naujai sukuria stulpelį; column_to_rownames() arba tibble::column_to_rownames() – pasirinkto stulpelio d. reikšmes paverčia eilučių pavadinimais. Pradiniame stulpelyje negali būti pasikartojančių reikšmių; rowid_to_column() arba tibble::rowid_to_column() – ištrina eilučių pavadinimus ir sukuria stulpelį su eilučių numeriais, prasidedančiais nuo 1. remove_rownames() arba tibble::remove_rownames() – pašalina eilučių pavadinimus; has_rownames() arba tibble::has_rownames() – patikrina, ar eilutės turi pavadinimus. data(Freedman, package = &quot;carData&quot;) head(Freedman) ## population nonwhite density crime ## Akron 675 7.3 746 2602 ## Albany 713 2.6 322 1388 ## Albuquerque NA 3.3 NA 5018 ## Allentown 534 0.8 491 1182 ## Anaheim 1261 1.4 1612 3341 ## Atlanta 1330 22.8 770 2805 Freedman2 &lt;- rownames_to_column(Freedman, &quot;area&quot;) head(Freedman2) ## area population nonwhite density crime ## 1 Akron 675 7.3 746 2602 ## 2 Albany 713 2.6 322 1388 ## 3 Albuquerque NA 3.3 NA 5018 ## 4 Allentown 534 0.8 491 1182 ## 5 Anaheim 1261 1.4 1612 3341 ## 6 Atlanta 1330 22.8 770 2805 Daugiau pavyzdžių bei kita reikiama informacija – šių funkcijų dokumentacijoje. Užduotis 5.3 Lentelė swiss. Sukurkite lentelės swiss kopiją pavadinimu swiss_1, kurioje eilučių pavadinimai perkelti į stulpelį „provincija“. Patikrinkite, ar pavyko. 5.4.2 Eilučių pasirinkimas ir pašalinimas Eilučių pasirinkimo funkcijos: filter(), t. y., dplyr::filter(), – eilučių pasirinkimas (filtravimas) pagal nurodytą sąlygą. slice() , t. y., dplyr::slice(), – eilučių pasirinkimas arba pašalinimas pagal indeksą (eilutės numerį). Kam to reikia? Pasirinkti tik mus šiuo metu dominančias eilutes (tiriamuosius ar stebėjimus) pagal loginę sąlygą. Pvz., tik jaunesnius kaip 60 metų asmenis. # Naudojimo principas (pavadinimai be kabučių) filter(duomenų_lentele, loginė_sąlyga, antra_loginė_sąlyga) Palyginimo operatoriai ir naudingos funkcijos aprašytos žemiau. # Naudojimo principas (pavadinimai be kabučių) slice(duomenų_lentele, paliekamų_eilučių_numeriai) Minus - ženklas prieš numerius nurodo, kad eilutės turi būti pašalinta. # Naudojimo principas (pavadinimai be kabučių) slice(duomenų_lentele, -(pašalinamų_eilučių_numeriai)) Pagalbinės funkcijos ir operatoriai eilučių pasirinkimui Su funkcija filter() dažnai naudojama su palyginimo ir loginiais operatoriais (pvz., lentelė 5.1). Ji sąlygos patikrinimą atlieka kiekvienai eilutei atskirai Lentelė 5.1: Palyginimą atliekantys R operatoriai. Operatorius Atliekamas palyginimas Pavyzdys Pavyzdžio atsakymas &lt; Ar mažiau 5 &lt; 8 TRUE &gt; Ar daugiau 5 &gt; 7 FALSE &lt;= Ar mažiau arba lygu 3 &lt;= 4 TRUE &gt;= Ar daugiau arba lygu 6 &gt;= 3 TRUE == Ar lygu 3 == 2 FALSE != Ar nelygu 3 != 2 TRUE %in% Ar tai vienas iš … &quot;C&quot; %in% c(&quot;G&quot;, &quot;M&quot;, &quot;C&quot;) TRUE TRUE yra loginė reikšmė „taip“, „tiesa“, FALSE – loginė reikšmė „ne“, „netiesa“. Palyginimo rezultatą modifikuojantys operatoriai: ! – neiginys (loginė operacija „NE“): iš „ne“ (FALSE) padaro „taip“ (TRUE), iš „taip“ padaro „ne“; ! (amžius &lt; 22): amžius nemažesnis už 22. Operatoriai, skirti sujungti kelias palyginimo sąlygas: | – jungtukas „ARBA“ (loginė operacija „ARBA“): diena == &quot;šeštadienis&quot; | diena == &quot;sekmadienis&quot;: mus dominanti diena arba šeštadienis, arba sekmadienis. &amp; – jungtukas „IR“ (loginė operacija „IR“): lytis == &quot;vyras&quot; &amp; amžius &lt; 35: ir vyras, ir jaunesnis nei 35. Kitos sąlygų patikrinimui naudingos funkcijos: is.na() – tikrina, ar eilutėje esanti reikšmė yra praleista (NA); !is.na() – tikrina, ar eilutėje esanti reikšmė nėra praleista; between() – tikrina, ar skaičius yra tam tikrame intervale. Daugiau informacijos – suvedus komandas ?Comparison bei ??base::logic. Pavyzdžiai Pasirenkame tik tas eilutes, kur Petal.Length mažiau už 1.4 (tokių eilučių yra tik 11). iris_fit1 &lt;- filter(iris, Petal.Length &lt; 1.4) glimpse(iris_fit1) ## Observations: 11 ## Variables: 5 ## $ Sepal.Length &lt;dbl&gt; 4.7, 4.3, 5.8, 5.4, 4.6, 5.0, 5.5, 4.4, 5.0, 4.5,... ## $ Sepal.Width &lt;dbl&gt; 3.2, 3.0, 4.0, 3.9, 3.6, 3.2, 3.5, 3.0, 3.5, 2.3,... ## $ Petal.Length &lt;dbl&gt; 1.3, 1.1, 1.2, 1.3, 1.0, 1.2, 1.3, 1.3, 1.3, 1.3,... ## $ Petal.Width &lt;dbl&gt; 0.2, 0.1, 0.2, 0.4, 0.2, 0.2, 0.2, 0.2, 0.3, 0.3,... ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, s... summary(iris_fit1) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.300 Min. :1.000 Min. :0.1000 ## 1st Qu.:4.450 1st Qu.:3.100 1st Qu.:1.200 1st Qu.:0.2000 ## Median :4.700 Median :3.200 Median :1.300 Median :0.2000 ## Mean :4.873 Mean :3.309 Mean :1.236 Mean :0.2273 ## 3rd Qu.:5.200 3rd Qu.:3.550 3rd Qu.:1.300 3rd Qu.:0.2500 ## Max. :5.800 Max. :4.000 Max. :1.300 Max. :0.4000 ## Species ## setosa :11 ## versicolor: 0 ## virginica : 0 ## ## ## Pasirenkame tik tas eilutes, kur Petal.Length daugiau už 4 ir rūšis yra versicolor arba virginica (tokių eilučių yra tik 11). iris_fit2 &lt;- filter(iris, Petal.Length &gt; 4, Species %in% c(&quot;versicolor&quot;, &quot;virginica&quot;)) glimpse(iris_fit2) ## Observations: 84 ## Variables: 5 ## $ Sepal.Length &lt;dbl&gt; 7.0, 6.4, 6.9, 6.5, 5.7, 6.3, 6.6, 5.9, 6.1, 6.7,... ## $ Sepal.Width &lt;dbl&gt; 3.2, 3.2, 3.1, 2.8, 2.8, 3.3, 2.9, 3.0, 2.9, 3.1,... ## $ Petal.Length &lt;dbl&gt; 4.7, 4.5, 4.9, 4.6, 4.5, 4.7, 4.6, 4.2, 4.7, 4.4,... ## $ Petal.Width &lt;dbl&gt; 1.4, 1.5, 1.5, 1.5, 1.3, 1.6, 1.3, 1.5, 1.4, 1.4,... ## $ Species &lt;fct&gt; versicolor, versicolor, versicolor, versicolor, v... summary(iris_fit2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.90 Min. :2.200 Min. :4.100 Min. :1.000 ## 1st Qu.:6.00 1st Qu.:2.800 1st Qu.:4.575 1st Qu.:1.500 ## Median :6.35 Median :3.000 Median :5.050 Median :1.800 ## Mean :6.41 Mean :2.945 Mean :5.133 Mean :1.777 ## 3rd Qu.:6.70 3rd Qu.:3.100 3rd Qu.:5.600 3rd Qu.:2.100 ## Max. :7.90 Max. :3.800 Max. :6.900 Max. :2.500 ## Species ## setosa : 0 ## versicolor:34 ## virginica :50 ## ## ## Pasirenkame visas eilutes nuo 140 iki paskutinės. n() yra pagalbinė funkcija, nurodanti, kad tai – paskutinė eilutė. iris_sl1 &lt;- slice(iris, 140:n()) glimpse(iris_sl1) ## Observations: 11 ## Variables: 5 ## $ Sepal.Length &lt;dbl&gt; 6.9, 6.7, 6.9, 5.8, 6.8, 6.7, 6.7, 6.3, 6.5, 6.2,... ## $ Sepal.Width &lt;dbl&gt; 3.1, 3.1, 3.1, 2.7, 3.2, 3.3, 3.0, 2.5, 3.0, 3.4,... ## $ Petal.Length &lt;dbl&gt; 5.4, 5.6, 5.1, 5.1, 5.9, 5.7, 5.2, 5.0, 5.2, 5.4,... ## $ Petal.Width &lt;dbl&gt; 2.1, 2.4, 2.3, 1.9, 2.3, 2.5, 2.3, 1.9, 2.0, 2.3,... ## $ Species &lt;fct&gt; virginica, virginica, virginica, virginica, virgi... summary(iris_sl1) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :5.800 Min. :2.500 Min. :5.000 Min. :1.800 ## 1st Qu.:6.250 1st Qu.:3.000 1st Qu.:5.100 1st Qu.:1.950 ## Median :6.700 Median :3.100 Median :5.200 Median :2.300 ## Mean :6.491 Mean :3.036 Mean :5.336 Mean :2.164 ## 3rd Qu.:6.750 3rd Qu.:3.150 3rd Qu.:5.500 3rd Qu.:2.300 ## Max. :6.900 Max. :3.400 Max. :5.900 Max. :2.500 ## Species ## setosa : 0 ## versicolor: 0 ## virginica :11 ## ## ## Pašaliname eilutes, kurių numeriai nuo 3 iki 145. iris_sl2 &lt;- slice(iris, -3:-145) glimpse(iris_sl2) ## Observations: 7 ## Variables: 5 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 6.7, 6.3, 6.5, 6.2, 5.9 ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.0, 2.5, 3.0, 3.4, 3.0 ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 5.2, 5.0, 5.2, 5.4, 5.1 ## $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 2.3, 1.9, 2.0, 2.3, 1.8 ## $ Species &lt;fct&gt; setosa, setosa, virginica, virginica, virginica, ... summary(iris_sl2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.900 Min. :2.500 Min. :1.4 Min. :0.200 ## 1st Qu.:5.500 1st Qu.:3.000 1st Qu.:3.2 1st Qu.:1.000 ## Median :6.200 Median :3.000 Median :5.1 Median :1.900 ## Mean :5.943 Mean :3.057 Mean :4.1 Mean :1.529 ## 3rd Qu.:6.400 3rd Qu.:3.200 3rd Qu.:5.2 3rd Qu.:2.150 ## Max. :6.700 Max. :3.500 Max. :5.4 Max. :2.300 ## Species ## setosa :2 ## versicolor:0 ## virginica :5 ## ## ## Užduotis 5.4 Visus šio skyriaus pavyzdžius perrašykite naudodami jungimo operatorių %&gt;%. Lentelė swiss. Kiek yra provincijų, kuriose vaisingumas (Fertility) didesnis nei 80%. Naudokite funkcijas filter() ir glimpse(). 5.4.3 Eilučių perrikiavimas Funkcija arrange() – eilučių rikiavimas tam tikra tvarka. Kam to reikia? Jei dėl tam tikrų priežasčių mums svarbi eilučių eilės tvarka; Jei norime pamatyti didžiausias ar mažiausias reikšmes. Eilutes išdėliojame pagal pirmo stulpelio reikšmes, jei yra vienodų reikšmių, tada tokias eilutes išrikiuojame pagal antro stulpelio reikšmes. Stulpelių gali būti nuo vieno iki tiek, kiek reikia. # Naudojimo principas (pavadinimai be kabučių) arrange(duomenų_lentele, stulpelio_pavadinimas, kito_stulpelio_pavadinimas) Norėdami išdėlioti mažėjimo tvarka, naudojame pagalbinę funkciją desc() (nuo angl. descending – išdėlioti mažėjimo tvarka). # Naudojimo principas (pavadinimai be kabučių) arrange(duomenų_lentele, desc(stulpelio_pavadinimas)) Pavyzdžiai Eilutes išdėliojame pagal Sepal.Width reikšmes nuo didžiausios iki mažiausios. # Naudojimo principas (pavadinimai be kabučių) iris_a1 &lt;- arrange(iris, desc(Sepal.Width)) head(iris_a1, 10) Eilutes išdėliojame pagal Petal.Width reikšmes nuo mažiausios iki didžiausios, tada mažėjimo tvarka pagal Sepal.Length, tada didėjimo tvarka pagal Sepal.Width ir Petal.Length. # Naudojimo principas (pavadinimai be kabučių) iris_a2 &lt;- arrange(iris, Petal.Width, desc(Sepal.Length), Sepal.Width, Petal.Length) head(iris_a2, 10) Užduotis 5.5 Visus šio skyriaus pavyzdžius perrašykite naudodami jungimo operatorių %&gt;%. Lentelė swiss_1 (iš skyriuje „Eilučių pavadinimai“ esančios užduotis 5.3): Kurioje provincijoje vaisingumas (Fertility) didžiausias? Kurioje provincijoje aukštesnio nei pradinio išsilavinimo lygis mažiausias? Atsakykite naudodami funkcijas arrange() ir head(). 5.4.4 Eilučių sugrupavimas Jei skaičiavimus norime atlikti grupių viduje, tada naudojame: group_by() – eilučių grupavimas (vėliau skaičiavimai bus vykdomi kiekvienai grupei atskirai). Jai priešinga komanda: ungroup() – grupavimo panaikinimas. Pačios savaime šios funkcijos nieko vertos. Tačiau labai vertingos kombinacijoje su kitomis funkcijomis, kurioms svarbu, ar yra grupavimas. iris_gr &lt;- group_by(iris, Species) iris_gr ## # A tibble: 150 x 5 ## # Groups: Species [3] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows class(iris_gr) ## [1] &quot;grouped_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Pasikeitė (buvo papildyta) duomenų lentelės klasė, todėl reikiamos paketo dplyr funkcijos skaičiavimus atliks pagal grupes. Užduotis 5.6 Kaip pasikeičia lentelės iris_gr klasė, kai panaudojame funkciją ungroup? (Lentelė iris_gr sukurta šiame skyriuje, tad žiūrėkite aukščiau). 5.5 Duomenų lentelės stulpeliai (kintamieji) 5.5.1 Stulpelių pervadinimas Pagrindinės funkcijos dirbti su stulpelių pavadinimais: colnames() – parodo stulpelių pavadinimus; rename() arba dplyr::rename() – stulpelių pervadinimas. set_names() arba purrr::set_names() – iš karto visų pavadinimų suteikimas. Kam to reikia? Pavadinimai įprastai keičiami dėl patogumo. # Naudojimo principas (pavadinimai be kabučių) rename(duomenų_lentele, naujasis_pavadinimas = senasis_pavadinimas) # Naudojimo principas (pavadinimai kabutėse) set_names(duomenų_lentele, c(&quot;kiekvienas&quot;, &quot;naujas&quot;, &quot;pavadinimas&quot;, &quot;atskirai&quot;)) Pavyzdžiai Pervardiname stulpelius Petal.Length į taurėlapio_ilgis bei Species į rūšis. colnames(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; iris_r1 &lt;- rename(iris, taurėlapio_ilgis = Petal.Length, rūšis = Species) colnames(iris_r1) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;taurėlapio_ilgis&quot; ## [4] &quot;Petal.Width&quot; &quot;rūšis&quot; Pakeičiame iš karto visus stulpelių pavadinimus. iris_r2 &lt;- set_names(iris, c(&quot;vainiklapio_ilgis&quot;, &quot;vainiklapio_plotis&quot;, &quot;taurelapio_ilgis&quot;, &quot;taurelapio_plotis&quot;, &quot;rūšis&quot;)) colnames(iris_r2) ## [1] &quot;vainiklapio_ilgis&quot; &quot;vainiklapio_plotis&quot; &quot;taurelapio_ilgis&quot; ## [4] &quot;taurelapio_plotis&quot; &quot;rūšis&quot; Užduotis 5.7 Visus šio skyriaus pavyzdžius perrašykite naudodami jungimo operatorių %&gt;%. Lentelė swiss. Kintamųjų pavadinimus sulietuvinkite. Naudokite funkciją rename(). Lentelė BOD. Kintamųjų pavadinimus sulietuvinkite. Naudokite funkciją set_names(). 5.5.2 Stulpelių pasirinkimas, pašalinimas ar perrikiavimas Funkcija select(), t. y. dplyr::select(), – stulpelių pasirinkimas, pašalinimas ar perrikiavimas. Kam to reikia? Duomenų lentelė pertvarkoma dėl patogumo arba Konkrečiam analizės metodui reikia, kad lentelėje būtų tik keli kintamieji išrikiuoti tam tikra tvarka. Pasirenkama nurodant pavadinimą be kabučių arba stulpelio eilės numerį (sveikąjį skaičių). # Naudojimo principas (pavadinimai be kabučių) select(duomenų_lentele, pasirinktas_stulpelis) select(duomenų_lentele, nuo:iki) Pašalinama pridedant minuso - ženklą prieš kiekvieną pašalinamą pavadinimą. # Naudojimo principas (pavadinimai be kabučių) select(duomenų_lentele, -pašalintas_stulpelis) select(duomenų_lentele, -(nuo:iki)) Perrikiuojama įrašius pirmųjų stulpelių pavadinimus ir pabaigoje parašius everything() (viskas, kas liko). # Naudojimo principas (pavadinimai be kabučių) select(duomenų_lentele, pirmasis, antrasis, everything()) Pavyzdžiai Pasirenkame stulpelius Petal.Length ir Species iris_s1 &lt;- select(iris, Petal.Length, Species) glimpse(iris_s1) ## Observations: 150 ## Variables: 2 ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5,... ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, s... Pasirenkame stulpelius nuo Petal.Length iki Species: iris_s2 &lt;- select(iris, Petal.Length:Species) glimpse(iris_s2) ## Observations: 150 ## Variables: 3 ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5,... ## $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1,... ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, s... Pašaliname stulpelius Petal.Length ir Species: iris_s3 &lt;- select(iris, -Petal.Length, -Species) glimpse(iris_s3) ## Observations: 150 ## Variables: 3 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,... ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1,... ## $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1,... Pašaliname stulpelius nuo Petal.Length iki Species: iris_s3 &lt;- select(iris, -(Petal.Length:Species)) glimpse(iris_s3) ## Observations: 150 ## Variables: 2 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,... ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1,... Pasirenkame paskutinį stulpelį: iris_s3 &lt;- select(iris, tidyselect::last_col()) glimpse(iris_s3) ## Observations: 150 ## Variables: 1 ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa... Užduotis 5.8 Visus šio skyriaus pavyzdžius perrašykite naudodami jungimo operatorių %&gt;%. Lentelė swiss. Naudodami funkciją summary() atlikite suvestinę stulpeliams nuo Examination iki Catholic. Lentelė OrchardSprays. Pašalinkite stulpelius rowpos ir colpos. Naudodami glimpse() įsitikinkite, kad stulpeliai pašalinti. 5.5.3 Pagalbinės funkcijos stulpelių pasirinkimui Su funkcija select() dažnai naudojamos pagalbinės funkcijos. Pradedantiesiems rekomenduoju žinoti starts_with(), ends_with(), contains() ir everything(). Visos likusios – vidutinio ar pažengusiųjų lygio funkcijos, tad apie jas galite neskaityti. starts_with() – pavadinimai, prasidedantys nurodyta fraze; ends_with() – pavadinimai, kurie baigiasi nurodyta fraze); contains() – pavadinimai, kuriuose yra nurodyta frazė; everything() visi likę prieš tai nepaminėti stulpeliai; last_col() arba tidyselect::last_col() paskutinis stulpelis (arba kažkuris stulpelis nuo galo, jei taip nurodoma skliaustuose). Norint naudoti šią funkciją, šiuo metu reikia papildomai užkrauti paketą tidyselect; one_of() – vienas iš pavadinimų, kurie nurodyti kaip tekstas (kabutėse); matches() – pavadinimai, kurie atitinka šabloną, vadinamą reguliariuoju reiškinių arba įprastoji išraiška, angl. regular extression; num_range() pavadinimai tam tikrame skaitmenų diapazone, pvz., x01, x02, x03; Daugiau informacijos ir pavyzdžių suvedus kodą ?tidyselect::select_helpers. Pavyzdžiai iris_s5 &lt;- select(iris, starts_with(&quot;sepal&quot;)) glimpse(iris_s5) ## Observations: 150 ## Variables: 2 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,... ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1,... iris_s6 &lt;- select(iris, ends_with(&quot;length&quot;)) glimpse(iris_s6) ## Observations: 150 ## Variables: 2 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,... ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5,... Užduotis 5.9 Visus šio skyriaus pavyzdžius perrašykite naudodami jungimo operatorių %&gt;%. Lentelė Ericksen iš paketo carData. Pasirinkite visus stulpelius, kurie baigiasi raide „e“ ir pagal juos nubraižykite sklaidos diagramą. 5.5.4 Stulpelių transformavimas, perskaičiavimas Jei reikia iš esamų stulpelių sukurti naujus arba esamus transformuoti – perskaičiuoti, pakeisti duomenų tipą, perkoduoti, kintamojo reikšmėms atlikti matematines transformacijas, gali būti naudojamos funkcijos: mutate(), t. y. dplyr::mutate(), – prideda naujus stulpelius, senuosius palieka; transmute(), t. y. dplyr::transmute(), – palieka tik naujuosius stulpelius, o visus kitus – pašalina (tai mutate() ir select() funkcijų hibridas). Kam to reikia? Tai pati svarbiausia funkcija dirbant su kintamųjų reikšmėmis, nes įprastai nuskaitytus duomenis reikia pasiversti į reikiamą tipą, apskaičiuoti skirtumus tarp stulpelių, logaritmuoti. Tam naudosime funkciją mutate(). # Naudojimo principas (pavadinimai be kabučių) mutate(duomenų_lentele, naujasis_pavadinimas_1 = kokia_nors_funkcija(senasis_pavadinimas_1), naujasis_pavadinimas_2 = kokia_nors_kita_funkcija(senasis_pavadinimas_2) ) Kartu su mutate() naudoti naudingos funkcijos iš skyriaus 1.2.8 „R kaip kalkuliatorius: operatoriai ir komandos“. Pavyzdžiai Apskaičiuokime naują kintamąjį bendras_ilgis: iris_m1 &lt;- mutate(iris, bendras_ilgis = Sepal.Length + Petal.Width) glimpse(iris_m1) ## Observations: 150 ## Variables: 6 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9... ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1... ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5... ## $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1... ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, ... ## $ bendras_ilgis &lt;dbl&gt; 5.3, 5.1, 4.9, 4.8, 5.2, 5.8, 4.9, 5.2, 4.6, 5.0... Rezultatas naudojant transmute() – mažesnė duomenų lentelė: iris_m1 &lt;- transmute(iris, bendras_ilgis = Sepal.Length + Petal.Width) glimpse(iris_m1) ## Observations: 150 ## Variables: 1 ## $ bendras_ilgis &lt;dbl&gt; 5.3, 5.1, 4.9, 4.8, 5.2, 5.8, 4.9, 5.2, 4.6, 5.0... Apskaičiuokime dar 3 naujus kintamuosius. Atkreipkite dėmesį, kad skaičiavimuose galima naudoti jau sukurtus kintamuosius (pvz., log_ilgis): iris_m2 &lt;- mutate(iris, ilgis_kvadratu = Sepal.Length ^ 2, log_ilgis = log(ilgis_kvadratu), kažkoks_neaiškus_indeksas = pi * (sqrt(Sepal.Length) + 1/log_ilgis) - mean(log_ilgis)) glimpse(iris_m2) ## Observations: 150 ## Variables: 8 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5... ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3... ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1... ## $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0... ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, seto... ## $ ilgis_kvadratu &lt;dbl&gt; 26.01, 24.01, 22.09, 21.16, 25.00, 2... ## $ log_ilgis &lt;dbl&gt; 3.258481, 3.178470, 3.095125, 3.0521... ## $ kažkoks_neaiškus_indeksas &lt;dbl&gt; 4.548057, 4.431824, 4.315038, 4.2564... Užduotis 5.10 Visus šio skyriaus pavyzdžius perrašykite naudodami jungimo operatorių %&gt;%. Lentelė women: svorį svarais paverskite į svorį kilogramais. Perskaičiuotų kintamųjų pavadinimo pabaigoje turi būti parašyta „_kg“; grafiškai atvaizduokite ūgio ir svorio santykio pasiskirstymą. Lentelė chickwts: Logaritmuokite kintamojo weight reikšmes, sukurdami naują kintamąjį log_weight. Grafiškai palyginkite, kas atsitiko su pasiskirstymo simetrija. 5.5.5 Kintamojo klasės keitimas Kai reikia pakeisti kintamojo klasę, kartu su mutate() funkcija gali būti naudojamos šio bazinės R sistemos funkcijos (vietoje taško reikia įrašyti kintamojo pavadinimą): factor(.) ordered(.) as.factor(.) as.ordered(.) as.numeric(.) as.integer(.) as.character(.) as.logical(.) Sistemoje tidyverse taip pat yra šiam tikslui skirtų funkcijų. Tačiau pradedantiesiems pakaks ir bazinių. Pavyzdžiai data(birthwt, package = &quot;MASS&quot;) birthwt2 &lt;- select(birthwt, low, ui) glimpse(birthwt2) ## Observations: 189 ## Variables: 2 ## $ low &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0... ## $ ui &lt;int&gt; 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0... birthwt3 &lt;- birthwt2 %&gt;% mutate(low = as.factor(low), urine_irritability = as.factor(ui)) glimpse(birthwt3) ## Observations: 189 ## Variables: 3 ## $ low &lt;fct&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0... ## $ ui &lt;int&gt; 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0... ## $ urine_irritability &lt;fct&gt; 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0... Jei reikia ne tik pakeisti klasę, bet ir perkoduoti reikšmes, apie tais skaitykite kitame skyriuje. Užduotis 5.11 Duomenų lentelė birthwt. Visus kintamuosius, kurie iš tiesų turėtų būti kategoriniai, paverskite į faktorius. Naują duomenų lentelę pasivadinkite birthwt_3. 5.5.6 Kintamojo reikšmių perkodavimas Kai reikia perkoduoti kintamojo reikšmes, kartu su mutate() naudojamos funkcijos: recode() – duomenis paverčia į skaitinius arba tekstinius kintamuosius; recode_factor() – duomenis paverčia į nominaliuosius arba ranginius faktorius. dplyr::recode(., ...) dplyr::recode_factor(., ...) dplyr::recode_factor(., ..., .ordered = TRUE) Čia vietoje taško rašomas kintamojo (duomenų eilutės) pavadinimas, vietoje … – perkodavimo nurodymai tokiu formatu: &quot;senoji_reikšmė&quot; = &quot;naujoji_reikšmė&quot;, &quot;senoji_2&quot; = &quot;naujoji_2&quot;; jei rezultatas (dešinioji pusė) turi būti skaičius, jis rašomas be kabučių; kitais atvejais kabutes rekomenduoju naudoti. Pavyzdžiai su duomenų eilutėmis Duomenų eilutė „x“: x &lt;- c(1:4, NA) x ## [1] 1 2 3 4 NA Skaičiai perkoduojami į raides: recode_factor(x, `1` = &quot;z&quot;, `2` = &quot;y&quot;, `3` = &quot;x&quot;) ## Warning: Unreplaced values treated as NA as .x is not compatible. Please ## specify replacements exhaustively or supply .default ## [1] z y x &lt;NA&gt; &lt;NA&gt; ## Levels: z y x Visos likusios netrūkstamos kategorijos perkoduojamos naudojant argumentą .default: recode_factor(x, `1` = &quot;z&quot;, `2` = &quot;y&quot;, .default = &quot;D&quot;) ## [1] z y D D &lt;NA&gt; ## Levels: z y D Trūkstamoms reikšmėms taip pat gali būti sukurta atskira kategorija naudojant argumentą .missing: recode_factor(x, `1` = &quot;z&quot;, `2` = &quot;y&quot;, .default = &quot;D&quot;, .missing = &quot;M&quot;) ## [1] z y D D M ## Levels: z y D M Ranginiai kintamieji sukuriami naudojant argumentą .ordered: recode_factor(x, `1` = &quot;z&quot;, `2` = &quot;y&quot;, .default = &quot;D&quot;, .missing = &quot;M&quot;, .ordered = TRUE) ## [1] z y D D M ## Levels: z &lt; y &lt; D &lt; M Užduotis 5.12 Duota duomenų eilutė „u“. set.seed(30); u &lt;- sample(letters[1:5], size = 100, replace = TRUE); Jos patyrinėjimui naudinga funkcija table(), kuri sudaro dažnių lentelę. Mažąsias raides „a&quot; ir „c“ perkoduokite į didžiąsias, visas likusias (.default) pavadinkite „Kita“; Rezultatą (duomenų eilutę) pavadinkite „u_modif“; Ar jus nustebino funkcijos table(u, u_modif) (porinė dažnių lentelė) rezultatas? Pavyzdžiai su duomenų lentelėmis data(birthwt, package = &quot;MASS&quot;) summary(birthwt$race) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.000 1.000 1.000 1.847 3.000 3.000 birthwt_4 &lt;- birthwt %&gt;% mutate(race = recode_factor(race, &quot;1&quot; = &quot;white&quot;, &quot;2&quot; = &quot;black&quot;, &quot;3&quot; = &quot;ohter&quot;)) glimpse(birthwt_4) ## Observations: 189 ## Variables: 10 ## $ low &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,... ## $ age &lt;int&gt; 19, 33, 20, 21, 18, 21, 22, 17, 29, 26, 19, 19, 22, 30, ... ## $ lwt &lt;int&gt; 182, 155, 105, 108, 107, 124, 118, 103, 123, 113, 95, 15... ## $ race &lt;fct&gt; black, ohter, white, white, white, ohter, white, ohter, ... ## $ smoke &lt;int&gt; 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0,... ## $ ptl &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,... ## $ ht &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,... ## $ ui &lt;int&gt; 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,... ## $ ftv &lt;int&gt; 0, 3, 1, 2, 0, 0, 1, 1, 1, 0, 0, 1, 0, 2, 0, 0, 0, 3, 0,... ## $ bwt &lt;int&gt; 2523, 2551, 2557, 2594, 2600, 2622, 2637, 2637, 2663, 26... class(birthwt_4$race) ## [1] &quot;factor&quot; summary(birthwt_4$race) ## white black ohter ## 96 26 67 Užduotis 5.13 Duomenų lentelė birthwt. Visus kintamuosius, kurie iš tiesų turėtų būti kategoriniai, perkoduokite ir paverskite į faktorius: Naują duomenų lentelę pasivadinkite birthwt_5. Kategorijų pavadinimai turi būti prasmingi žodžiai. Kas atsitinka, jei pakeičiame perkoduojamų kategorijų eilės tvarką (tarkim, pirma perkoduojame rasę „2“, po to „3“, po to „1“)? Patikrinkite naudodami summary(). 5.5.7 Kintamojo reikšmių kategorizavimas Kartais skaitinio kintamojo reikšmes, pvz., amžių, reikia suskirstyti į kategorijas „jaunas“, „vidutinio amžiaus“, „pagyvenęs“. Tam naudinga funkcija cut(). set.seed(654852) amžius &lt;- sample(1:80, size = 100, replace = TRUE) summary(amžius) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 23.50 40.50 41.22 61.50 80.00 Funkcijoje nurodomos ribos, kaip „supjaustyti“ kintamojo reikšmes. Kiekvienam pogrupiui galime suteikti pavadinimus. amžiaus_gr &lt;- cut(amžius, c(0, 30, 60, 100), labels = c(&quot;jaunas&quot;, &quot;vidutinio amžiaus&quot;, &quot;pagyvenęs&quot;)) summary(amžiaus_gr) ## jaunas vidutinio amžiaus pagyvenęs ## 35 38 27 Funkcija cut() gali būti naudojama funkcijos mutate() skliaustuose. Užduotis 5.14 Duomenų lentelė birthwt ir paketo MASS. Kūdikių svorį suskirstykite į 5 kategorijas kas 1 kilogramą: Grupėms pavadinimų nesuteikite ir pažiūrėkite, kaip jas pavadino programa R; Grupėms suteikite žodinius pavadinimus. Patys sugalvokite tinkamus. 5.6 Lentelės formos keitimas Jei duomenų lentelės yra netvarkingos (prisiminkite tvarkingų lentelių savybes), naudingos paketo tidyr funkcijos, keičiančios lentelių formą. Pagrindinės funkcijos: tidyr::gather() tidyr::spread() tidyr::separate() tidyr::unite() Plačiau apie funkcijas rašoma jų dokumentacijoje. Visgi panagrinėkime, kelias situacijas, kada šios funkcijos tinka: Kai stulpelių pavadinimai iš tiesų yra kintamojo reikšmės, jas perkeliame į atskirą stulpelį (vadinamasis raktų stulpelis), greta parašome reikšmes (gauname 2 stulpelius). Iš plačiojo formato lentelės verčiame į ilgojo: data(&quot;table4a&quot;) table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 gather(table4a, &quot;1999&quot;, &quot;2000&quot;, key = &quot;metai&quot;, value = &quot;populiacija&quot;) ## # A tibble: 6 x 3 ## country metai populiacija ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Brazil 1999 37737 ## 3 China 1999 212258 ## 4 Afghanistan 2000 2666 ## 5 Brazil 2000 80488 ## 6 China 2000 213766 Kai vieno stebėjimo reikšmės (pvz., šalies konkrečiais metais) yra keliose eilutėse, t. y., viename stulpelyje yra kelios savybės, jas reikia parašyti vienoje eilutėje bet keliuose stulpeliuose. Raktų stulpelio eilutėse esančios reikšmės verčiamos stulpelių pavadinimais. Iš ilgojo formato verčiame į platųjį: data(&quot;table2&quot;, package = &quot;tidyr&quot;) table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 spread(table2, key = type, value = count) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Kai viename stulpelyje yra kelios reikšmės, jas reikia atskirti į atskirus stulpelius: data(&quot;table3&quot;, package = &quot;tidyr&quot;) table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 separate(table3, col = rate, into = c(&quot;atvejai&quot;, &quot;populiacija&quot;), sep = &quot;/&quot;, convert = TRUE) ## # A tibble: 6 x 4 ## country year atvejai populiacija ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Ir atvirkščiai, kai vieno kintamojo reikšmės yra keliuose stulpeliuose – jas sujungiame: data(&quot;table5&quot;, package = &quot;tidyr&quot;) table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 unite(table5, century, year, col = &quot;metai&quot;, sep = &quot;&quot;) ## # A tibble: 6 x 3 ## country metai rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Biologiniams duomenims dažniausiai reikalinga funkcija yra gather(). Tad tai, ką ji daro, reikia labai gerai suprasti. Užduotis 5.15 Užsikraukite lentelę anorexia iš paketo MASS. Ką reikia padaryti, kad greta galėtume nusibraižyti pacientų svorio pasiskirstymą prieš gydymą ir po jo? Grafike kiekvienam gydymo metodui turėtų būti suteikta atskira facetė. Preliminariai grafiškai įvertinkite, kuris gydymas buvo efektyviausias. Parsisiųskite ir užsikraukite duomenis (nuoroda r icon::fa(&quot;external-link-alt&quot;)). Identifikuokite problemą, dėl kurios lentelė nėra tvarkinga, ir ją išspręskite. 5.7 Kelių duomenų lentelių sujungimas 5.7.1 Eilučių prijungimas dplyr::bind_rows() Plačiau apie funkciją – dokumentacijoje. Užduotis 5.16 Iš dokumentacijos išmėginkite po kelis pavyzdžius. Kam reikalingas argumentas .id? 5.7.2 Stulpelių prijungimas dplyr::bind_cols() Plačiau apie funkciją – dokumentacijoje. Užduotis 5.17 Iš dokumentacijos išmėginkite po kelis pirmus pavyzdžius. 5.7.3 Lentelių sujungimas pagal stebėjimo ID ar pavadinimą dplyr::full_join() dplyr::left_join() Yra ir daugiau *_join() šeimos funkcijų. Apie tai – dokumentacijoje. Užduotis 5.18 Dokumentacijoje susiraskite kiekvienos funkcijos aprašymą (skyrius „Join types“). Po to išmėginkite po kelis pirmus pavyzdžius abiem funkcijoms. Rezultatą peržiūrėkite naudodami funkciją View(). Ar supratote, ką kiekviena funkcija padarė? Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["ataskaitos.html", "6. Ataskaitų rengimas 6.1 „R Markdown“ dokumentai 6.2 Užrašų knygutės režimas 6.3 TeX / LaTeX lygtys 6.4 Lygtys grafikų antraštėse", " 6. Ataskaitų rengimas 6.1 „R Markdown“ dokumentai Patogus ir ganėtinai paprastas būdas kurti R analizės ataskaitas – naudoti R papildinį R Markdown. R Markdown yra įrankis, kurio galimybės neapsiriboja vien ataskaitų kūrimu – juo galima sudaryti daugelio kitų tipų dokumentus: internetines svetaines, straipsnius, knygas. Mokslines publikacijas spausdinančios organizacijos, tokios kaip „American Chemical Society“ bei „Elsevier“ turi specialiai jų straipsniams skirtus R Markdown šablonus. Naudodami R Markdown taip pat galite rašyti ir savo kursinį ar baigiamąjį darbą. Papildinys turi jam skirtą tinklapį (http://rmarkdown.rstudio.com), kuriame pateikiama mokomoji medžiaga bei gausybė R Markdown dokumentų pavyzdžių. Užduotis 6.1 Pažiūrėkite trumpą pažintinį filmuką, esantį šiame tinklapyje: http://rmarkdown.rstudio.com/lesson-1.html 6.1.1 R Markdown dokumento atidarymas Vienas iš būdų atidaryti naują R Markdown dokumentą – naudotis RStudio meniu: RStudio meniu → File → New file → R Markdown… Pastaba: „File“ meniu (kuris yra viršuje kairėje) nemaišykite su „Files“ langu. Kitas būdas parodytas pav. 6.1. Pav. 6.1: R Markdown dokumento atvėrimas. 6.1.2 R Markdown dokumento struktūra R Markdown dokumentus sudaro 3 pagrindinės dalys (pav. 6.2): Antraštė su technine informacija YAML formatu; Tekstas, parašytas natūralia žmonių kalba, pvz., lietuviškai, su R Markdown elementais; R programos kodo blokai, kuriuose vykdoma analizė. Pav. 6.2: Pagrindinės R Markdown dokumento dalys. Pavyzdyje rodoma dokumento versija, atidaryta per RStudio. Parsisiųskite R Markdown atmintinę (nuoroda ) ir išnagrinėkite virš lentelių esančią medžiagą „.Rmd files“, „Reproducible Research“ ir „Dynamic Documents“ bei schemas-lenteles „.Rmd structure“ bei „Workflow“. R Markdown dokumentai – tai tekstinės bylos, kurių įprastinis plėtinys yra .Rmd arba .rmd. 6.1.3 Ataskaitų generavimas Ataskaitos sugeneruojamos paspaudus „Knit“ mygtuką. Paspaudę trikampėlį prie šio mygtuko (pav. 6.3) galime pasirinkti vieną iš kelių dažniausiai naudojamų ataskaitos formatų. Tinklapio (HTML) formatui jokių papildomų priedų nereikia. Word formatui reikia programos Pandoc, kuri yra įdiegiama su RStudio. PDF formatui reikia Pandoc ir LaTeX (skaitoma la-tek) sistemos, kuri turėtų būti įdiegta atskirai (mūsų pratyboms ji nėra reikalinga). Pav. 6.3: R Markdown dokumento (kairėje) ir juo sugeneruotos HTML formato ataskaitos (dešinėje) pavyzdys. Paspaudę „Knit“ mygtuką sugeneruosite ataskaitą, kuri atsiras arba „Viewer“, arba atskirame lange. Vėliau paspaudę „Open in Browser“ mygtuką, galėsite ataskaitą persikelti į interneto naršyklės langą. Paspaudę trikampį šalia „Knit“ mygtuko, galėsite pasirinkti vieną ir dažniausiai naudojamų ataskaitos formatų. Eilutės Nr. 14 pabaigoje padėti 4 tarpai (kiekvienas vos įžiūrimas taškiukas simbolizuoja tarpą). Dėl jų – ketvirtasis sakinys yra naujoje pastraipoje. 6.1.4 R Markdown sintaksė Programavimo kalbos sintaksė – tai tam tikros taisyklės ir reikalavimai, kuriuos turi tenkinti ta kalba. R Markdown sintaksę sudaro specialieji simboliai, rašomi „žmonių kalbai“ skirtoje dokumento dalyje. Sugeneravus ataskaitą, joje interpretuojami kaip tam tikras formatavimo būdas (pajuodintas tekstas, pasviręs tekstas, antraštė, nuoroda, sąrašas, lentelė ir t.t. Pvz., pav. 6.3). Tam, kad geriau suprastumėte, kas tie specialieji simboliai ir kaip jie vartojami bei interpretuojami, parsisiųskite R Markdown sintaksės gidą (nuoroda ) ir išnagrinėkite medžiagą, esančią 1 puslapyje ir 2 puslapio pradžioje (iki „Chunk Options“). Be abejo verta paminėti, kad RStudio pagalbos sistemoje („Help“ kortelėje, pav. 6.4) pateikti svarbiausi R Markdown raktažodžiai. Pav. 6.4: Pagrindinius R Markdown sintaksės elementus galite rasti naudodamiesi RStudio: meniu juostoje pasirinkę „Help“ –&gt; „Markdown Quick Reference“. „Help“ lange paspaudę raudonai pažymėtą ikoną pasididinsite aprašymo langą. Atkreipsiu dėmesį tik į keletą neakivaizdžių dalykų: Jei norite, kad tekstas ataskaitoje būtų parašytas iš naujos eilutės, eilutės pabaigoje turėtumėte padėti bent 2 tarpus. Kitu atveju net iš naujos eilutės parašytas tekstas bus interpretuojamas kaip ta pati pastraipa. Prieš naują antraštės pavadinimą, kuris prasideda eilutės pradžioje be tarpo padėjus grotelių (#) simbolį, palikite tuščią eilutę. Analogiškai, prieš naują sąrašą, brūkšnį (***) ir daugelį kitų iš naujos eilutės rašomų raktažodžių reikia palikti tuščią eilutę. Ir į vieną akivaizdų: Vaizdumo dėlei programa RStudio raktažodžiais pažymėtas dokumento vietas (įprastai) nudažo kita spalva (pvz., pav. 6.2). Plačiau apie R Markdown dokumentus skaitykite tinklapyje: https://rmarkdown.rstudio.com/ 6.1.5 Paketas addins.rmd ir RStudio įskiepiai RStudio galimybes galima praplėsti papildiniais, vadinamais įskiepiais (angl. add-ins). Pakete addins.rmd yra įskiepių, skirtų mokytis R Markdown sintaksę. Paketą, turintį įskiepių, tereikia reikia įsidiegti, bet užkrauti nebūtina. Įdiegus, RStudio „Addins“ meniu atsiranda reikiami įskiepiai (pav. 6.5). Pav. 6.5: RStudio įskiepiai iš paketo addins.rmd. Jei įdiegtas reikiamas paketas, įskiepiai pasiekiami per „Addins“ meniu. Kiekvienam iš įskiepų galima sukurti greitųjų klavišų kombinaciją. Tai, kaip atidaryti reikiamą meniu, parodyta pav. 6.6. Pav. 6.6: Greitųjų RStudio klavišų nustatymo/keitimo meniu atidarymas. Užduotis 6.2 Įskiepiui pavadinimu „Rmd: Code block: R code“ sukurkite greitųjų klavišų kombinaciją Ctrl+Alt+Shift+E. Patikrinkite, ar ji veikia. Toliau bus pateikiama pavyzdžių, kaip naudoti addins.rmd paketo įskiepius (pav. 6.7, 6.8, 6.9, 6.10) Pav. 6.7: Pavyzdys, kaip naudoti paketo addins.rmd RStudio įskiepius. Teksto formatavimas R Markdown sintaksės elementais. Pav. 6.8: Paketo addins.rmd RStudio įskiepiai, skirti sukurti antraščių pavadinimus (pirmasis būdas). Pav. 6.9: Paketo addins.rmd RStudio įskiepiai, skirti sukurti antraščių pavadinimus (antrasis būdas). Pav. 6.10: Paketo addins.rmd RStudio įskiepiai sąrašams sudaryti. Iš pradžių sukuriamas pirmo lygio sąrašas, po to – antro. Pirmo sąrašo lygio elementai pavyzdyje ženklinami skaičiais, antro lygio – mažosiomis raidėmis. Virš daugelio R Markdown elementų, tokių kaip sąrašai, antraštės, lentelės, būtina palikti vieną tuščią eilutę. Paketo addins.rmd RStudio įskiepiai įprastai tai padaro. Paketo addins.rmd įskiepiai, kurių pavadinime parašyta „(example)“ tiesiog įterpia tam tikro elemento (pvz., lentelės) pavyzdį, bet realaus teksto formatavimo neatlieka. 6.1.6 Programos kodo blokai Programos kodas turi būti rašomas specialiuose blokuose (angl. chunks) kurie įterpiami paspaudus Ctrl + Alt + I arba „Insert“ mygtuką ir pasirinkus „R“ bloką. Rašant programos kodą galioja ta pati seka, aprašyta 5.1.3 skyriuje: Analizės kodo dalys eilės tvarka: Paketų užkrovimas; Nustatymai; Duomenų įkėlimas; Visa kita. 6.1.7 Funkcija pander Funkcija pander() yra paketo pander dalis. Ji skirta gražesniam rezultatų pateikimui ataskaitose. Funkcijai skirtas tinklapis http://rapporter.github.io/pander/ library(pander) # funkcijai pander library(magrittr) # operatoriui %&gt;% Daugumą statistinės analizės funkcijų rezultatų galima atspausdinti naudojant komandą pander ir taip gauti gražiau suformatuotas lenteles. Palyginkime įprastu būdu atspausdintus rezultatus: summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## …su rezultatais, atspausdintais naudojant pander: summary(iris) %&gt;% pander() Sepal.Length Sepal.Width Petal.Length Petal.Width Species Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 setosa :50 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 versicolor:50 Median :5.800 Median :3.000 Median :4.350 Median :1.300 virginica :50 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 NA 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 NA Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 NA Skirtumas akivaizdus. Toliau pateikdami papildomą parametrą missing = &quot;&quot;, langelius su įrašu NA galime pasikeisti į tuščias eilutes: summary(iris) %&gt;% pander(missing = &quot;&quot;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 setosa :50 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 versicolor:50 Median :5.800 Median :3.000 Median :4.350 Median :1.300 virginica :50 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 Arba tiesiog koreguokime bendruosius paketo pander nustatymus, kad visose funkcija pander() atspausdintose lentelėse langeliai su įrašu NA būtų keičiami į tuščias eilutes: panderOptions(&quot;missing&quot;, &quot;&quot;) Įdėkime lentelės aprašymą (angl. caption): summary(iris) %&gt;% pander(caption = &quot;Duomenų lentelės „iris“ suvestinė, atspausdinta naudojant „pander“.&quot;) Duomenų lentelės „iris“ suvestinė, atspausdinta naudojant „pander“. Sepal.Length Sepal.Width Petal.Length Petal.Width Species Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 setosa :50 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 versicolor:50 Median :5.800 Median :3.000 Median :4.350 Median :1.300 virginica :50 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 summary(iris) %&gt;% pander(caption = &quot;Duomenų lentelės „iris“ suvestinė, atspausdinta naudojant „pander“.&quot;) Duomenų lentelės „iris“ suvestinė, atspausdinta naudojant „pander“. Sepal.Length Sepal.Width Petal.Length Petal.Width Species Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 setosa :50 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 versicolor:50 Median :5.800 Median :3.000 Median :4.350 Median :1.300 virginica :50 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 Užduotis 6.3 Naudodami funkciją pander atspausdinkite duomenų lentelę BOD. Naudodami funkcijas pander ir tail atspausdinkite 4 paskutines duomenų lentelės iris eilutes. Naudodami funkciją table sudarykite kintamųjų N ir P iš duomenų rinkinio npk porinę dažnių lentelę. Ją atspausdinkite naudodami funkciją pander. Atspausdintos lentelės aprašymas turėtų būti „Porinė dažnių lentelė“. 6.2 Užrašų knygutės režimas Pamoka apie R užrašų knygutės režimu („R Notebooks“): https://rmarkdown.rstudio.com/r_notebooks.html 6.3 TeX / LaTeX lygtys Rašant mokslinius dokumentus neretai reikalingos lygtys. Paprasčiausias pavyzdys – kai reikia užrašyti kvadratinius centimetrus (\\(cm^2\\)). Tam pravarti TeX / LaTeX lygčių rašymo sistema, kuri yra integruota į RStudio R Markdown („.Rmd“) dokumentus. LaTeX lygtys R Markdown byloje rašomos tarp viengubų dolerio ($ $) ar dvigubų dolerio ($$ $$) ženklų. Pavyzdžiui užrašas $y = 2 \\times \\alpha^2$ virs \\(y = 2 \\times \\alpha^2\\), o analogiškas užrašas tarp dvigubų dolerio ženklų bus parašytas atskiroje eilutėje: \\[y = 2 \\times \\alpha^2\\] Užduotis 6.4 Prieš skaitydami toliau, atsidarykite R Markdown bylą programoje RStudio ir išbandykite aukščiau pateiktus pavyzdžius. 6.3.1 LaTeX lygtys R Markdown bylose Rašant LaTeX lygtis verta prisiminti: $ – lygties (esančios eilutėje su tekstu) pradžios ir pabaigos simbolis; $$ – lygties (esančios atskiroje eilutėje) pradžios ir pabaigos simbolis; Simbolis _ – apatinio indekso pradžia; Simbolis ^ – viršutinio indekso pradžia; Simboliai {} – grupavimo operatorius; Simbolis \\ – LaTeX raktažodžio pradžia. Svarbiausi šiam kursui lygčių rašymo raktažodžiai pateikiami 6.1 lentelėje, kiti naudingi raktažodžiai 6.2, 6.3 , 6.4 ir 6.5 lentelėse. Lentelė 6.1: Biostatistikos kursui svarbiausios TeX / LaTeX lygčių rašymo komandos. Pavadinimas Simbolis ar raktažodis Pavyzdys Rezultatas Viršutinis indeksas (vienam simboliui) ^ x^2 \\(x^2\\) Apatinis indeksas (vienam simboliui) _ x_2 \\(x_2\\) Viršutinis indeksas (simbolių grupei) ^{ } x^{222} \\(x^{222}\\) Apatinis indeksas (simbolių grupei) _{ } x_{222} \\(x_{222}\\) Trupmena \\frac{}{} \\frac{skaitiklis}{vardiklis} \\(\\frac{skaitiklis}{vardiklis}\\) Daugybos ženklas \\times U = \\alpha \\times A \\(U = \\alpha \\times A\\) Procentai \\% 10\\% \\(10\\%\\) Brūkšnelis virš simbolio \\bar{} \\bar{x}, \\bar{A} \\(\\bar{x}, \\bar{A}\\) Didžiosios lotyniškos raidės \\Sigma, \\Delta \\Sigma + \\Delta ^ \\Theta \\(\\Sigma + \\Delta ^ \\Theta\\) Mažosios lotyniškos raidės \\alpha, \\beta, \\sigma, \\mu, \\lambda \\alpha \\beta - \\sigma^2 \\mu \\(\\alpha \\beta - \\sigma^2\\mu\\) Įprasti skliausteliai ( ) ( \\frac{A}{X} )^3 \\(( \\frac{A}{X} )^3\\) Dideli skliausteliai \\left( \\right) \\left( \\frac{A}{X} \\right)^3 \\(\\left( \\frac{A}{X} \\right)^3\\) \\left[ \\right] \\left[ \\frac{A}{X} \\right]^3 \\(\\left[ \\frac{A}{X} \\right]^3\\) \\left&lt; \\right&gt; \\left&lt; \\frac{A}{X} \\right&gt;^3 \\(\\left&lt; \\frac{A}{X} \\right&gt;^3\\) Tarpas ~ a b~c~~d \\(a b~c~~d\\) LaTeX kalboje simboliai # $ % ^ &amp; _ { } ~ \\ yra specialieji (atlieka tam tikrus veiksmus, keli pavyzdžiai 6.1 lentelėje). Norint juos atvaizduoti lygtyje, kai kuriais (bet ne visais) atvejais prieš šiuos simbolius užtenka padėti atgal pasvirusį brūkšnį (pvz., užrašas \\% bus atvaizduotas kaip \\(\\%\\), \\$ kaip \\(\\$\\), o \\_ kaip \\(\\_\\)). Užduotis 6.5 R Markdown dokumente („.Rmd“), atidarytame per RStudio, užrašykite visas LaTeX lygtis, pateiktas 6.1 lentelės stulpelyje „Pavyzdys“. Tam lygtis tereikia įterpti tarp dvigubų dolerio simbolių \\(\\$\\$...\\$\\$\\) (vietoje daugtaškio) „žmonių kalbai“ skirtoje R Markdown dokumento dalyje; R Markdown dokumente („.Rmd“) užrašykite šias LaTeX lygtis: \\(f = 40\\%\\) \\(A^{2x}_{CD}\\) \\(c = \\frac{A}{B}\\) \\(\\frac{x^2}{y^3}\\) \\(\\mu = \\bar{A} \\times \\Theta^\\alpha\\) \\(\\left( \\frac{x^2}{y^3} + \\mu \\right)_{pirmasis}\\) \\(\\left( \\frac{X}{Y} \\right)^2\\) \\(\\lambda = \\alpha \\frac{\\beta \\sigma^2}{\\mu}\\) Lentelė 6.2: Įvairūs TeX / LaTeX lygčių raktažodžiai, interpretuojami kaip simboliai. Simbolis Raktažodis Pavyzdys Rezultatas Daugybos ženklas \\(\\times\\) \\times X \\times a \\(X \\times z\\) Procentai \\(\\%\\) \\% 10\\% \\(10\\%\\) Simbolis apytiksliai \\(\\approx\\) \\approx X \\approx a \\(X \\approx a\\) Bangelė \\(\\sim\\) \\sim X \\sim a \\(X \\sim a\\) Laipsnių ženklas \\(^\\circ\\) ^\\circ 10^\\circ \\(10^\\circ\\) Daugiau lygu \\(\\geq\\) \\geq X \\geq a \\(X \\geq a\\) Mažiau lygu \\(\\leq\\) \\leq X \\leq a \\(X \\leq a\\) Nelygu \\(\\neq\\) \\neq X \\neq a \\(X \\neq a\\) Dalinės išvestinės ženklas \\(\\partial\\) \\partial \\partial X \\(\\partial X\\) Plius minus \\(\\pm\\) \\pm \\pm a \\(\\pm a\\) Minus plius \\(\\mp\\) \\mp \\mp a \\(\\mp a\\) Begalybė \\(\\infty\\) \\infty \\infty \\(\\infty\\) Rodyklė į kairę \\(\\leftarrow\\) \\leftarrow X \\leftarrow a \\(X \\leftarrow a\\) Rodyklė į dešinę \\(\\rightarrow\\) \\rightarrow X \\rightarrow 0 \\(X \\rightarrow 0\\) Rodyklė į dešinę \\(\\to\\) \\to X \\to \\infty \\(X \\to \\infty\\) Tarpas ~ \\, \\; \\ a b~c\\ d\\,e\\;f~~g \\(a b~c\\ d\\,e\\;f~~g\\) Nauja eilutė \\\\ a \\\\ d (nerodoma) Lentelė 6.3: TeX / LaTeX raktažodžiai matematiniam šriftui užrašyti. Pavadinimas Raktažodis Pavyzdys Rezultatas Matematinis šriftas \\mathcal{} \\mathcal{R} \\(\\mathcal{R}\\) \\mathcal{N}(\\mu,\\sigma^2) \\(\\mathcal{N}(\\mu,\\sigma^2)\\) \\mathcal{P}(\\lambda) \\(\\mathcal{P}(\\lambda)\\) \\mathcal{B}(n, p) \\(\\mathcal{B}(n, p)\\) Lentelė 6.4: Įvairios TeX / LaTeX komandos sudėtingesniems matematiniams veiksmams užrašyti. Pavadinimas Raktažodis Pavyzdys Rezultatas Šaknis \\sqrt[]{} \\sqrt[n]{x} \\(\\sqrt[n]{x}\\) \\sqrt{} \\sqrt{x} \\(\\sqrt{x}\\) Suma \\sum_{}^{} \\sum_{A}^{B} C_i \\(\\sum_{A}^{B}C_i\\) \\sum_{A} \\(\\sum_{A}\\) \\sum^{B} \\(\\sum^{B}\\) \\sum C_i \\(\\sum C_i\\) Suma (patobulintai) \\sum \\limits_{}^{} \\sum \\limits_{A}^{B} C_i \\(\\sum \\limits_{A}^{B} C_i\\) Sandauga \\prod_{}^{} \\prod_{A}^{B} C_i \\(\\prod_{A}^{B}C_i\\) Sandauga (patobulintai) \\prod \\limits_{}^{} \\prod \\limits_{A}^{B} C_i \\(\\prod \\limits_{A}^{B} C_i\\) Integralas \\int_{}^{} \\int_{A}^{B} dx \\(\\int_{A}^{B} dx\\) Integralas (patobulintai) \\int \\limits_{}^{} \\int \\limits_{A}^{B} dx \\(\\int \\limits_{A}^{B} dx\\) Ribos \\lim_{} \\lim_{A} \\(\\lim_{A}\\) \\lim_{i \\to \\infty} x_i \\(\\lim_{i \\to \\infty} x_i\\) Ribos (patobulinta) \\lim \\limits_{} \\lim \\limits_{i \\to \\infty} x_i \\(\\lim\\limits_{i \\to \\infty} x_i\\) Lentelė 6.5: TeX / LaTeX raktažodžiai („kodai“) graikiškoms raidėms užrašyti. Simbolis Kodas Simbolis Kodas Simbolis Kodas Simbolis Kodas \\(\\alpha\\) \\alpha \\(\\theta\\) \\theta \\(\\pi\\) \\pi \\(\\phi\\) \\phi \\(\\beta\\) \\beta \\(\\vartheta\\) \\vartheta \\(\\Pi\\) \\Pi \\(\\varphi\\) \\varphi \\(\\gamma\\) \\gamma \\(\\Theta\\) \\Theta \\(\\rho\\) \\rho \\(\\Phi\\) \\Phi \\(\\Gamma\\) \\Gamma \\(\\kappa\\) \\kappa \\(\\varrho\\) \\varrho \\(\\chi\\) \\chi \\(\\delta\\) \\delta \\(\\lambda\\) \\lambda \\(\\sigma\\) \\sigma \\(\\psi\\) \\psi \\(\\Delta\\) \\Delta \\(\\Lambda\\) \\Lambda \\(\\Sigma\\) \\Sigma \\(\\Psi\\) \\Psi \\(\\epsilon\\) \\epsilon \\(\\mu\\) \\mu \\(\\iota\\) \\iota \\(\\omega\\) \\omega \\(\\varepsilon\\) \\varepsilon \\(\\nu\\) \\nu \\(\\tau\\) \\tau \\(\\Omega\\) \\Omega \\(\\zeta\\) \\zeta \\(\\xi\\) \\xi \\(\\upsilon\\) \\upsilon \\(\\eta\\) \\eta \\(\\Xi\\) \\Xi \\(\\Upsilon\\) \\Upsilon Užduotis 6.6 Įvertinkite, kuo skiriasi 6.4 lentelės pavyzdžiuose pateiktos lygtys, kai jas užrašome: eilutėje su tekstu (naudodami \\(\\$...\\$\\)) ir kaip atskirą lygčių bloką (naudodami \\(\\$\\$...\\$\\$\\)). Kuris būdas vaizdesnis? Daugiau informacijos apie LaTeX lygtis galite rasti šiame šaltinyje: https://en.wikibooks.org/wiki/LaTeX/Mathematics 6.4 Lygtys grafikų antraštėse Oficialus būdas užrašyti matematinius simbolius R grafikuose – tai plotmath išraiškos (daugiau sužinosite įrašę ?plotmath). Jos, deja, neįtrauktos į šį kursą, nes dažniausiai naudojamas metematines išraiškas (žiūrėti 6.4.1 skyriuje) galima užrašyti naudojant LaTeX lygčių sintaksę, nagrinėtą ankstesniuose skyriuose ir žinoti dar keturias taisykles. LaTeX lygtį rašant R grafikų antraštėse reiktų žinoti dar 4 taisyklės: lygtis rašoma kabutėse, tarp dolerio simbolių $…$, reikalinga funkcija TeX() (iš paketo latex2exp), atgal pasvirę brūkšniai turi būti sudvigubinami (\\\\). Paaiškinimas: Antraščių pavadinimai rašomi kabutėse – viengubose (pvz., &#39;antraštė&#39;) arba dvigubose (pvz., &quot;antraštė&quot;), nes tai yra tekstas; Ta antraštės vieta, kuri turi būti užrašyta kaip lygtis, matematinis simbolis, graikiška raidė, viršutinis ar apatinis indeksas rašoma tarp viengubų dolerio simbolių (pvz., (&quot;tekstas, $lygtis_1$&quot;)) Antraščių pavertimui į lygtį reikalinga funkcija TeX(), esanti pakete latex2exp (pvz., TeX(&quot;tekstas, $lygtis_1$&quot;)) Visus atgal pasvirusius brūkšnius (\\) reikia sudvigubinti (\\\\). Pvz., \\alpha turi būti parašyta kaip \\\\alpha, o \\times – kaip \\\\times. # LaTeX lygčių naudojimui grafikuose library(latex2exp) # Grafikas, braižomas ggplot2 sistema library(ggplot2) ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + geom_point() + ggtitle(label = TeX(&quot;Plotas, $cm^2$&quot;)) + # ← LaTeX lygtis čia labs(y = TeX(&quot;$\\\\alpha$&quot;), # ← LaTeX lygtis čia x = TeX(&quot;$\\\\frac{len}{\\\\bar{y}}$&quot;)) # ← LaTeX lygtis čia ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + geom_point() + xlab(TeX(&quot;$\\\\alpha$, sant. vnt.&quot;)) + # ← LaTeX lygtis čia ylab(TeX(&quot;vidurkis, $\\\\mu$&quot;)) # ← LaTeX lygtis čia hist(iris$Petal.Length, main = TeX(&quot;Ilgis, $\\\\beta$&quot;), xlab = &quot;Ilgis, cm&quot;, ylab = TeX(&quot;Dažnis, $\\\\nu$&quot;) ) Užduotis 6.7 Užsikraukite paketus latex2exp bei magrittr ir naudodamiesi programos kodo ruošiniu TeX(&quot;$...$&quot;) %&gt;% plot(), kuriame vietoje daugtaškio turėtų būti lygtis, ir LaTeX lygčių rašymo grafikų antraštėse taisyklėmis užrašykite šias lygtis: lygtis, pateiktas 6.1 lentelės stulpelyje „Pavyzdys“, kaip darėte ankstesnėje užduotyje; \\(A^{2x}_{CD}\\) \\(c = \\frac{A}{B}\\) \\(\\frac{x^2}{y^3}\\) \\(\\mu = \\bar{A} \\times \\Theta^\\alpha\\) \\(\\left( \\frac{x^2}{y^3} + \\mu \\right)_{pirmasis}\\) \\(\\left( \\frac{X}{Y} \\right)^2\\) \\(\\lambda = \\alpha \\frac{\\beta \\sigma^2}{\\mu}\\) \\(f = 40\\%\\) Pvz., (i) punkto atsakymas turėtų būti: TeX(&quot;$f = 40\\\\%$&quot;) %&gt;% plot() Pagal LaTeX lygčių rašymo grafikuose taisykles pataisykite programos kodą, esantį žemiau, kad lygtys grafiko antraštėse būtų rodomos teisingai. # Taisytinas kodas library(latex2exp) x &lt;- c(10, 22, 12, 31) y &lt;- c(1, 3, 5, 2) plot(x = x, y = y, main = &quot;Ilgis, $\\beta$&quot;, # ← taisyti čia xlab = &quot;I^2_alpha, sant.vnt.&quot;, # ← taisyti čia ylab = &quot;Tūris, m^3&quot;, # ← taisyti čia col = &quot;red&quot; ) Norimas rezultatas: 6.4.1 Matematinės išraiškos, kurias palaiko paketas latex2exp Šiame poskyryje pateikti lygčių ir simbolių pavyzdžiai, kuriuos palaiko paketas latex2exp (pav. 6.11). Pav. 6.11: TeX / LaTeX simboliai ir komandos, kurias palaiko paketas latex2exp. Atspausdinta naudojant R komandą latex2exp_supported(plot = TRUE). Daugiau „latex2exp“ palaikomų matematinių išraiškų ir lygčių pavyzdžių rasite suvedę komandą: latex2exp::latex2exp_examples() Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["skirstiniai.html", "7. Atsitiktiniai dydžiai ir skirstiniai 7.1 Apie pratybas 7.2 Tikimybių teorijos elementai 7.3 Tikimybiniai atsitiktinių dydžių modeliai 7.4 Skirstiniai programoje R 7.5 Programos GeoGebra tikimybių skaičiuoklė 7.6 Skirstiniai ir tikimybiniai uždaviniai 7.7 Grafiniai būdai modelio ir duomenų suderinamumui vertinti 7.8 Skaitiniai būdai modelio ir duomenų suderinamumui vertinti 7.9 Statistinio modelio parinkimas duomenims", " 7. Atsitiktiniai dydžiai ir skirstiniai 7.1 Apie pratybas Pratybų metu mokysimės (1) turimiems duomenims parinkti labiausiai tinkantį tikimybinį modelį (skirstinio tipą ir tinkamiausius jo parametrus) bei (2) spręsti tikimybinius uždavinius. Užsiėmimo tikslas – išmokti duomenims parinkti tinkamą teorinį atsitiktinio dydžio modelį (skirstinį) bei susipažinti su skirstinių taikymo principais tikimybiniams uždaviniams spręsti. 7.2 Tikimybių teorijos elementai Taikant aprašomosios statistikos metodus galima aprašyti bet kokią imtį (nekreipiant dėmesio į atsitiktinumą, atsirandantį sudarant imtį) ar net visą generalinę aibę (GA). Tačiau norint pagal imties duomenis daryti statistines išvadas (išvadas apie visą GA) būtina atsižvelgti į šį atsitiktinumą. Statistinių išvadų darymo metodai grindžiami tikimybių teorija. Tam, kad galiotų tikimybių teorijos dėsniai, imtis turi būti sudaryta tinkamai – tikimybiniu būdu, t. y., kiekvienam objektui tikimybė patekti į imtį turi būti vienoda, ir teoriškai idealiu laikomas – visiškai atsitiktinis grąžintinis imties sudarymo būdas. Šiame kurse dėstomi statistinių išvadų darymo metodai sukurti tik visiškai atsitiktinėms imtims ir tinka tik tada, jei imtis yra tikimybinė. 7.2.1 Tikimybiniai eksperimentai ir įvykiai Viena iš tikimybių teorijos sąvokų yra tikimybinis eksperimentas – tai toks bandymas, kuris gali turėti keletą atsitiktinių baigčių, ir negalima iš anksto pasakyti, kuri iš galimų baigčių įvyks šį kartą. Kiekvieno tikimybinio eksperimento rezultatas vadinamas (atsitiktiniu) įvykiu. Pvz., bandymas – auginamos ląstelės, įvykis – užaugusių ląstelių skaičius; bandymas – tiriama kūdikio lytis, įvykis – lytis yra mergaitė; bandymas – pasėjama 10 sėklų, įvykis – sudygo 8 sėklos; bandymas – vykdoma apklausa, įvykis – 91% studentų atsakė, kad jau atliko namų darbus; bandymas – ieškomas organų donoras iki tol, kol bus rastas tinkamas, įvykis (jei donoras rastas iš antro karto): pirmas donoras – netinkamas, antras – tinkamas; bandymas – sportininkas šauna į taikinį, įvykis – balų skaičius, surinktas pagal balų skaičiavimo taisykles. Įvykiai gali būti elementarieji (tokie, kurie negali būti suskaidyti į mažesnes dalis, pvz., viena sėkla gali arba sudygti, arba nesudygti) ir sudėtiniai (susidėti iš kelių elementariųjų įvykių, pvz., pasodinus 10 sėklų, kiekvienos iš jų sudygimas/nesudygimas – elementarusis įvykis, o bendras viso eksperimento rezultatas – sudygusių sėklų skaičius – sudėtinis įvykis). Įvykis – tai tikimybinio eksperimento rezultatas. 7.2.2 Atsitiktinis dydis Kita tikimybių teorijos sąvoka – atsitiktinis dydis (trumpinsime ats.d., angl. random variable) yra toks dydis, kuris po bandymo įgyja vieną konkrečią iš anksto nežinomą skaitinę reikšmę. Tam, kad atsitiktinio dydžio reikšmė taptų skaitinė, gali būti panaudota perkodavimo ar perskaičiavimo taisyklė, pagal kurią atsitiktiniam įvykiui priskiriama skaitinė reikšmė. Jei bandymo rezultatas nėra išreikštas kaip skaičius – tai nėra atsitiktinis dydis. Keletas ats.d. pavyzdžių: tiriame augalų aukštį, ats.d. – aukštis centimetrais; ištiriame n baltymo molekulių, ats.d. – pažeistų molekulių skaičius; pasėjame 20 sėklų, ats.d. – sudygusių sėklų skaičius po 3 dienų (įvykis – sėkla sudygo ar nesudygo – nėra ats.d., nes tai ne skaičius, o pavertimas į ats.d. – suskaičiavimas, kiek sėklų sudygo); ieškome naftos ir darome gręžinius, ats.d. – gręžinių, kuriuose neradome naftos, skaičius iki tol, kol padarėme gręžinį, kuriame atradome naftos (vėl kategorinio tipo – rado/nerado naftos – įvykiui pritaikoma tam tikra taisyklė, kaip paversti į skaičių); tiriame paukštį ir skaičiuojame parazitus, ats.d. – surastų parazitų skaičius. Atsitiktinio dydžio įgyjamos reikšmės visada yra skaičiai. Atsitiktiniai dydžiai dažnai žymimi didžiosiomis raidėmis, (pvz., \\(X\\), tarkim ilgis), o jų įgyjamos reikšmės – mažosiomis (\\(x\\), tarkim 6 cm). Atsitiktinio dydžio vidurkis žymimas \\(\\mathbf{E}X\\), o dispersija – \\(\\mathbf{D}X\\). Skaitiniai kintamieji būna tolydieji arba diskretieji, todėl ir atsitiktiniai dydžiai būna diskretieji arba tolydieji. Pav. 7.1: Ar įžvelgiate analogiją tarp diskrečiųjų ir tolydžiųjų ats.d. bei diskrečiųjų \\((A)\\) ir tolydžiųjų, gradientinių \\((B)\\) spalvų skalių? Daugiau apie atsitiktinius dydžius galite sužinoti šiame video paskaitų cikle (anglų kalba su subtitrais, kurių reikia ieškoti kortelėje „Transcript“): nuoroda . Visiems rekomenduoju peržiūrėti bent pirmąją dalį, kurios trukmė ~ 6 min. 7.2.3 Tikimybė Tikimybė (angl. probability) – skaitinis atsitiktinės įvykio baigties galimybės matas. Kinta nuo 0 (negalimas įvykis, kuris neįvyks) iki 1 (būtinasis įvykis, kuris tikrai įvyks). Tikimybė dažnai žymima kaip funkcija \\(P\\). Jei \\(A\\) yra mus dominantis įvykis, sakykime, \\(A\\) – gims mergaitė, tada užrašas „\\(P(A)\\)“ nurodo tikimybę, kad gims mergaitė, pvz., \\(P(A) = 0.49\\). Užrašas \\(P(X = x) = 0.1\\) reikštų, kad tikimybė, jog atsitiktinis dydis (\\(X\\) didžioji, sakykime, kolonijų skaičius) bus lygus konkrečiam skaičiui (\\(x\\) mažoji, tarkim, 20), lygi 0.1, t. y., 10%. Tikimybė gali būti užrašoma kaip skaičius tarp 0 ir 1 arba procentine išraiška nuo 0% iki 100%. Apie terminų vartojimą: terminas „tikimybė“ yra tinkamesnis kalbant apie generalinę aibę. O kalbant apie imties duomenis, tinkamesnis atitikmuo būtų „santykinis dažnis“. Generalinė aibė ↔ tikimybė Imtis ↔ santykinis dažnis 7.2.4 Skirstiniai Atsitiktinio dydžio reikšmių skirstinys (angl. probability distribution), arba tiesiog skirstinys, – yra būdas arba taisyklė, susiejanti atsitiktinio dydžio reikšmes su jų įgijimo tikimybėmis. Skirstinys gali būti pateiktas kaip formulė, lentelė arba grafikas. Priklausomai nuo ats.d. tipo, skirstiniai skirstomi į diskrečiuosius ir tolydžiuosius. Atsitiktinio dydžio skirstinys – tai atsitiktinio dydžio reikšmės ir su jomis susietos tikimybės. Kiekvienas skirstinys gali būti pateiktas dviem formomis (pav. 7.2): jei skirstinys diskretusis: tikimybių (tikimybės masės) funkcija (pvz., santykinių dažnių lentelė) – parodo konkrečios reikšmės įgijimo tikimybę, kuri įprastai žymima \\(P(X = x)\\); diskrečioji pasiskirstymo funkcija (pvz., sukauptųjų santykinių dažnių lentelė) – parodo tikimybę įgyti reikšmę, ne didesnę už kitą konkrečią reikšmę, vadinamą kvantiliu. Pasiskirstymo funkcija įprastai žymima \\(F(x)\\), kur \\(x\\) yra kvantilis, ir yra lygi išraiškai \\(P(X \\le x)\\). jei skirstinys tolydusis: tikimybės tankio funkcija (ar pamenate branduolių tankio grafiką?) – pasirinktame ats.d. reikšmių intervale plotas po šia kreive parodo tikimybę ats.d. reikšmei patekti į intervalą; tolydžioji pasiskirstymo funkcija – analogiškai kaip ir diskrečiojo skirstinio atveju, parodo tikimybę įgyti reikšmę, ne didesnę už kitą konkrečią reikšmę, vadinamą kvantiliu, taip pat žymima \\(F(x)\\) ir yra lygi \\(P(X \\le x)\\). Trumpas matematinių užrašų, tokių kaip \\(F(x)\\), \\(P(X=x)\\), \\(P(X&lt;x)\\), paaiškinimas. Sakykime, kad atliekame kūdikių svorio tyrimą. Užrašas, \\(F(3~kg)\\) atitiktų užrašą \\(P(Svoris \\le 3~kg)\\) bei sakinį „tikimybė, kad kūdikio svoris, tiriamasis atsitiktinis dydis \\(X\\), bus ne didesnis už \\(3~kg\\), t. y., už konkretų skaičių \\(x\\)“. Pav. 7.2: Diskrečiųjų ir tolydžiųjų skirstinių formos ir paaiškinimai, kaip jas atpažinti. Taškai žymi konkrečias ats.d. reikšmes ir su jomis susietas tikimybes. Pav. 7.3: Sąsaja tarp tolydžiojo ats.d. \\(X\\) kvantilio \\(x_\\alpha\\), su juo susietos tikimybės \\(\\alpha\\) bei tikimybės tankio ir tikimybės pasiskirstymo grafikų. Plotas po tankio grafiko kreive tam tikrame intervale nurodo tikimybę, kuri matoma ir pasiskirstymo funkcijos y ašyje. Plotas po visa tankio kreive lygus 1, tokio dydžio yra ir maksimali pasiskirstymo funkcijos y ašies reikšmė. Vaizduojamas normaliojo skirstinio pavyzdys. Pav. 7.4: Sąsaja tarp diskrečiojo ats.d. \\(X\\) kvantilio \\(x_{\\alpha}\\), su juo susietos tikimybės \\(\\alpha\\) bei tikimybių (masės) ir tikimybės pasiskirstymo grafikų. Vaizduojamas binominio skirstinio pavyzdys. Atsitiktiniai dydžiai įprastai gali būti aprašyti vienu iš kelių žinomų teorinių skirstinių, kurie modeliuoja tam tikrus procesus. Pvz., tolydieji ats.d. gali būti aprašomi normaliuoju (Gauso), log-normaliuoju, diskretieji – Puasono, binominiu, geometriniu, neigiamu binominiu ir kitais. Į teorinių skirstinių naudojimą galima žiūrėti kaip į mokslinį įrankį, skirtą įvertinti tikimybinių reiškinių neapibrėžtumą, apskaičiuoti paklaidas, analizuoti procesų kilmę (ar atitinka modelį, ar ne), atlikti kitokius skaičiavimus, kurie leistų priimti statistiniu modeliavimu pagrįstus sprendimus. Tarkime, jei modelis imties duomenims tinka pakankamai gerai, tada tarsi teigiama, kad modeliu aprašomas skirstinys būdingas generalinei aibei ir pagal jį galima daryti prognozes. Skirstiniai gali būti taikomi tokiose srityse, kaip: tikimybinių reiškinių, atsitiktinių dydžių modeliavimas (pvz., apskaičiuoti, kokia tikimybė, kad jūs turėsite bent 2 vaikus); pasikliauties intervalų sudarymas (pvz., iš apklausos duomenų reikia įvertinti, kuri visos Lietuvos vyrų reguliariai užsiima aktyvia fizine veikla); statistinių hipotezių tikrinimas (pvz., iš tyrimo duomenų reikia nuspręsti, kas Vilniaus universiteto studentams labiau pakelia nuotaiką: plytelė šokolado ar 15 minučių bėgimo). Šio užsiėmimo metu gilinsimės į pirmąją taikymo sritį. Keliuose tolimesniuose skyriuose apžvelgsime kelis dažniausiai naudojamus tikimybinius modelius. 7.3 Tikimybiniai atsitiktinių dydžių modeliai Šiame skyriuje panagrinėsime kelis žinomus teorinius skirstinius, kurie gali būti naudojami tikimybi6kai apra6yti tam tikrų bandymų rezultatus. 7.3.1 Binominis skirstinys Keletas terminų, susijusių su diskrečiaisiais skirstiniais: sėkmė (arba sėkmingas bandymas) – toks rezultatas, kai įvyko mus dominantis/mums palankus įvykis; nesėkmė (arba nesėkmingas bandymas) – toks rezultatas, kai neįvyko mus dominantis/mums palankus įvykis. Sakykime, kad vykdome bandymą tokiomis sąlygomis: atliekant bandymą galimos tik 2 baigtys, pvz., pavyko / nepavyko, sėkmė / nesėkmė, vyras / moteris, sudygo / nesudygo, skaičius / herbas; bandymus kartojame \\(n\\) kartų \\((n = ~1, ~2, ~3, ~...)\\): pvz., iš viso yra \\(n\\) objektų, gali įvykti \\(n\\) įvykių ir pan. vieno bandymo sėkmės tikimybė yra žinoma ir lygi \\(p\\) \\((0&lt;p&lt;1)\\); tikimybė \\(p\\) yra pastovi visų bandymų metu; kiekvieno bandymo rezultatai yra tarpusavyje nepriklausomi. Tokiu atveju ats.d. \\(X\\) – sėkmingų bandymų skaičius iš \\(n\\) galimų – bus diskretusis \\((k = 0,~ 1,~ 2,~ ... ,~ n)\\), pasiskirstęs pagal binominį dėsnį ir žymimas: \\[\\begin{equation} X \\sim \\mathcal{B}(n, ~ p) \\tag{7.1} \\end{equation}\\] Konkrečios reikšmės įgijimo tikimybė aprašoma lygtimi: \\[\\begin{equation} P(X = k) = \\binom{n}{k}p^kq^{n-k} \\tag{7.2} \\end{equation}\\] Čia \\(q = (1-p)\\), o \\(\\binom{n}{k} = \\frac{n!}{k!(n-k)!}\\) – binominis koeficientas. Matematinės binominio ats.d. savybės (vidurkis ir dispersija): \\[\\begin{equation} \\mathbf{E}X = np, ~~~ \\mathbf{D}X = npq \\tag{7.3} \\end{equation}\\] Biologinis pavyzdys: ats.d. – sudygusių sėklų skaičius, kai pasėjame 20. Jei \\(X\\) yra binominis ats.d., įprastai skirstinio parametrą \\(n\\) žinome (arba numanome) – nes žinome, kiek kartų atliktas eksperimentas. Mums dažniausiai reikia nustatyti sėkmės tikimybę \\(p\\). Atkreipkite dėmesį, kad binominio skirstinio parametras \\(n\\) nėra tas pats, kas imties dydis, kuris dažnai statistikoje žymimas ta pačia raide. Šio žymėjimo nekeičiau, nes jis plačiai paplitęs ir naudojamas programose, kuriomis atliksime skaičiavimus. Jei gerai išstudijuosite binominį modelį, sunkumų neturėtų kilti. 7.3.2 Puasono skirstinys Sakykime, kad vykdome bandymą tokiomis sąlygomis: atliekant bandymą skaičiuojami įvykiai, tenkantys vienam vienetui: objektui arba laiko, ilgio, ploto, erdvės ar kitokiam vienetui; vidutinis įvykių skaičius \\((\\lambda)\\) šiam vienetui yra žinomas; maksimalus galimas įvykių skaičius nėra apribotas; tikimybė, kad įvyks įvykis, ir vidutinis įvykių skaičius yra pastovūs ir nekinta; įvykiai tarpusavyje yra nepriklausomi. Tokiu atveju ats.d. \\(X\\) – įvykių skaičius, tenkantis objektui, laiko, erdvės ar pan. vienetui – yra diskretusis \\((k = 0,~ 1,~ 2,~ ... )\\), skirstosi pagal Puasono modelį ir žymimas: \\[\\begin{equation} X \\sim \\mathcal{P}(\\lambda) \\tag{7.4} \\end{equation}\\] Konkrečios reikšmės įgijimo tikimybė aprašoma lygtimi: \\[\\begin{equation} P(X = k) = \\frac{ \\lambda^k }{k!}e^{-\\lambda} \\tag{7.5} \\end{equation}\\] Puasono ats.d. savybės (vidurkis ir dispersija): \\[\\begin{equation} \\mathbf{E}X = \\lambda, ~~~ \\mathbf{D}X = \\lambda \\tag{7.6} \\end{equation}\\] Parametras \\(\\lambda\\) yra kartu ir vidurkis, ir dispersija. Biologiniai pavyzdžiai: ats.d. – mutacijų, įvykstančių vienoje chromosomoje, skaičius. ats.d. – retos ligos atvejų, įvykstančių populiacijoje per vienerius metus, skaičius. 7.3.3 Binominio skirstinio aproksimacija Puasono skirstiniu Sakykime, kad savo tyrimo rezultatą galime aprašyti binominio skirstinio modeliu \\(X \\sim \\mathcal{B}(n, ~ p)\\), tačiau \\(n\\) palyginus su \\(p\\) – labai didelis (tarkime, \\(n &gt; 1000\\)), o \\(p\\) – labai mažas (tarkime, \\(p&lt;0,001\\)). Tokiu atveju binominio skirstinio tikimybes pakankamai gerai atitinka Puasono skirstinio \\(\\mathcal{P}(np)\\) tikimybės: teorinį binominio skirstinio vidurkį prilyginame teoriniam Puasono skirstinio vidurkiui \\((np \\sim \\lambda)\\) ir skaičiavimus atliekame naudodami Puasono skirstinį. Įprastai šitokios aproksimacijos reikia, jei skaičiavimus atliekame ne kompiuteriu arba grafinės skaičiuoklės, tokios kaip „GeoGebra“, užstringa dėl didelių skaičių. Skaičiuojant programa „R“ problemų įprastai nekyla. 7.3.4 Geometrinis skirstinys Sakykime, kad vykdome bandymą tokiomis sąlygomis: atliekant bandymą galimos tik 2 baigtys, pvz., pavyks / nepavyks, vyras / moteris; bandymus kartojame tol, kol sulaukiame pirmos sėkmės; vieno bandymo sėkmės tikimybė yra žinoma ir lygi \\(p\\) \\((0&lt;p&lt;1)\\); tikimybė \\(p\\) yra pastovi visų bandymų metu; kiekvieno bandymo rezultatai yra tarpusavyje nepriklausomi. Tada ats.d. \\(X\\) galime apsibrėžti kaip nesėkmingų bandymų skaičių iki pirmos sėkmės (į \\(X\\) sėkmingų bandymų skaičius nėra įskaitytas). Toks ats.d. \\(X\\) yra diskretusis \\((k = 0, 1, 2, …)\\), skirstosi pagal geometrinį skirstinį ir žymimas: \\[\\begin{equation} X \\sim \\mathcal{Geom}(p) \\tag{7.7} \\end{equation}\\] Konkrečios reikšmės įgijimo tikimybė aprašoma lygtimi: \\[\\begin{equation} P(X = k) = pq^k \\tag{7.8} \\end{equation}\\] Čia \\(q =(1-p)\\). Geometrinio ats.d. savybės (vidurkis ir dispersija): \\[\\begin{equation} \\mathbf{E}X = \\frac{q}{p}, ~~~ \\mathbf{D}X = \\frac{q}{p^2} \\tag{7.9} \\end{equation}\\] Biologinis pavyzdys: ats.d. yra gimusių berniukų skaičius prieš gimstant pirmai mergaitei. Pastaba. Geometrinis skirstinys turi du susijusius, bet skirtingus matematinius apibrėžimus. Šiame skyriuje pasirinktas tas, kuris naudojamas programose R ir GeoGebra. Čekanavičiaus ir Murausko vadovėlyje pateiktas kitas matematinis geometrinio skirstinio apibrėžimas, tad formulės neatitinka. Tačiau rezultatus galime persiskaičiuoti. Pavyzdžiui, jei norime modeliuoti, kiek įvykių įvyko iš viso \\((\\)pažymėkime \\(X^*)\\), o žinome, kiek iš jų buvo nesėkmingi \\((X)\\), prie gautos konkrečios \\(X\\) reikšmės pridedame 1 (sėkmingų įvykių skaičių): \\(k^* = k + 1\\) (\\(k^*\\) – įvykių skaičius iš viso). Analogiškai ir prie vidurkio pridedame 1: \\(\\mathbf{E}X^* = \\mathbf{E}X + 1\\). Tačiau prie dispersijos nieko pridėti nereikia, nes prie kiekvienos reikšmės pridėta konstanta dispersijos nepakeičia: \\(\\mathbf{D}X^* = \\mathbf{D}X\\). Jei dėl geometrinių atsitiktinių dydžių kyla klausimų ar neaiškumų, siūlau peržvelgti šį šaltinį (nuoroda ), kuriame aprašomi skirtumai. 7.3.5 Neigiamas binominis skirstinys Sakykime, kad vykdome bandymą tokiomis sąlygomis: atliekant bandymą galimos tik 2 baigtys, pvz., pavyks / nepavyks; bandymus kartojame tol, kol sulaukiame \\(r\\) sėkmių \\((r &gt; 0)\\); vieno bandymo sėkmės tikimybė yra žinoma ir lygi \\(p\\) \\((0&lt;p&lt;1)\\); tikimybė \\(p\\) yra pastovi visų bandymų metu; kiekvieno bandymo rezultatai yra tarpusavyje nepriklausomi. Tada ats.d. \\(X\\) galime apsibrėžti kaip nesėkmingų bandymų skaičių iki \\(r\\)-tosios sėkmės (į \\(X\\) sėkmingų bandymų skaičius nėra įskaitytas). Toks ats.d. \\(X\\) yra diskretusis \\((k = 0, 1, 2, …)\\), skirstosi pagal neigiamą binominį skirstinį ir žymimas: \\[\\begin{equation} X \\sim \\mathcal{NB}(r, p) \\tag{7.10} \\end{equation}\\] Konkrečios reikšmės įgijimo tikimybė aprašoma lygtimi: \\[\\begin{equation} P(X = k) = \\binom{k+r-1}{r-1}p^r q^k \\tag{7.11} \\end{equation}\\] Čia \\(q =(1-p)\\). Neigiamo binominio ats.d. savybės (vidurkis ir dispersija): \\[\\begin{equation} \\mathbf{E}X = \\frac{qr}{p}, ~~~ \\mathbf{D}X = \\frac{qr}{p^2} \\tag{7.12} \\end{equation}\\] Biologinis pavyzdys: ats.d. yra gimusių berniukų skaičius prieš gimstant penktai mergaitei. Bendruoju atveju parametras \\(r\\) gali nebūti sveikasis skaičius. Kai jis yra sveikasis, neigiamas binominis skirstinys dar vadinamas Paskalio (Pascal) skirstiniu (t. y., tam tikras neigiamo binominio skirstinio atvejis). Geometrinis skirstinys – taip pat atskiras neigiamo binominio ir Paskalio skirstinių atvejis, kai \\(r = 1\\). \\[\\begin{equation} X \\sim \\mathcal{NB}(r = 1,~ p) = Geom(p) \\tag{7.13} \\end{equation}\\] Paskalio skirstinys – tai neigiamas binominis skirstinys, kai parametras \\(r\\) yra sveikasis skaičius. Geometrinis skirstinys – tai neigiamas binominis skirstinys, kai parametras \\(r = 1\\). Pastaba. Neigiamas binominis skirstinys turi keletą skirtingų matematinių formuluočių, o šiame skyriuje aprašyta ta, kuri naudojama programose R ir GeoGebra. Norėdami modeliuoti kitaip apibrėžtą atsitiktinį dydį, rezultatus galime persiskaičiuoti. Pavyzdžiui, jei norime modeliuoti, kiek įvykių įvyko iš viso \\((\\)pažymėkime \\(X^*)\\), o žinome, kiek iš jų buvo nesėkmingi \\((X)\\), prie gautos konkrečios \\(X\\) reikšmės pridedame sėkmingų įvykių skaičių \\(r\\): \\(k^* = k + r\\) (\\(k^*\\) – įvykių skaičius iš viso). Analogiškai ir prie vidurkio pridedame \\(r\\): \\(\\mathbf{E}X^* = \\mathbf{E}X + r\\). Tačiau prie dispersijos nieko pridėti nereikia, nes prie kiekvienos reikšmės pridėta konstanta dispersijos nepakeičia: \\(\\mathbf{D}X^* = \\mathbf{D}X\\). Jei kils neaiškumų dėl neigiamo binominio skirstinio apibrėžimų, siūlau peržiūrėti šį šaltinį (nuoroda ). 7.3.6 Normalusis skirstinys Normalusis skirstinys yra tolydusis. Tikimybių teorijoje tai pats svarbiausias skirstinys, nes juo galima aprašyti daugelį natūraliai vykstančių reiškinių. Atsitiktinis dydis \\(X\\), kuris skirstosi pagal normalųjį skirstinį, žymimas: \\[\\begin{equation} X \\sim \\mathcal{N}(\\mu, \\sigma^2) \\tag{7.14} \\end{equation}\\] Normaliojo atsitiktinio dydžio tikimybės tankis \\(p(x)\\) ties konkrečia reikšme \\(x\\) skaičiuojamas pagal formulę: \\[\\begin{equation} p(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}~e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} \\tag{7.15} \\end{equation}\\] Parametrai: \\(\\mu\\) – vidurkis \\((\\mu \\in \\mathbb{R})\\); \\(\\sigma^2\\) – dispersija \\((\\sigma^2 &gt; 0)\\). Statistinės programos paprastumo dėlei vietoje dispersijos dažnai naudoja standartinį nuokrypį. Normaliojo ats.d. savybės (vidurkis, dispersija ir standartinis nuokrypis): \\[\\begin{equation} \\mathbf{E}X = \\mu, ~~~ \\mathbf{D}X = \\sigma^2, ~~~ \\sqrt{\\mathbf{D}X} = \\sigma \\tag{7.16} \\end{equation}\\] Standartinis normalusis: \\[\\begin{equation} X \\sim \\mathcal{N}(0; 1) \\tag{7.17} \\end{equation}\\] Standartinio normaliojo skirstinio savybės – vidurkis lygus nuliui, dispersija ir standartinis nuokrypis lygūs vienetui: \\[\\begin{equation} \\mathbf{E}X = 0, ~~~ \\mathbf{D}X = 1, ~~~ \\sqrt{\\mathbf{D}X} = 1 \\tag{7.18} \\end{equation}\\] Jei skirstinys normalusis, galioja empirinės taisyklės (grafinė iliustracija: nuoroda ). 7.3.7 Log-normalusis skirstinys Jei atsitiktinis dydis gali įgyti tik teigiamas reikšmes \\((X&gt;0)\\), o atlikus logaritminę transformaciją jo skirstinys tampa normalusis, tada sakoma, kad atsitiktinis dydis \\(X\\) pasiskirstęs pagal log-normalųjį skirstinį: \\[\\begin{equation} log(X) \\sim \\mathcal{N}(\\mu, \\sigma^2) \\tag{7.19} \\end{equation}\\] Atlikę logaritminę transformaciją, su šiuo dydžiu galime elgtis kaip su įprastu normaliuoju. 7.4 Skirstiniai programoje R Programoje R skirstinius aprašančių funkcijų pavadinimai turi 2 dalis: funkcijos tipą (norimą skaičiavimą) aprašanti dalis (raidė d, p, q arba r); skirstinio tipą aprašanti dalis (trumpasis R skirstinio pavadinimas). Lentelė 7.1: Funkcijos tipą (norimą skaičiavimą) aprašanti R funkcijos pavadinimo dalis (pirmoji raidė). Pirmoji raidė Pavadinimas Apibūdinimas d…() Tikimybės tankio arba tikimybių (masės) funkcija Konkrečiai ats.d. reikšmei \\(x\\)¹ apskaičiuojamas tikimybės tankis (tolydiesiems ats.d.) arba reikšmės įgijimo tikimybė \\(P(X = x)\\) (diskretiesiems ats.d.). p…() Pasiskirstymo funkcija Pateiktam kvantiliui \\(q\\)¹ apskaičiuojama jį atitinkanti tikimybė \\(p\\), lygi \\(P(X \\le q)\\), jei lower.tail = TRUE² (pasirinkta pagal nutylėjimą) arba tikimybė \\(P(X&gt;q)\\), jei lower.tail = FALSE. q…() Kvantilių funkcija (atvirkštinė pasiskirstymo funkcijai) Pateiktai tikimybei \\(p\\)¹ apskaičiuojamas ją atitinkantis kvantilis \\(q\\). Jei lower.tail = TRUE, tai tikimybė yra \\(P(X \\le q)\\), jei lower.tail = FALSE, tada – \\(P(X&gt;q)\\). r…() Atsitiktinių reikšmių generavimo funkcija Sugeneruojamas nurodytas skaičius reikšmių, kurios paimtos iš pagal nurodytą dėsnį pasiskirsčiusios generalinės aibės. ¹ – gali būti viena reikšmė arba reikšmių seka. Jei seka – skaičiuojama kiekvienai reikšmei atskirai. ² – žiūrėti funkcijų dokumentacijoje, pvz., ?pnorm. Lentelė 7.2: Skirstinio tipą aprašanti R funkcijos pavadinimo dalis: tolydžiųjų skirstinių pavyzdžiai. Tolydusis skirstinys R pavadinimas Svarbiausi parametrai programoje R Normalusis (Gauso) norm mean – vidurkis, sd – standartinis nuokrypis. Log-normalusis lnorm meanlog – vidurkis (logaritminėje skalėje), sdlog – standartinis nuokrypis (logaritminėje skalėje). \\(\\chi^2\\) (chi kvadratu) chisq df – laisvės laipsniai (\\(df&gt;0\\), bet nebūtinai sveikieji). Stjudento (t) t df – laisvės laipsniai (\\(df&gt;0\\), bet nebūtinai sveikieji). Fišerio (F) f df1, df2 – laisvės laipsniai skaitiklyje ir vardiklyje. Logistinis logis location, scale – padėties ir sklaidos parametrai. Tolygusis unif min, max – apatinė ir viršutinė pasiskirstymo ribos. Lentelė 7.3: Skirstinio tipą aprašanti R funkcijos pavadinimo dalis: diskrečiųjų skirstinių pavyzdžiai, parametrai ir modeliuojamo atsitiktinio dydžio apibrėžimas. Diskretusis skirstinys R pavadinimas Svarbiausi parametrai ir ats.d. programoje R Binominis binom size – bandymų skaičius, prob – vieno bandymo sėkmės tikimybė,ats.d. – sėkmingų bandymų skaičius. Puasono pois lambda – įvykių skaičiaus vidurkis/dispersija, ats.d. – įvykusių įvykių skaičius. Geometrinis geom prob – vieno bandymo sėkmės tikimybė, ats.d. – nesėkmingų bandymų skaičius. Neigiamas binominis nbinom size – norimas sėkmių skaičius, prob – vieno bandymo sėkmės tikimybė, ats.d. – nesėkmingų bandymų skaičius. Hipergeometrinis hyper m – pirmos grupės objektų skaičius, n – antros grupės objektų skaičius, k – atsitiktiniu negrąžintiniu būdu pasirinktų/ištrauktų objektų skaičius, ats.d. – pirmos grupės objektų skaičius tarp pasirinktų. Apibendrinant 7.1, 7.2 ir 7.3 lentelėse pateiktą informaciją, pilni skirstinio tipą ir pagal jį norimą skaičiavimą vykdančių funkcijų pavadinimai bus, pavyzdžiui, tokie: pnorm() – pateikus kvantilį, skaičiuos su juo pagal normalųjį dėsnį susietą tikimybę, qbinom() – pateikus tikimybes, skaičiuos pagal binominį skirstinį su jomis susietus kvantilius. Kiekvienos funkcijos skliaustuose turi būti nurodomi konkretaus skirstinio parametrai. Apie tai rašoma kiekvienos funkcijos dokumentacijoje. 7.4.1 R Commander tikimybių skaičiuoklės Papildinio Rcmdr meniu juostoje yra skiltis Distributions. Joje galite rasti įvairias tikimybių skaičiuokles. 7.5 Programos GeoGebra tikimybių skaičiuoklė Programa „GeoGebra“ yra nemokamas įrankių rinkinys įvairiems matematiniams (geometriniams, statistiniams ir kitiems) skaičiavimams. Programą galima parsisiųsti į savo kompiuterį, planšetę arba naudoti internetinę versiją (internetinė skaičiuoklės versija: nuoroda ). Mums reikalingas įrankis – tikimybių skaičiuoklė, su kuria supažindinama video epizoduose 7.1, 7.2 bei perskaičius šias instrukcijas: „Probability Calculator“ – trumpa instrukcija, kaip naudotis tikimybių skaičiuokle (nuoroda ); „GeoGebra Probability and Statistics Quickstart“ – greitos pradžios gidas: instrukcijos ir pažintiniai pratimai (nuoroda ). Video epizodas 7.1 Programos „GeoGebra“ tikimybių skaičiuoklė: įvadas. Video epizodas 7.2 Bendrieji principai, kaip spręsti tikimybinius uždavinius programos „GeoGebra“ tikimybių skaičiuokle: konkrečių reikšmių įgijimo tikimybių, tikimybių įgyti reikšmę iš tam tikro intervalo, su tikimybėmis susietų kvantilių, ats.d. vidurkio ir standartinio nuokrypio apskaičiavimas. Dabartinė programos „GeoGebra“ versija Paskalio (kartu ir neigiamo binominio bei geometrinio) skirstinio vidurkį ir standartinį nuokrypį skaičiuoja neteisingai. Todėl naudokitės formulėmis. 7.6 Skirstiniai ir tikimybiniai uždaviniai Šiame skyriuje bus supažindinta, kaip sprendžiami tikimybiniai uždaviniai. Bendrosios rekomendacijos, kaip spręsti. Pirmiausia pagal uždavinio sąlygą reikia nuspręsti, ar uždaviniui spręsti apskirtai reikalingas skirstinys. Jei taip, tada nustatyti, ar atsitiktinis dydis yra tolydusis, ar diskretusis, bei koks galėtų būti jo skirstinio tipas ir parametrai. Po to spręsti, kas duota (kvantilis, konkreti reikšmė ar tikimybė) bei ką reikia apskaičiuoti (kvantilį, konkrečią reikšmę, reikšmių intervalą, tikimybę ar kokią nors kitą skirstinio savybę, pvz., vidurkį). Tada nuspręsti, ar naudoti tikimybių skaičiuokles, ar užtenka kurių nors skirstinio savybes, pvz., vidurkį aprašančių formulių. Svarbu patikrinti, ar rezultatas yra logiškas. 7.6.1 Žinome tikimybę, kaip rasti kvantilį? Nustatome, su kokio tipo ats.d. susidūrėme: tolydžiuoju ar diskrečiuoju. Pasirenkame tinkamą teorinio modelio (skirstinio) tipą: normalųjį, Puasono, binominį ar kitą. Apskaičiuojame modelio parametrus: jie gali būti nurodyti uždavinio sąlygoje. Nurodome tikimybę (skaitine išraiška); Pažymime, kuri tai tikimybė: Tikimybė „mažiau už“ (α, „lower tail“) ar Tikimybė „daugiau už“ (1-α, „upper tail“). Naudodami skaičiuoklę ar funkciją apskaičiuojame kvantilį (konkretų skaičių). Programoje R funkcijos, kurios skaičiuoja kvantilius, prasideda raide q(angl., quantile), po to seka sutrumpintas skirstinio pavadinimas: qnorm, qbinom, qpois, qt, … Kodą už mus gali parašyti Rcmdr. Uždavinį taip pat galima spręsti programa „GeoGebra“. Pav. 7.5: Kvantilių skaičiavimas papildiniu R Commander. Užduotis 7.1 Ar tiesa, kad: …kai Puasono skirstinio parametras \\(\\lambda = 3\\), tai skirstinio kvantilis, atitinkantis tikimybę \\(\\alpha=0.5\\), yra lygus 6? …kai geometrinio skirstinio sėkmės tikimybė (skirstinio parametras) \\(p = 1\\), tai kvantilis, atitinkantis tikimybę \\(1-\\alpha=0.4\\) yra lygus 4. 7.6.2 Žinome kvantilį, kaip rasti tikimybę? Nustatome, su kokio tipo ats.d. susidūrėme: tolydžiuoju ar diskrečiuoju. Pasirenkame tinkamą teorinio modelio (skirstinio) tipą: normalųjį, Puasono, binominį ar kitą. Apskaičiuojame modelio parametrus: jie gali būti nurodyti uždavinio sąlygoje. Nurodome kvantilį (skaitine išraiška); Pažymime, kuri tikimybė mus domina: Tikimybė „mažiau už“ (α, „lower tail“) ar Tikimybė „daugiau už“ (1-α, „upper tail“). Naudodami skaičiuoklę ar funkciją apskaičiuojame tikimybę (skaičių tarp 0 ir 1). Pav. 7.6: Principas, kaip apskaičiuoti tikimybes, kad reikšmė pateks į intervalą. Pav. 7.7: Tikimybių skaičiavimas papildiniu R Commander (tolydieji skirstiniai). Pav. 7.8: Tikimybių skaičiavimas papildiniu R Commander (diskretieji skirstiniai). R programoje funkcijos, kurios skaičiuoja tikimybes, kai žinomi kvantiliai, prasideda raide p (angl. probability), po to eina sutrumpintas skirstinio pavadinimas: pnorm, pbinom, ppois, pt, … Kodą už mus gali parašyti Rcmdr. Uždavinį taip pat galima spręsti programa „GeoGebra“. Užduotis 7.2 Kokia tikimybė, kad reikšmė, atsitiktinai pasirinkta iš Stjudento t skirstinio su 5 laisvės laipsniais, bus mažesnė už 1,3? 7.6.3 Žinome reikšmę, kaip rasti jos įgijimo tikimybę/tikimybės tankį? Programoje R funkcijos, kurios skaičiuoja konkrečios reikšmės įgijimo tikimybes/tikimybės tankį prasideda raide d (angl. density), po to eina sutrumpintas skirstinio pavadinimas: dnorm, dbinom, dpois, dt, … Pastaba: tikimybes skaičiuoja tik diskretiesiems dydžiams pagal tikimybės masės funkciją; tikimybės tankį skaičiuoja tik tolydiesiems dydžiams pagal tikimybės tankio funkciją. Užduotis 7.3 Žinoma, kad \\(X \\sim \\mathcal{P}(2)\\). Apskaičiuokite tikimybę \\(P(X = 4)\\). 7.6.4 Tikimybinių uždavinių pavyzdžiai Užduotis 7.4 Išspręskite šiuos uždavinius: Žąsų migracija. Daugiamečių stebėjimų duomenimis, žąsų migracija pavasarį užtrunka vidutiniškai 4 dienas (SD = 1,3 dienos). Darykime prielaidą, kad kelionės trukmės skirstinys yra normalusis. Kokia tikimybė, kad šiemet migracija: baigsis greičiau nei per 6 dienas? užtruks ilgiau nei 6 dienas? užtruks ne mažiau kaip 2, bet ne daugiau kaip 5 dienas? Koks migracijos trukmės 10% procentilis? SD – standartinis nuokrypis. Kelionė į paskaitą. Vidutiniškai kelionė į biostatistikos paskaitą užtrunka 40 min \\((\\sigma = 10~min)\\). Sakykime, kad kelionės trukmės skirstinys – normalusis. Kokia tikimybė, kad kelionė užtruks daugiau nei 50 min? Kokia tikimybė, kad kelionė užtruks mažiau nei 55 min? Nurodykite labiausiai tikėtinų kelionės trukmių intervalą (trumpiausią ir ilgiausią trukmę), atmetus 5% trumpiausių ir 5% ilgiausių kelionių. Nurodykite labiausiai tikėtinų kelionės trukmių intervalą, apibrėžiantį, kiek laiko įprastai užtrunka kelionė 95% kartų, atmetus vienodą kiekį išskirtinai trumpiausių ir išskirtinai ilgiausių kelionių. Kokia tikimybė, kad kelionė užtruks lygiai 30 min? Stjudento t skirstinys. Kokia tikimybė, kad atsitiktinai pasirinkta atsitiktinio dydžio, pasiskirsčiusio pagal Stjudento skirstinį su 5 laisvės laipsniais (df), reikšmė bus mažesnė už 0,5? Atsitiktinai pasirinka atsitiktinio dydžio, pasiskirsčiusio pagal Stjudento skirstinį, reikšmė. Įvertinkite, kada tikimybė, kad ši reikšmė bus mažesnė už -2, bus didesnė: kai skirstinio parametras df (laisvės laipsniai) lygus 10, 25 ar 50? Kada Stjudento skirstinio 5% procentilio reikšmė bus labiausiai nutolusi nuo 0: kai parametro df (laisvės laipsniai) reikšmė lygi 8, 22 ar 100? Kada Stjudento ir standartinis normalusis skirstiniai supanašėja? (Keiskite df reikšmes ir palyginkite.) df – nuo angl. degrees of freedom (laisvės laipsniai). Mergaitės trijų vaikų šeimoje. Kokia tikimybė, kad trijų vaikų šeimoje: bus bent viena mergaitė? visi vaikai bus mergaitės? bus dvi mergaitės? bus mažiau nei viena mergaitė? bus daugiau nei dvi mergaitės? pirmasis vaikas bus mergaitė? Kiek vidutiniškai mergaičių yra trijų vaikų šeimoje? Koks mergaičių skaičiaus trijų vaikų šeimoje standartinis nuokrypis? Neatvykimas į darbą. Vidutiniškai pirmadieniais į darbą neateina 3 darbuotojai. Kokia tikimybė, kad šį pirmadienį į darbą: ateis visi? neateis ne mažiau kaip 2 darbuotojai? neateis daugiau nei 5 darbuotojai? neateis nuo 2 iki 6 darbuotojų? Spontaninės mutacijos. Tyrimo su drozofilomis rezultatai siūlo, kad spontaninių žalingų mutacijų dažnis yra apie 1,2 mutacijos diploidiniam genomui. Darykime preliminarią prielaidą, kad žmogaus genome įvykstančių mutacijų pasiskirstymas atitinka Puasono dėsnį \\((X \\sim \\mathcal{P}(\\lambda = 1,2))\\). Kokia tikimybė, kad individas turės bent 12 spontaninių žalingų mutacijų? Genetinis nestabilumas. Tiriamas genetinis nestabilumas ir su juo susijęs vėžys. Paprastai, didelėje populiacijoje per metus suserga tik 1 pacientas iš 1000. Kokia tikimybė, kad šiemet šioje populiacijoje susirgs: tik 1 pacientas? susirgs bent 3 pacientai? ne mažiau kaip 2 pacientai? daugiau nei 5 pacientai? niekas nesusirgs? Kiek vidutiniškai pacientų susirgs šiemet? Sėklos – 1. Sėjant sėklas vienos sėklos sudygimo tikimybė – 75%. Įvertinkite, kiek vidutiniškai sėklų reikia pasėti, kad sudygtų 20, ir koks reikiamo pasėti sėklų skaičiaus standartinis nuokrypis. Kokia tikimybė, kad pasėjus 20 sėklų sudygs bent 75% iš jų? Naftos gręžiniai – 1. Naftos kompanijos atstovai žino, kad tiriamajame rajone 80% gręžinių naftos neturi. Kokia tikimybė, kad prieš atrandant naftos bus padaryti 2 nesėkmingi bandymai? Kokia tikimybė, kad nafta bus atrasta gręžiant penktą kartą? Kokia tikimybė, kad nafta bus atrasta išgręžus ne daugiau kaip 6 gręžinius be naftos? Kiek vidutiniškai gręžinių reikia išgręžti, kad būtų rasta naftos? Naftos gręžiniai – 2. Naftos kompanijos atstovai žino, kad tiriamajame rajone padarius gręžinį tikimybė rasti naftos 60%. Šiame regione yra suplanuota eksploatuoti 3 naftos platformas. Kiek vidutiniškai gręžinių reikės padaryti, norint įgyvendinti šį tikslą? Kokia tikimybė, kad visi 3 bandymai bus sėkmingi? Kokia tikimybė, kad iki tol, kol pasieks tikslą, kompanija padarys ne daugiau kaip 3 nesėkmingus bandymus? Recesyvinė liga ir būsimi vaikai. Vyras ir moteris yra recesyvinės ligos nešiotojai. Jie nori 5 vaikų. Kokia tikimybė, kad visi 5 vaikai šios ligos atžvilgiu bus sveiki? Kokia tikimybė, kad bent 4 vaikai iš penkių bus sveiki? Dalinius kai kurių uždavinių sprendimus arba atsakymus galite rasti VMA (nuoroda ) 7.7 Grafiniai būdai modelio ir duomenų suderinamumui vertinti Praktikoje dažnai mes teorinio modelio neturime ir jį reikia susidaryti pagal surinktus duomenis. Tai, kaip modelį sudaryti, bus nagrinėjama tolimesniuose skyriuose, o šiame – pristatomi grafiniai būdai, kuriais galima palyginti teorinį modelį su empiriniais duomenimis ir įvertinti, ar duomenys ir modelis pakankamai gerai suderinami (t. y., ar pakankamai gerai atitinka). 7.7.1 Kvantilių palyginimo (qq) diagrama Kvantilių palyginimo, arba kvantilių-kvantilių (qq) diagrama (angl. quantile-quantile plot, q-q plot), yra grafinis būdas, skirtas palyginti, ar empirinių – ypač tolydžiųjų – duomenų pasiskirstymas atitinka teoriniu (pvz., normaliuoju) modeliu aprašomą pasiskirstymą. Šis grafikas yra vienas populiariausių, todėl jam bus skirta daugiau dėmesio nei kitiems skirstinių palyginimo grafikams. QQ diagramos x ašyje įprastai atidedami teorinio modelio kvantiliai, o y ašyje – empirinių duomenų kvantiliai (kai kuriose programose gali būti ir atvirkščiai). X ašyje gali būti tiek labiausiai jūsų duomenis atitinkančio normaliojo skirstinio (pav. 7.9), tiek ir standartinio normaliojo (pav. 7.10) skirstinio kvantiliai. Visais atvejais, kuo qq diagramos taškų išsidėstymas panašesnis į tiesę, einančią ties grafiko įstrižaine, tuo duomenys geriau atitinka modelį. Ypač svarbu, kad vienoje tiesėje būtų duomenų taškai, esantys tarp pirmojo \\((Q_1)\\) ir trečiojo \\((Q_3)\\) kvartilių. Visi kiti orientyrai (papildoma atskaitos tiesė ir jos pasikliauties intervalai, kaip pav. 7.10) yra tik pagalbiniai dalykai. Pav. 7.9: Įprasta kvantilių-kvantilių (q-q) diagrama. Pav. 7.10: Kvantilių-kvantilių (qq) diagrama su atskaitos tiese ir šios tiesės pasikliauties intervalu. Jei pasiskirstymas skiriasi nuo teorinio, taškai nukrypsta nuo įstrižainės. Keletas pavyzdžių, kaip atrodo skirstinį atitinkantys ir aiškiai jo neatitinkantys duomenys, vaizduojama pav. 7.11. Pav. 7.11: Normalioji qq (kvantilių palyginimo) diagrama lygina duomenis su teoriniu normaliuoju skirstiniu. Jei duomenys daugmaž normalieji, taškai išsidėsto daugmaž į vieną liniją ties grafiko įstrižaine. Nuokrypis nuo šios kreivės rodo nuokrypį nuo normalumo. Duomenys tie patys, kaip ir 3.7-3.12 paveiksluose: A-D normalieji duomenys, E – dvi viršūnės, F – dešinioji asimetrija, G – kairioji asimetrija, H – dvi galimos išskirtys. Q-Q grafike teorinis skirstinys ne būtinai turi būti normalusis (peržvelkite kelis galimus standartinius pasirinkimus pav. 7.12). Pav. 7.12: Naudodamiesi q-q diagrama, duomenų pasiskirstymą galime lyginti su įvairiais modeliais, ne tik normaliuoju. QQ grafikus ne pogrupiais galima nubraižyti naudojant šias R Commander meniu komandas: Rcmdr meniu → KMggplot2 → QQ plot… (pav. 7.9); Rcmdr meniu → graphs → Quantile comparison plot… (pav. 7.10 ir 7.12). Užduotis 7.5 Užsikraukite duomenis: data(npk); data(swiss): Daroma prielaida, kad duomenų lentelės „npk“ kintamojo „yield“ reikšmių pasiskirstymas yra normalusis. Grafiškai įvertinkite, ar ši prielaida yra pagrįsta? Grafiškai įvertinkite ir išvardinkite kintamuosius iš duomenų lentelės „swiss“, kurių reikšmės yra pasiskirsčiusios daugmaž normaliai, o kurių – ne normaliai. 7.7.2 Statistiniai kriterijai normalumui tikrinti Yra keletas kriterijų („testų“, angl. statistical test) pasiskirstymo normalumui tikrinti: Shapiro-Wilk’o, Anderson-Darling, Kolmogorovo-Smirnovo su Lilliefor’o pataisa ir kiti. Tikrinant prielaidą reikia pasirinkti tik vieną. Bet kurio iš šių kriterijų taikymo rezultatą vertiname pagal tikimybę, vadinama p reikšme (p-value). Šių testų atveju, p reikšmė yra tikimybė gauti tokio dydžio nuokrypį nuo normaliojo pasiskirstymo, kokį stebime savo duomenyse, arba dar didesnį, jei GA, iš kurios sudarėme imtį, pasiskirstymas iš tiesų yra normalusis. T. y., kokia tikimybė gauti tokį nuokrypį nuo normalumo arba dar didesnį, jei iš tiesų pasiskirstymas yra normalusis. Kiekvienas iš testų (statistinių kriterijų) skirtingai apibrėžia, kas yra nuokrypis nuo normalumo. Įprastai reikšmingumo lygmuo (tikimybė \\(\\alpha\\)) – riba, kurią pasirenkame spręsdami – yra lygi \\(\\alpha = 0.05\\). Jei imtis didelė, o analizės metodas, kurį naudosime, nėra labai jautrus mažam ar vidutiniam nuokrypiui nuo normalumo, gali būti naudojamas ir mažesnis reikšmingumo lygmuo. Įprastai sakoma, kad: jei \\(p\\ge 0.05\\), duomenų pasiskirstymo nuokrypis nuo normaliojo modelio yra statistiškai nereikšmingas, normalumo prielaida tenkinama; jei \\(p &lt; 0.05\\), duomenų pasiskirstymo nuokrypis nuo normaliojo modelio yra statistiškai reikšmingas, normalumo prielaida netenkinama. 7.7.3 Normalumo tikrinimas pogrupiams Įprastai duomenų normalumą reikia tikrinti ne visiems turimiems duomenims iš karto, o kiekvienam tiriamam pogrupiui atskirai. Tam tinkamos papildinio RcmdrPlugin.biostat funkcijos, kurios yra šiame meniu lange: Rcmdr meniu → BioStat → Tests → Normality tests. Normalumą tikrinsime: Shapiro-Wilk’o testu arba Kolmogorovo-Smirnovo testu su Lilliefor’o pataisa bei Kvantilių-kvantilių (q-q) grafiku (tad būtinai uždėkite varnelę ties „Draw a qq-plot“). Užduotis 7.6 Užsikraukite duomenis „barley“ (miežiai) iš paketo „lattice“ (kodas žemiau). Nustatykite, ar kintamojo „derlius“ („yield“) reikšmių pasiskirstymas yra normalusis kiekviename iš pogrupių. Į pogrupius skirstykite pagal: įvairovę (kintamasis „variety“); vietoves (kintamasis „site“); metus (kintamasis „year“). Sąsiuvinyje apsirašykite savo pastebėjimus. data(&quot;barley&quot;, package = &quot;lattice&quot;) Užduotis 7.7 Užsikraukite duomenis „cabbages“ iš paketo „MASS“. Skirstydami į pogrupius (žiūr. 3 punktą), nustatykite, ar šių kintamųjų reikšmės skirstosi normaliai: svoris (HeadWt); vitamino C kiekis (VitC ). Į pogrupius skirstykite: pagal veisles (Cult); pagal sėjos dieną (Date); iš karto ir pagal veislę, ir pagal sėjos dieną. Sąsiuvinyje apsirašykite savo pastebėjimus. 7.7.4 Tikimybių-tikimybių (pp) diagrama Tikimybių palyginimo (tikimybių-tikimybių, pp) diagrama interpretuojama taip pat, kaip ir qq diagrama. Tik joje atidedami ne kvantiliai, o teorinės ir empirinės tikimybės (pav. 7.13). Pav. 7.13: PP diagramos pavyzdys. 7.7.5 Kitų tipų grafikai Kitų tipų grafikai, skirti palyginti empirinius duomenis su teoriniu modeliu bus pateikti kituose šių pratybų poskyriuose kaip pavyzdžiai. Daugumoje šių grafikų siekiama rasti tokį modelį, kur teorinių ir empirinių duomenų linijos/taškai/stulpeliai labiausiai sutampa (pvz., pav. 7.14). Pav. 7.14: Grafiko, kuriame lyginama teorinė (raudona linija) ir empirinė (juodi taškai) kreivės, pavyzdys. \\(CDF\\) – tikimybių pasiskirstymo funkcija (angl. cumulative distribution function). 7.8 Skaitiniai būdai modelio ir duomenų suderinamumui vertinti Statistikų (kriterijų), pagal kurias galima vertinti empirinių duomenų ir teorinio modelio atitikimo „gerumą“, yra daug (pvz., \\(\\chi^2\\) statistika, Kolmogorovo-Smirnovo D statistika, AIC – Akaikės informacinis kriterijus, BIC – Bajeso informacinis kriterijus ir kitos). Jos turi savų pliusų ir savų minusų priklausomai nuo duomenų savybių. Visgi, kaip žinoti, kuris modelis iš kelių lyginamų yra tinkamesnis, jei sprendžiame pagal skaitinius kriterijus? Bendras principas yra toks: įprastai statistikos (kriterijai) tam tikru būdu vertina skirtumus tarp teorinių modelių ir empirinių duomenų, tad kuo statistikos reikšmė arčiau nulio (t. y., kuo skirtumas yra mažesnis), tuo duomenys geriau atitinka modelį. Įprastai kuo statistikos ar kriterijaus, vertinančio modelio ir duomenų suderinamumą, reikšmė arčiau nulio, tuo duomenys labiau suderinami su modeliu. Prisiminkite, kad kriterijaus statistika ir statistinio testo p reikšmė – tai du skirtingi dalykai. Pavyzdys 1. Lyginami duomenys ir tolydieji skirstiniai („Modelis-1“, „Modelis-2“, „Modelis-3“). Gaunami rezultatai: ## Goodness-of-fit statistics ## Modelis-1 Modelis-2 Modelis-3 ## Kolmogorov-Smirnov statistic 0.1138 0.412 0.165 ## Cramer-von Mises statistic 0.0695 3.884 0.206 ## Anderson-Darling statistic 0.3590 18.609 1.160 ## ## Goodness-of-fit criteria ## Modelis-1 Modelis-2 Modelis-3 ## Akaike&#39;s Information Criterion 486 1022 496 ## Bayesian Information Criterion 490 1027 501 Žymėjimai: „Goodness-of-fit“ – suderinamumas. Labiausiai su duomenimis suderinamas „Modelis-1“, prasčiausiai – „Modelis-2“. Pavyzdys 2. Lyginami duomenys ir diskretieji skirstiniai („Modelis-A“, „Modelis-B“, „Modelis-C“). Gaunami rezultatai: ## Chi-squared statistic: 8.2 6.4 147 ## Degree of freedom of the Chi-squared distribution: 4 4 4 ## Chi-squared p-value: 0.086 0.17 8.1e-31 ## Chi-squared table: ## obscounts theo Modelis-A theo Modelis-B theo Modelis-C ## &lt;= 1 31 35 25 84 ## &lt;= 2 43 42 43 28 ## &lt;= 3 47 45 53 21 ## &lt;= 4 35 35 43 16 ## &lt;= 5 32 22 24 12 ## &gt; 5 12 21 12 39 ## ## Goodness-of-fit criteria ## Modelis-A Modelis-B Modelis-C ## Akaike&#39;s Information Criterion 756 760 921 ## Bayesian Information Criterion 759 763 925 Iš šių rezultatų matome, kad kiekvienam modeliui („Modelis-A“, „Modelis-B“, „Modelis-C“) \\(\\chi^2\\) statistikos reikšmės yra atitinkamai \\(8.16\\), \\(6.38\\) bei \\(147\\), o \\(\\chi^2\\) suderinamumo kriterijaus (statistinio testo) p reikšmės yra atitinkamai \\(0.0859\\), \\(0.172\\) bei \\(8.09\\cdot 10^{-31}\\). BIC ir AIC kriterijų reikšmes taip pat matome. Žymėjimai: „obscounts“ – empiriniai dažniai (angl. observed counts), „theo“ – teoriniai dažniai. Pagal \\(\\chi^2\\) statistikos reikšmę galime vertinti, kad empiriniai duomenys ir „Modelis-B“ suderinami labiausiai, o „Modelis-C“ – prasčiausiai (turbūt, apskritai nesuderinamas). Nors skirtumas tarp suderinamumo su A ir B modeliais – ganėtinai menkas. Funkcijos, kurios sugeneravo šiuos pavyzdžius, aprašomos skyriuje „Palyginimas naudojant skaitines statistikas“. Užduotis 7.8 Duomenims bandoma parinkti tinkamą tikimybinį modelį. Kiekvienam modeliui (pažymėkime juos raidėmis nuo A iki E) \\(\\chi^2\\) statistikos reikšmės yra 264, 12.6, 23, 103, 22.3. Išrikiuokite modelius nuo labiausiai iki prasčiausiai suderinamo su duomenimis. Kitiems dviems modeliams Kolmogorovo-Smirnovo D statistikos reikšmės yra 0.35 ir 0.115. Kuris modelis labiau suderinamas su duomenimis? 7.9 Statistinio modelio parinkimas duomenims Skirstinio parinkimas – tai procedūra, kuomet statistiniai duomenys aprašomi geriausiai juos atitinkančiu teoriniu modeliu – skirstiniu. Modelio parinkimas prasideda tuo, kad pirmiausia nustatome, kokį atsitiktinį dydį modeliuosime – tolydųjį ar diskretųjį. Tada nusprendžiame, kurie skirstiniai (normalieji, binominiai, geometriniai ar kiti) geriausiai tiktų mūsų duomenims ir iškeltai mokslinei problemai spręsti. Išsirinkę skirstinius, apskaičiuojame tinkamiausius jų parametrus (pvz., \\(\\mathcal{N}(257; 35)\\), \\(\\mathcal{B}(7; 0,22)\\), \\(\\mathcal{P}(3)\\)). Galiausiai grafiškai ir/arba pagal suderinamumo kriterijus nustatome, ar bent vienas teorinis modelis pakankamai gerai aprašo duomenis, ir jei taip, tai kuris. Kai modelis sudarytas, juo galime naudotis. Norint išsirinkti tinkamą modelį, patartina išbandyti kelis variantus ir pažiūrėti, kuriuo atveju turimi empiriniai duomenys labiausiai atitinka teorinius. Gali būti, kad vienodai gerai tiks keli variantai. Tokiu atveju, rinkitės lengviausiai interpretuojamą modelį. Deja, gali netikti nei vienas. Prieš pereidami prie kito skyriaus, panagrinėkime diskrečiųjų duomenų pavyzdį, kuriems modelis parinktas naudojantis teorinėmis žiniomis ir literatūra (paveikslas 7.15). Duomenys – šešis vaikus auginančių šeimų apklausos rezultatai. Tyrimo metu siekta nustatyti, kiek berniukų auga tokiose šeimose (tiksliau, įvertinti berniukų skaičiaus pasiskirstymą). Teoriškai tokiai situacijai galima naudoti binominį modelį, pvz., \\(\\mathcal{B}(6; 0,51)\\). Modelio parametras \\(n = 6\\) parinktas todėl, kad šeimose yra 6 vaikai, tad vienoje šeimoje gali būti iki 6 berniukų, o parametras \\(p = 0,51\\) (tikimybė, kad gims berniukas), sakykime, paimtas iš literatūros. Jei vieno ar abiejų parametrų nežinome, juos galime pasirinkti grįsdami teorinėmis žiniomis, pvz., perskaityta literatūra, arba apskaičiuoti iš duomenų naudodami tolimesniuose skyriuose aprašytus metodus. Pav. 7.15: Pavyzdys: dešimties šeimų, kuriose auga šeši vaikai, apklausos rezultatai, jų apibendrinimas ir palyginimas su teoriniu modeliu. Duomenų lentelė – tai pradiniai duomenys. Dažnių lentelė – empirinių duomenų skirstinys. Grafike – empirinių santykinių dažnių (juodos linijos) palyginimas su teorinio binominio modelio \\(\\mathcal{B}(6; 0,51)\\) tikimybėmis (raudonos linijos). Galima numanyti, kad turint didesnę imtį empiriniai duomenys geriau atitiks modelį. Praktinė pastaba apie modelių parinkimą Turimiems duomenims modelius galima parinkti visiškai „mechaniškai“ naudojantis įvairiais algoritmais bei statistinių paketų funkcijomis. Visgi prisiminkite, kad tai tik įrankiai, padedantys išspręsti jūsų tyrimo metu suformuluotą mokslinę problemą. Tam, kad modelis būtų prasmingas, tiek modelio, tiek jo parametrų prasmę reiktų suprasti ir interpretuoti savo tyrimo kontekste (kartais tam gali prireikti papildomos literatūros analizės). Ši idėja glaudžiai siejasi su kita mintimi: jei galite rinktis iš kelių panašaus „gerumo“ modelių, rinkitės paprastesnį ir lengviau interpretuojamą. 7.9.1 Paketas fitdistrplus teoriniam modeliui parinkti Duomenims teorinį modelį galima parinkti naudojant funkciją fitdist() iš paketo fitdistrplus. Ši funkcija tinka ir tolydiesiems, ir diskretiesiems skirstiniams parinkti. Darbo eiga daugmaž tokia: # Užkraunamas paketas library(fitdistrplus) # Įkeliami duomenys data(npk) dplyr::glimpse(npk) # Pasirenkamas analizuojamas kintamasis derlius &lt;- npk$yield # (Papildomas nebūtinas žingsnis) # Aprašomas skirstinys. # Pagal asimetrijos ir eksceso koeficientus nubraižoma, į kokį teorinį skirstinį # panašus mūsų duomenų pasiskirstymas. descdist(derlius, discrete = FALSE, boot = 1000) # Pasirenkamas skirtinio tipas. # Tada programa apskaičiuoja labiausiai tinkančius parametrus. # Sukuriamas modelio objektas. modelis_normal &lt;- fitdist(derlius, distr = &quot;norm&quot;) # Modelio suvestinė summary(modelis_normal) # Patikrinama, kokie modelio parametrai parinkti coef(modelis_normal) # Skaitinės modelio ir duomenų suderinamumo charakteristikos gof_rez &lt;- gofstat(modelis_normal) gof_rez # Chi-kvadratu suderinamumo testo p reikšmė. # Tinka tik didelėms imtims (didesnėms už 30), # jei p &lt; 0.05 - skirtumas tarp modelio ir duomenų statistiškai reikšmingas. # Apie praktinį reikšmingumą spręsti pagal grafikus. gof_rez$chisqpvalue # Grafinis palyginimas plot(modelis_normal) # Linijos turi būti panašios Dabar panagrinėkime šių funkcijų rezultatus. Užsikraukime paketą: library(fitdistrplus) Įsikeliame duomenis. Pavyzdyje duomenys iš paketo. Darbinėje situacijoje įprastai duomenis įsikelsime iš duomenų bylos. Įsikėlę duomenis peržiūrime naudodami glimpse ar panašią funkciją. data(npk) dplyr::glimpse(npk) ## Observations: 24 ## Variables: 5 ## $ block &lt;fct&gt; 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5,... ## $ N &lt;fct&gt; 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1,... ## $ P &lt;fct&gt; 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0,... ## $ K &lt;fct&gt; 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1,... ## $ yield &lt;dbl&gt; 49.5, 62.8, 46.8, 57.0, 59.8, 58.5, 55.5, 56.0, 62.8, 55... Paketo fitdistrplus funkcijos skirtos darbui su duomenų eilutėmis (vektoriais), o ne duomenų lentelėmis, kaip tidyverse sistemoje. Analizei naudosime kintamojo yield iš duomenų lentelės npk reikšmes, tad jas priskirsime duomenų eilutei derlius: derlius &lt;- npk$yield Sukuriame normaliojo ats.d. modelį ir pavadiname „modelis_normal“. Pavadinti galime kaip norime, bet rekomenduojamas prasmingas pavadinimas. modelis_normal &lt;- fitdist(derlius, distr = &quot;norm&quot;) Galime pasirinkti ir kitą modelį, parašydami trumpąjį jo pavadinimą. Pavadinimų pavyzdžiai pateikti lentelėse 7.2, 7.3. Jei norite daugiau pavyzdžių ir paaiškinimų, pastudijuokite funkcijos dokumentaciją surinkę komandą ?fitdist. Toliau dirbsime su sukurtuoju modeliu „modelis_normal“ ir tikrinsime, kaip gerai duomenys atitinka šį modelį. Modelio suvestinę atlieka funkcija summary(): summary(modelis_normal) ## Fitting of the distribution &#39; norm &#39; by maximum likelihood ## Parameters : ## estimate Std. Error ## mean 54.875000 1.2334776 ## sd 6.042782 0.8722003 ## Loglikelihood: -77.22727 AIC: 158.4545 BIC: 160.8106 ## Correlation matrix: ## mean sd ## mean 1.00000e+00 -3.82215e-09 ## sd -3.82215e-09 1.00000e+00 Pirmame sakinyje, prasidedančiame žodžiais „Fitting of the distribution“, nurodomas taikytas modelis (t. y., „norm“) ir parametrų apskaičiavimo metodas („maximum likelihood“ – didžiausio tikėtinumo metodas). Suvestinės skiltyje „Parameters:“ matome apskaičiuotus normaliojo skirstinio parametrų (mean – vidurkis ir sd – standartinis nuokrypis) įverčius ir jų standartines paklaidas (standartinės paklaidos yra šių įverčių standartiniai nuokrypiai). Taip pat kitus modelio „gerumo“ įverčius, kurių nenagrinėsime. Koreliacijos matricos („Correlation matrix:“) taip pat nenagrinėsime. Jei jus domina tik parinkti modelio parametrai, o ne visa suvestinė, naudokite funkciją coef(): coef(modelis_normal) ## mean sd ## 54.875000 6.042782 Įvairios statistikos, pagal kurias įvertinama, kaip gerai duomenys atitinka modelį, gali būti gautos naudojant funkciją gofstat() (nuo angl. goodness-of-fit statistics): gof_rez &lt;- gofstat(modelis_normal) gof_rez ## Goodness-of-fit statistics ## 1-mle-norm ## Kolmogorov-Smirnov statistic 0.09158520 ## Cramer-von Mises statistic 0.02949152 ## Anderson-Darling statistic 0.20037302 ## ## Goodness-of-fit criteria ## 1-mle-norm ## Akaike&#39;s Information Criterion 158.4545 ## Bayesian Information Criterion 160.8106 Tinkamiausios statistikos parenkamos pagal tai, kokį teorinį modelį (pvz., diskretųjį ar tolydųjį) taikome, nebent nurodysite kitaip (kaip tai padaryti skaitykite įvedę komandą ?gofstat). Įprastai norime, kad šių statistikų reikšmės būtų kuo arčiau nulio. Chi-kvadratu \\((\\chi^2)\\) suderinamumo testas (angl. chi-square goodness-of-fit test) skirtas patikrinti hipotezę, ar duomenys ir modelis pakankamai gerai suderinami. Apie šį statistinį kriterijų plačiau rašoma Čekanavičiaus ir Murausko vadovėlyje „Statistika ir jos taikymai I“. Jei tenkinamos \\(\\chi^2\\) kriterijui taikyti reikiamos prielaidos, didelė p reikšmė \\((p&gt;0,05)\\) rodo, kad duomenys ir modelis pakankamai gerai suderinami. round(gof_rez$chisqpvalue, 3) ## [1] 0.383 Grafiniam teorinio modelio ir empirinių duomenų palyginimui gali būti naudojamos funkcijos plotdist() arba tiesiog plot(). Taip bus nubraižomi 4 tipų grafikai: plot(modelis_normal) Šiame pavyzdyje raudonai žymima teorinė kreivė. Daugiau informacijos apie galimus parametrus skaitykite funkcijos dokumentacijoje (?plotdist). Kiekvieno tipo grafiką galima nubraižyti atskirai naudojant funkcijas cdfcomp (sukauptojo santykinio dažnio diagrama lyginama su teorine tikimybių pasiskirstymo kreive), denscomp (teorinis tikimybių tankio grafikas lyginamas su empirine histograma), ppcomp (tikimybių-tikimybių – p-p – diagrama) ir qqcomp (kvantilių-kvantilių – q-q – diagrama). Šių funkcijų parametras addlegend kontroliuoja, ar braižyti legendą. cdfcomp(modelis_normal, addlegend = FALSE) denscomp(modelis_normal) ppcomp(modelis_normal, addlegend = FALSE) qqcomp(modelis_normal, addlegend = FALSE) Analogiškai galime sukurti ir log-normalųjį ar kitokį modelį. Log-normaliąjam modeliui visos kintamojo reikšmės privalo būti teigiamos: \\((x_i&gt;0)\\). Užduotis 7.9 Naudodami kodą: fit_lognorm &lt;- fitdist(derlius, distr = &#39;lnorm&#39;) Sukurkite log-normalųjį modelį ir jį patyrinėkite aukščiau išvardintomis funkcijomis (summary(), plot() ir kitomis). Nuspręskite, kuris modelis – normalusis ar log-normalusis – šiems duomenims labiau tinka? (Tam papildomai reikia susikurti normalųjį modelį.) 7.9.2 Kelių modelių palyginimas (paketas fitdistrplus) Palyginimas grafiškai Duomenys toxocara – salose gyvenančių laukinių kačių parazitų tyrimas. data(toxocara) parazitu_skaicius &lt;- toxocara$number hist(parazitu_skaicius) summary(parazitu_skaicius) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 0.000 2.000 8.679 9.000 75.000 Grafiškai patikrinkime, kuris teorinis modelis labiau tinka parazitų skaičių katėse aprašyti – Puasono ar neigiamas binominis? # Modelių kūrimas model_p &lt;- fitdist(parazitu_skaicius, &quot;pois&quot;) model_nb &lt;- fitdist(parazitu_skaicius, &quot;nbinom&quot;) # Sudarome modelių sąrašą modeliu_sarasas &lt;- list(model_p, model_nb) # Susirašome modelių pavadinimus pavadinimai &lt;- c(&quot;Puasono&quot;, &quot;Neigiamas binominis&quot;) Palyginame grafiškai: plot(model_p) plot(model_nb) Lyginame grafiškai viename grafike (naudojant firdistrplus, diskretiesiems duomenims yra mažiau grafinio atvaizdavimo galimybių nei tolydiesiems): cdfcomp(modeliu_sarasas, legendtext = pavadinimai) Atrodo, kad neigiamas binominis modelis (žalia linija) labiau atitinka empirinius duomenis (juodi taškai), nei Puasono modelis (raudona linija). qqcomp(modeliu_sarasas, legendtext = pavadinimai) Jei išbandytumėte, pastebėtumėte, kad dvi kitos funkcijos nėra tinkamos mūsų turimiems diskretiesiems duomenims lyginti su teoriniais modeliais. denscomp(modeliu_sarasas, legendtext = pavadinimai, demp = TRUE) ppcomp(modeliu_sarasas, legendtext = pavadinimai) Palyginimas naudojant skaitines statistikas Jei norite lyginti pagal skaitines statistikas, galite naudoti funkciją gofstat(): gofstat(modeliu_sarasas) ## Chi-squared statistic: 31256.96 7.48606 ## Degree of freedom of the Chi-squared distribution: 5 4 ## Chi-squared p-value: 0 0.1123255 ## the p-value may be wrong with some theoretical counts &lt; 5 ## Chi-squared table: ## obscounts theo 1-mle-pois theo 2-mle-nbinom ## &lt;= 0 14 0.009014207 15.295027 ## &lt;= 1 8 0.078236512 5.808596 ## &lt;= 3 6 1.321767215 6.845015 ## &lt;= 4 6 2.131297776 2.407815 ## &lt;= 9 6 29.827829221 7.835196 ## &lt;= 21 6 19.626223732 8.271110 ## &gt; 21 7 0.005631339 6.537242 ## ## Goodness-of-fit criteria ## 1-mle-pois 2-mle-nbinom ## Akaike&#39;s Information Criterion 1017.067 322.6882 ## Bayesian Information Criterion 1019.037 326.6288 Tam, kad būtų paprasčiau suprasti, kur kuris modelis, galite nurodyti pavadinimus: gofstat(modeliu_sarasas, fitnames = pavadinimai) ## Chi-squared statistic: 31256.96 7.48606 ## Degree of freedom of the Chi-squared distribution: 5 4 ## Chi-squared p-value: 0 0.1123255 ## the p-value may be wrong with some theoretical counts &lt; 5 ## Chi-squared table: ## obscounts theo Puasono theo Neigiamas binominis ## &lt;= 0 14 0.009014207 15.295027 ## &lt;= 1 8 0.078236512 5.808596 ## &lt;= 3 6 1.321767215 6.845015 ## &lt;= 4 6 2.131297776 2.407815 ## &lt;= 9 6 29.827829221 7.835196 ## &lt;= 21 6 19.626223732 8.271110 ## &gt; 21 7 0.005631339 6.537242 ## ## Goodness-of-fit criteria ## Puasono Neigiamas binominis ## Akaike&#39;s Information Criterion 1017.067 322.6882 ## Bayesian Information Criterion 1019.037 326.6288 Atrodo, neigiamas binominis skirstinys tinka labiau. Kaip apie tai nusprendžiau rašoma 7.8 skyriuje. 7.9.3 Jei duomenys pateikti kaip dažnių lentelė (fitdistrplus) Jei dirbate su diskrečiaisiais duomenimis ir turite dažnių lentelę, tada ją reikia pasiversti į vektorių naudojant funkciją rep(). Pavyzdys. Nuskaitome duomenis: library(data.table) duomenys &lt;- fread( &quot;x dažnis 0 26 1 43 2 48 3 42 4 29 5 6 6 5 8 1&quot;) Dažnių lentelę pasiverčiame į duomenų eilutę (vektorių): vektorius &lt;- rep(x = duomenys$x, times = duomenys$dažnis) Toliau su duomenis analizuojame įprastiniu būdu. model_poisson &lt;- fitdist(vektorius, distr = &quot;pois&quot;) plot(model_poisson) summary(model_poisson) ## Fitting of the distribution &#39; pois &#39; by maximum likelihood ## Parameters : ## estimate Std. Error ## lambda 2.245 0.1059481 ## Loglikelihood: -358.8056 AIC: 719.6111 BIC: 722.9094 coef(model_poisson) ## lambda ## 2.245 Užduotis 7.10 Duota dažnių lentelė (k – kintamojo reikšmės, Freq – dažnis). Ją reikia pasiversti į vektorių ir patikrinti, kuris modelis – Puasono, binominis ar neigiamas binominis – labiau tinkamas. Naudokite paketą fitdistrplus. k Freq 0 79 1 72 2 38 3 10 5 1 Pastaba: jei modeliuojant binominį skirstinį kils nesklandumų, jo nebemodeliuokite. Darbui su kategoriniais duomenimis patogesnė funkcija vcd::goodfit(). Deja, šių pratybų metu paketo vcd funkcijų nenagrinėsime. Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["pi.html", "8. Pasikliautinieji intervalai (PI) 8.1 Nubraižyti lentele pateiktus PI 8.2 Klasikiniai metodai PI skaičiuoti", " 8. Pasikliautinieji intervalai (PI) Statistinės išvados yra pagal imties (kuri yra mažesnė už generalinę aibę) duomenis padarytos išvados apie visą generalinę aibę (GA). Tam, kad išvados būtų teisingos, – pirmiausia, imtis privalo būti reprezentatyvi: sudaryta tinkamu būdu taip, kad atspindėtų esmines generalinės aibės savybes. Tada pagal duomenis ir iškeltą klausimą reikia pasirinkti tinkamą analizės metodą. Atkreipkite dėmesį, kad daugelis statistikos metodų sukurti darant prielaidą, kad GA yra be galo didelė. Tad mūsų GA turi būti pakankamai didelė, kad ši prielaida galiotų. Statistinės išvados daromos: tikrinant statistines hipotezes (taikant statistinius kriterijus); sudarant įverčius (taškinius įverčius ir pasikliauties intervalus). Pasikliauties intervalai dar vadinami pasikliautinaisiais intervalais. Šio užsiėmimo metu nagrinėsime pasikliauties intervalų (PI) sudarymo metodus. Darbui reikalingi R paketai: data.table, DescTools, pander, biostat, ggplot2, tidyverse. # Atsisiųskite iš saugyklos „GitHub“: devtools::install_github(&quot;GegznaV/biostat&quot;, dependencies = TRUE) Korektiško vidurkio pasikliauties intervalo skaičiavimo žingsniai: Nusibraižome duomenis, įsitikiname, kad vidurkis yra prasmingas; Patikriname, ar nepažeidžiamos prielaidos (pvz., ar duomenys skirstosi normaliai, ar jų pakankamai daug ir kt.), kuriomis grindžiamas statistinis modelis (intervalo skaičiavimo būdas); Skaičiuojame pasikliauties intervalą. Šie žingsniai pritaikomi ir kitų, ne tik vidurkio, pasikliauties intervalų skaičiavimui. Svarbu nusibraižyti duomenis, patikrinti prielaidas ir tik po to atlikti skaičiavimus. 8.1 Nubraižyti lentele pateiktus PI Dažna užduotis analizuojant duomenis – vizualizuoti pasikliauties intervalus. Sakykime, kad duota lentelė, kurioje taškinis vidurkio įvertis ir jo pasikliauties intervalas. Šiuos duomenis reikia įsikelti į „R“ ir nubraižyti. Lentelė 8.1: Duomenys, kuriuos norime nubraižyti (1). Vidurkis PIviršutinis PIapatinis 162.0 122.3 182.8 Lentelė pateikta tinklapyje, tad ją patogu nukopijuoti ir nuskaityti naudojant funkciją fread() iš paketo data.table. Užkraukime reikiamus paketus. library(data.table) library(tidyverse) Sys.setlocale(locale = &quot;Lithuanian&quot;) Po to parašykime komandą fread(&quot;&quot;), jos skliaustuose padėkime kabutes. Tada pele pažymėkite visą lentelės 8.1 turinį, jį nukopijuokite ir įklijuokite į dokumentą tarp kabučių kaip rodoma pavyzdyje žemiau. Galime pridėti papildomų tarpų, kad sulygiuotume stulpelius, bet tai nėra būtina. Įvykdykime komandą ir patikrinkime, ar duomenys nuskaityti teisingai. duomenys1 &lt;- fread( &quot;Vidurkis PIviršutinis PIapatinis 162.0 122.3 182.8&quot;) glimpse(duomenys1) ## Observations: 1 ## Variables: 3 ## $ Vidurkis &lt;dbl&gt; 162 ## $ PIviršutinis &lt;dbl&gt; 122.3 ## $ PIapatinis &lt;dbl&gt; 182.8 duomenys1 ## Vidurkis PIviršutinis PIapatinis ## 1: 162 122.3 182.8 Kopijuojant lentelę iš tinklapio, stulpelių skirtukai yra tabuliacijos, kurias fread() atpažįsta automatiškai. Todėl lentelę nuskaito teisingai. Dabar šiuos duomenis atvaizduokime naudodami ggplot2. Paklaidų ir intervalų braižymui naudinga funkcija geom_errorbar(), kuriai reikia nurodyti apatinę ir viršutinę ribas, kurios surašytos atskirame duomenų lentelės stulpelyje. Turime tik vieną grupę, todėl x’ui suteikiame bet kokį pavadinimą kabutėse. ggplot(duomenys1, aes(x = &quot;duomenys&quot;)) + geom_point(aes(y = Vidurkis)) + geom_errorbar(aes(ymin = PIviršutinis, ymax = PIapatinis)) Šiek tiek padailinkime grafiką: ggplot(duomenys1, aes(x = &quot;duomenys&quot;)) + geom_point(aes(y = Vidurkis), size = 4) + geom_errorbar(aes(ymin = PIviršutinis, ymax = PIapatinis), width = .1, size = 1) + lims(y = c(100, 200)) + labs(x = &quot;&quot;) Apibendrinančias statistikas, tokias kaip vidurkis ar mediana, duomenų vizualizavimo ekspertai rekomenduoja atvaizduoti taškais ar linijomis, bet ne stulpeliais. Vidurkius ir medianas stulpeliais atvaizduoti nekorektiška, nes taip akcentuojama apatinė matavimo skalės dalis, kur duomenų galbūt nėra, ir ignoruojama viršutinė dalis, kur duomenys yra. Deja, centro padėties suvestinų atvaizdavimo būdas stulpeliais plačiai paplitęs. Lentelė 8.2: Duomenys, kuriuos norime nubraižyti (2): vidurkis ir jo pasikliautinasis intervalas. Sveikosios ir dešimtosios skaičiaus dalies skirtukas – kablelis. Vidurkis PIvirš PIapat 42,53 41,02 44,01 Jei sveikosios ir dešimtosios dalies skirtukas yra kablelis (pavyzdys – lentelė 8.2), programa automatiškai jo neatpažįsta, tad tai reikia nurodyti naudojant parametrą dec: duomenys2 &lt;- fread(dec = &quot;,&quot;, &quot;Vidurkis PIvirš PIapat 42,53 41,02 44,01&quot;) glimpse(duomenys2) ## Observations: 1 ## Variables: 3 ## $ Vidurkis &lt;dbl&gt; 42.53 ## $ PIvirš &lt;dbl&gt; 41.02 ## $ PIapat &lt;dbl&gt; 44.01 duomenys2 ## Vidurkis PIvirš PIapat ## 1: 42.53 41.02 44.01 Užduotis 8.1 Ką tik nuskaitytus duomenis „duomenys2“ atvaizduokite grafiškai. Lentelė 8.3: Duomenys, kuriuos norime nubraižyti (3): vidurkis ir jo pasikliautinasis intervalas grupėms. Grupė Vidurkis PIviršutinis PIapatinis Balti 25 22 28 Žali 19 17 24 Raudoni 45 30 52 Geltoni 33 30 36 Jei norime, kad fread() tekstinius kintamuosius nuskaitytų kaip kategorinius, reikia naudoti parametrą stringsAsFactors = TRUE: duomenys3 &lt;- fread(stringsAsFactors = TRUE, &quot;Grupė Vidurkis PIviršutinis PIapatinis Balti 25 22 28 Žali 19 17 24 Raudoni 45 30 52 Geltoni 33 30 36&quot;) glimpse(duomenys3) ## Observations: 4 ## Variables: 4 ## $ Grupė &lt;fct&gt; Balti, Žali, Raudoni, Geltoni ## $ Vidurkis &lt;int&gt; 25, 19, 45, 33 ## $ PIviršutinis &lt;int&gt; 22, 17, 30, 30 ## $ PIapatinis &lt;int&gt; 28, 24, 52, 36 duomenys3 ## Grupė Vidurkis PIviršutinis PIapatinis ## 1: Balti 25 22 28 ## 2: Žali 19 17 24 ## 3: Raudoni 45 30 52 ## 4: Geltoni 33 30 36 Užduotis 8.2 Ką tik nuskaitytus duomenis nuskaitykite dar kartą naudodami stringsAsFactors = FALSE, rezultatą pavadinkite „duomenys3chr“. Palyginkite, kuo skiriasi „duomenys3“ ir „duomenys3chr“. Bazinis kodas atvaizduoti duomenis. Pastebėkite, kad x ašyje išdėstytos stulpelio Grupė reikšmės, todėl šio stulpelio pavadinimas rašomas ne kabutėse. ggplot(duomenys3, aes(x = Grupė)) + geom_point(aes(y = Vidurkis)) + geom_errorbar(aes(ymin = PIviršutinis, ymax = PIapatinis)) Pagražintas grafikas: ggplot(duomenys3, aes(x = Grupė, color = Grupė)) + geom_errorbar(aes(ymin = PIviršutinis, ymax = PIapatinis), width = 0.2, size = 1) + geom_point(aes(y = Vidurkis), fill = &quot;black&quot;, size = 2, shape = 23) + labs(title = &quot;Vidurkis ir jo 95% pasikliauties intervalas&quot;) Užduotis 8.3 Lentelė 8.4: Nuskaitykite ir vizualizuokite duomenis. Lentelė 8.5: Nuskaitykite duomenis. Proporcijas ir jų pasikliauties intervalus atvaizduokite stulpeliais (geom_col()). Stulpelio spalva turi būti parinkta pagal medžio rūšį (Tree), o stulpelio apvadas privalo būti juodas. Įvardinkite, trūkumus, kuriuos pastebite šioje lentelėje. Lentelė 8.4: Plauko ilgio pasiskirstymas pagal spalvas. Spalva Vidurkis PI_viršutinis PI_apatinis Juoda 5,9 5,7 6,4 Ruda 5,5 5,2 5,8 Gelsva 5,3 4,9 5,6 Lentelė 8.5: Rūšinis medžių pasiskirstymas miške. Tree Count Total Proportion lower_ci upper_ci 1 Douglas fir 70 156 0.4487 0.369115906 0.53030534 2 Ponderosa pine 79 156 0.5064 0.425290653 0.58728175 3 Grand fir 3 156 0.0192 0.003983542 0.05516994 4 Western larch 4 156 0.0256 0.007029546 0.06434776 Jei lentelė 8.5 būtų pateikta tokiu pavidalu, kokį matote žemiau (be tabuliacijų), tada stulpelių, kuriuose yra keli žodžiai atskirti tarpu, reikšmes privalėtumėte rašyti kabutėse, pvz., &quot;Douglas fir&quot; arba \\&quot;Douglas fir\\&quot;. Kitu atveju duomenys būtų nuskaityti neteisingai arba apskritai nebūtų nuskaityti. ## V1 Tree Count Total Proportion lower_ci upper_ci ## 1: 1 Douglas fir 70 156 0.4487 0.369115906 0.53030534 ## 2: 2 Ponderosa pine 79 156 0.5064 0.425290653 0.58728175 ## 3: 3 Grand fir 3 156 0.0192 0.003983542 0.05516994 ## 4: 4 Western larch 4 156 0.0256 0.007029546 0.06434776 Jei stulpelyje yra keli žodžiai, juos reikia įterpti į papildomas dvigubas kabutes. Jei neįterpiama – nuskaitoma neteisingai: neteisingai &lt;- fread( &quot;Pavadinimas Reikšmė Pirmas 1 Du žodžiai 2 Keli žodžiai 3 &quot;) ## Warning in fread(&quot;Pavadinimas Reikšmė\\nPirmas 1\\nDu žodžiai 2\\nKeli žodžiai ## 3\\n&quot;): Stopped early on line 3. Expected 2 fields but found 3. Consider ## fill=TRUE and comment.char=. First discarded non-empty line: &lt;&lt;Du žodžiai ## 2&gt;&gt; neteisingai ## Pavadinimas Reikšmė ## 1: Pirmas 1 Keli variantai, kaip nuskaitymą atlikti teisingai: Visą tekstą dėti į viengubas kabutes, o reikiamų stulpelių reikšmes – į dvigubas: teisingai1 &lt;- fread( &#39;Pavadinimas Reikšmė Pirmas 1 &quot;Du žodžiai&quot; 2 &quot;Keli žodžiai&quot; 3 &#39;) teisingai1 ## Pavadinimas Reikšmė ## 1: Pirmas 1 ## 2: Du žodžiai 2 ## 3: Keli žodžiai 3 Visą tekstą dėti į dvigubas kabutes, o prieš stulpeliuose esančias dvigubas kabutes pridėti atgal pasvirusį brūkšnį (\\), kaip parodyta šiame pavyzdyje: teisingai2 &lt;- fread( &quot;Pavadinimas Reikšmė Pirmas 1 \\&quot;Du žodžiai\\&quot; 2 \\&quot;Keli žodžiai\\&quot; 3 &quot;) teisingai2 ## Pavadinimas Reikšmė ## 1: Pirmas 1 ## 2: Du žodžiai 2 ## 3: Keli žodžiai 3 8.2 Klasikiniai metodai PI skaičiuoti 8.2.1 Vidurkio PI, kai GA dispersija žinoma Kai generalinės aibės dispersija žinoma, vidurkio PI galima skaičiuoti pagal formulę (8.1). Situacija, kai tikrasis vidurkis nežinomas, o išsisklaidymas aplink jį – dispersija – žinoma, yra tik hipotetinė. Tačiau formulė ganėtinai paprasta ir mokymosi tikslais iliustruoti, kaip konstruojamas PI, tinkama. Ši formulė taip pat naudojama, kai imties dydis pakankamai didelis. \\[\\begin{equation} \\hat{\\mu}_{1,2} = \\overline{X} \\mp z_{\\left(\\frac{1-Q}{2}\\right)}{\\sigma \\over \\sqrt{n}} \\tag{8.1} \\end{equation}\\] Formulėje: \\(\\hat{\\mu}_{1}\\) – apatinė vidurkio pasikliauties intervalo riba (mažesnis skaičius); \\(\\hat{\\mu}_{2}\\) – viršutinė vidurkio pasikliauties intervalo riba (didesnis skaičius); \\(\\overline{X}\\) – imties vidurkis; \\(\\sigma\\) – generalinės aibės standartinis nuokrypis (arba imties standartinis nuokrypis, jei duomenų pakankamai daug); \\(n\\) – imties dydis; \\(Q\\) – pasikliovimo lygmuo (tikimybė); \\({\\left(\\frac{1-Q}{2}\\right)}\\) – galime pažymėti kaip tikimybę \\(\\alpha\\); \\(z_{\\alpha}\\) – \\(z\\) koeficientas – daugiklis, dar vadinamas standartinio normaliojo skirstinio \\(1-\\alpha\\) lygmens kvantiliu (skaičius, priklausantis nuo norimo pasikliovimo lygmens). Jis imamas iš lentelių arba apskaičiuojamas programomis R, GeoGebra ar kitomis. Ši formulė tinka normaliai pasiskirsčiusiems duomenims, arba duomenims, kurių yra tiek daug, kad galioja centrinė ribinė teorema. Formulė susideda iš 3 dalių: taškinis vidurkio įvertis, koeficientas, priklausantis nuo norimo pasikliovimo lygmens, ir standartinė vidurkio paklaida. Ar matote jas visas? Siekiant apsiskaičiuoti reikiamą imties dydį, kad būtų pasiektas norimas tikslumas (intervalo ilgis), gali būti naudojama iš (8.1) formulės išvesta lygtis (8.3). Formulė su \\(z\\) koeficientu tinkama tada, kai žinome tikrąją generalinės aibės dispersiją \\((\\sigma^2)\\). Arba imtyje duomenų pakankamai daug – vienų autorių teigimu \\(n&gt;50\\), kitų – \\(n&gt;30\\). Galima alternatyva, kai imtis maža, bet pasiskirsčiusi normaliai – formulė, kurioje naudojamas \\(t\\) koeficientas. Jei norite skaičiuoti automatiškai, štai R kodas: data(npk) derlius &lt;- npk$yield # --- Keisti tik šias eilutes ------------------------------------------------ # Pasirenkame duomenų vektorių `x` ir pasikliovimo lygmenį – tikimybę `Q`. # Jei turite suvestinę, vietoje `x` įrašykite kintamųjų # `n`, `st_nuokrypis` ir `vidurkis` reikšmes. x &lt;- derlius Q &lt;- 0.95 # ---------------------------------------------------------------------------- n &lt;- length(x) st_nuokrypis &lt;- sd(x) vidurkis &lt;- mean(x) # --- Toliau esančio kodo nekeisti ------------------------------------------- # Taikome formulę su z koeficientu: z &lt;- qnorm((1 - Q) / 2, lower.tail = FALSE) paklaida &lt;- z * st_nuokrypis/sqrt(n) apatinė_riba &lt;- vidurkis - paklaida viršutinė_riba &lt;- vidurkis + paklaida # Rezultatai: vidurkio_pi_z &lt;- c(vidurkis = vidurkis, PI_apatine_riba = apatinė_riba, PI_virsutine_riba = viršutinė_riba) # ---------------------------------------------------------------------------- Rezultatas: vidurkio_pi_z ## vidurkis PI_apatine_riba PI_virsutine_riba ## 54.87500 52.40543 57.34457 Iki vieno skaičiaus po kablelio suapvalintas rezultatas: round(vidurkio_pi_z, digits = 1) ## vidurkis PI_apatine_riba PI_virsutine_riba ## 54.9 52.4 57.3 Užduotis 8.4 Išmatuotas \\(100\\) studentų cholesterolio kiekis kraujyje. Gautas vidurkis \\(310\\frac{\\mu mol}{l}\\). Koks cholesterolio kiekio kraujyje vidurkio \\(95\\%\\) pasikliauties intervalas, jeigu šio dydžio standartinis nuokrypis studentų populiacijoje yra \\(35\\frac{\\mu mol}{l}\\)? 8.2.2 Vidurkio PI, kai GA dispersija nežinoma Kai GA dispersija nežinoma, tada vidurkio PI skaičiavimo formulėje naudojame dispersiją, apskaičiuotą iš duomenų. Tokiu atveju vietoje z koeficiento reikia naudoti t koeficientą, kurio dydis priklauso nuo imties dydžio. Tad tokia formulė kaip (8.2) savo surinktiems duomenims analizuoti yra naudingesnė. \\[\\begin{equation} \\hat{\\mu}_{1,2} = \\overline{X} \\mp t_{\\left(\\frac{1-Q}{2}\\right)}(n-1) {S \\over \\sqrt{n}} \\tag{8.2} \\end{equation}\\] Formulėje: \\(\\hat{\\mu}_{1}\\) – apatinė vidurkio pasikliauties intervalo riba (mažesnis skaičius); \\(\\hat{\\mu}_{2}\\) – viršutinė vidurkio pasikliauties intervalo riba (didesnis skaičius); \\(\\overline{X}\\) – imties vidurkis; \\(S\\) – imties standartinis nuokrypis; \\(n\\) – imties dydis; \\(Q\\) – pasikliovimo lygmuo (tikimybė); \\({\\left(\\frac{1-Q}{2}\\right)}\\) – galime pažymėti kaip tikimybę \\(\\alpha\\); \\(t_{\\alpha}(n-1)\\) – daugiklis, dar vadinamas Stjudento koeficientu arba Stjudento skirstinio (su \\(n-1\\) laisvės laipsnių) \\(1-\\alpha\\) lygmens kvantiliu (skaičius, priklausantis nuo norimo pasikliovimo lygmens). Jis imamas iš lentelių arba apskaičiuojamas programomis R, GeoGebra ar kitomis. Ši formulė tinka normaliai pasiskirsčiusiems duomenims, arba duomenims, kurių yra tiek daug, kad galioja centrinė ribinė teorema. Pamenat, formulė susideda iš 3 dalių. Ar ir šiuo atveju matote jas visas? Štai R kodas, jei norite, kad R apskaičiuotų už jus: data(npk) derlius &lt;- npk$yield # --- Keisti tik šias eilutes ------------------------------------------------ # Pasirenkame duomenų vektorių `x` ir pasikliovimo lygmenį – tikimybę `Q`. # Jei turite suvestinę, vietoje `x` įrašykite kintamųjų # `n`, `st_nuokrypis` ir `vidurkis` reikšmes. x &lt;- derlius Q &lt;- 0.95 # ---------------------------------------------------------------------------- n &lt;- length(x) st_nuokrypis &lt;- sd(x) vidurkis &lt;- mean(x) # --- Toliau esančio kodo nekeisti ------------------------------------------- # Taikome formulę su t koeficientu: t &lt;- qt((1 - Q) / 2, df = (n - 1), lower.tail = FALSE) paklaida &lt;- t * st_nuokrypis/sqrt(n) apatinė_riba &lt;- vidurkis - paklaida viršutinė_riba &lt;- vidurkis + paklaida vidurkio_pi_t &lt;- c(vidurkis = vidurkis, PI_apatine_riba = apatinė_riba, PI_virsutine_riba = viršutinė_riba) # ---------------------------------------------------------------------------- Rezultatas: vidurkio_pi_t ## vidurkis PI_apatine_riba PI_virsutine_riba ## 54.87500 52.26848 57.48152 Iki vieno skaičiaus po kablelio suapvalintas rezultatas: round(vidurkio_pi_t, digits = 1) ## vidurkis PI_apatine_riba PI_virsutine_riba ## 54.9 52.3 57.5 Formulė su \\(t\\) koeficientu yra universalesnė, tinka, kai duomenų nedaug. Visgi, jų turi būti pakankamai, o ne vos keli taškai. Jei taškų iki 15 – pasiskirstymas privalo būti idealiai normalusis. Užduotis 8.5 Užsikraukite duomenis, naudodami komandą data(swiss). Duomenų lentelė swiss: Apskaičiuokite kintamojo Fertility reikšmių vidurkio 95% pasikliauties intervalą. Ar šie duomenys tenkina prielaidas vidurkio pasikliauties intervalui skaičiuoti naudojant formulę? Rcmdr vidurkio PI skaičiavimui Vidurkio pasikliauties intervalą pagal (8.2) lygtį galime skaičiuoti naudodami Rcmdr įskiepį RcmdrPlugin.EZR.2 (diegimo instrukcijos šios knygos prieduose). Užkrovus šį įskiepį atsiranda mygtukas pavadinimu „EZR“ (pav. 8.1). Pav. 8.1: RcmdrPlugin.EZR.2 meniu mygtukas R Commander meniu juostoje. Pav. 8.2: Vidurkio pasikliauties intervalo skaičiavimas pagal (8.2) formulę naudojant Rcmdr. Atsidariusioje lentelėje įrašome reikiamus skaičius: vidurkį, standartinį nuokrypį ir imties dydį. Sveikąją ir dešimtąją skaičiaus dalį reikia atskirti tašku (pvz., 10.254), o ne kableliu. 8.2.3 Imties dydžio skaičiavimas norimam vidurkio PI ilgiui Iš formulės (8.1) galima išsireikšti imties dydį, kurio reikia norimam tikslumui pasiekti. Tai aprašo lygtis (8.3): \\[\\begin{equation} n = \\left( {2 \\cdot \\sigma\\cdot z_{\\left(\\frac{1-Q}{2}\\right)} } \\over \\Delta\\hat{\\mu} \\right)^2 \\tag{8.3} \\end{equation}\\] Formulėje: \\(n\\) – imties dydis; \\(\\Delta\\hat{\\mu}\\) – vidurkio pasikliauties intervalo ilgis; \\(\\sigma\\) – (hipotetinis) standartinis nuokrypis; \\(Q\\) – pasikliovimo lygmuo (tikimybė); \\({\\left(\\frac{1-Q}{2}\\right)}\\) – galime pažymėti kaip tikimybę \\(\\alpha\\); \\(z_{\\alpha}\\) – \\(z\\) koeficientas – daugiklis, dar vadinamas standartinio normaliojo skirstinio \\(1-\\alpha\\) lygmens kvantiliu (skaičius, priklausantis nuo norimo pasiliovimo lygmens). Rezultatą apvaliname iki sveikųjų skaičių į didesniąją pusę, tarkim 60,02 → 61. Kitu atveju intervalas bus per trumpas. Šio tipo skaičiavimą galima atlikti papildiniu Rcmdr (pav. 8.3). Pav. 8.3: Papildinio RcmdrPlugin.EZR.2 naudojimas reikiamo imties dydžio skaičiavimui norimam pasikliauties intervalo pločiui gauti. Užduotis 8.6 Išmatuota 93 studentų cholesterolio koncentracija kraujyje. Gautas vidurkis yra \\(308\\frac{\\mu mol}{l}\\). Koks yra cholesterino kiekio kraujyje 99% pasikliauties intervalas, jeigu imties standartinis nuokrypis – \\(35\\frac{\\mu mol}{l}\\)? Kokio imties dydžio reikia, kad intervalo ilgis būtų \\(30\\frac{\\mu mol}{l}\\)? Kokio imties dydžio reikia, kad intervalo ilgis būtų \\(2\\) vienetais mažesnis, nei gautas (a) punkte? 8.2.4 Proporcijos PI Kategoriniai kintamieji gali būti skirstomi į: dvireikšmius – galinčius įgyti dvi skirtingas reikšmes, pvz., gėrimas tik „šiltas“ arba „šaltas“ \\((k = 2)\\); daugiareikšmius – galinčius įgyti daugiau nei 2 skirtingas reikšmes, pvz., driežas „raudonas“, „juodas“, „geltonas“, „žalias“ \\((k &gt; 2)\\). Čia \\(k\\) – kategorijų skaičius. Todėl proporcijos taip pat skirstomos į dvireikšmių kintamųjų proporcijas (arba „binomines“ proporcijas, angl., binomial proportion) ir daugiareikšmių kintamųjų proporcijas (arba „multinomines“ proporcijas, angl., multinomial proportion). Primenu, kad norint skaičiuoti PI imtis turi būti sudaryta atsitiktinai. Kitaip PI neturi prasmės. Pradedantiesiems rekomenduojama tokia proporcijos PI pasirinkimo schema: kai \\(k = 2\\) rinkitės koreguotą Wilson metodą. Jis tinka ir tada, kai proporcija \\(p\\) maža (netoli 0) arba didelė (netoli 1). kai \\(k &gt; 2\\) ir kai kiekvienoje grupėje bent po 6 (geriausia bent po 10) narių ir grupių skaičius ne per didelis (sakykim, \\(k &lt; 10\\)), rinkitės Goodman metodą (šis metodas tinkamas daugeliui praktiškai pasitaikančių situacijų); kai \\(k &gt; 2\\) kiekvienoje grupėje daugmaž vienodas skaičius narių, rinkitės Sison-Glaz metodą. Metodas ypač tinka tada, kai grupėse narių mažai, o grupių labai daug. Bet jei yra bent viena pagal narių skaičių dominuojanti grupė, tada metodas duoda prastus rezultatus ir jo reiktų nesirinkti. Šie metodai pasiekiami naudojant paketo DescTools funkcijas. Norint naudoti binominės proporcijos metodus, reikia žinoti, kiek mūsų imtyje yra narių iš viso (n) ir kiek iš jų turi mus dominančią savybę (x). x &lt;- 30 # Imtyje pasitaikiusių šaltų gėrimų skaičius n &lt;- 66 # Imties dydis # Wilson metodas: DescTools::BinomCI(x, n, method = &quot;wilson&quot;) ## est lwr.ci upr.ci ## [1,] 0.4545455 0.3402413 0.5738499 # Koreguotasis Wilson metodas: DescTools::BinomCI(x, n, method = &quot;modified wilson&quot;) ## est lwr.ci upr.ci ## [1,] 0.4545455 0.3402413 0.5738499 Rezultatas yra matrica (todėl vėliau ją versime į duomenų lentelę), kurios stulpeliai: est – proporcijos taškinis įvertis, lwr.ci ir upr.ci – proporcijos pasikliauties intervalo apatinė ir viršutinė ribos. „Multinominių“ proporcijų skaičiavimui reikia žinoti, kiek kurios grupės narių pasitaikė. # Imtyje pasitaikė 24 juodi, 52 raudoni, 26 žali ir 43 geltoni driežiukai x_2 &lt;- c(24, 52, 26, 43) DescTools::MultinomCI(x_2, method = &quot;goodman&quot;) ## est lwr.ci upr.ci ## [1,] 0.1655172 0.09685563 0.2683888 ## [2,] 0.3586207 0.25715494 0.4745463 ## [3,] 0.1793103 0.10742403 0.2839959 ## [4,] 0.2965517 0.20314729 0.4107643 Rezultatų matricoje kiekvienai grupei (juodi, raudoni, žali, geltoni) skirta atskira eilutė. # Imtyje pasitaikė 24 juodi, 22 raudoni, 26 žali ir 23 geltoni driežiukai x_3 &lt;- c(24, 22, 26, 23) DescTools::MultinomCI(x_3, method = &quot;sisonglaz&quot;) ## est lwr.ci upr.ci ## [1,] 0.2526316 0.1578947 0.3661081 ## [2,] 0.2315789 0.1368421 0.3450555 ## [3,] 0.2736842 0.1789474 0.3871608 ## [4,] 0.2421053 0.1473684 0.3555818 Pavyzdys 1: triušiai Sakykime, visiškai atsitiktinai sudarytoje imtyje 150 triušių ir 50 iš jų yra margi. Tad margų triušių dalies generalinėje aibėje 95% pasikliauties intervalas yra 0,26-0,41: (prop_pi &lt;- DescTools::BinomCI(x = 50, n = 150, method = &quot;wilson&quot;)) ## est lwr.ci upr.ci ## [1,] 0.3333333 0.2628876 0.4121024 prop_pi_df &lt;- as.data.frame(prop_pi) ggplot(prop_pi_df, aes(x = &quot;Margi triušiai&quot;)) + geom_col(aes(y = est), color = &quot;black&quot;, fill = &quot;skyblue1&quot;, width = 0.5) + geom_errorbar(aes(ymin = lwr.ci, ymax = upr.ci), size = 2, width = 0.1) + labs(x = &quot;&quot;, y = &quot;Dalis&quot;, title = &quot;Margų triušių dalis populiacijoje&quot;, subtitle = &quot;Įvertis ir 95% pasikliauties intervalas&quot;) Pavyzdys 2: rasinė įvairovė library(tidyverse) library(DescTools) Įsikeliame duomenis. data(birthwt, package = &quot;MASS&quot;) Sudarome norimo požymio (rasės) dažnių lentelę. birthwt %&gt;% count(race) ## # A tibble: 3 x 2 ## race n ## &lt;int&gt; &lt;int&gt; ## 1 1 96 ## 2 2 26 ## 3 3 67 Rasių atžvilgiu duomenys buvo surinkti visiškai atsitiktinai, todėl pagal imtį galime spręsti apie pasiskirstymą generalinėje aibėje – sudaryti pasikliautinuosius intervalus. Rasių kodų reikšmės: 1 – baltoji rasė, 2 – juodoji rasė, 3 – kitos rasės. Norėdami išlaikyti grupių pavadinimus, duomenis pateikiame tokiu formatu – &quot;pavadinimas&quot; = skaičius: rasiu_pi_matrica &lt;- MultinomCI(x = c(&quot;baltoji&quot; = 96, &quot;juodoji&quot; = 26, &quot;kitos&quot; = 67), method = &quot;goodman&quot;) rasiu_pi_matrica ## est lwr.ci upr.ci ## baltoji 0.5079365 0.42005803 0.5953273 ## juodoji 0.1375661 0.08730632 0.2100988 ## kitos 0.3544974 0.27499693 0.4429394 Duomenų matricą paverčiame į duomenų lentelę, eilučių pavadinimus perkeliame į stulpelį „rasė“. rasiu_pi_lentele &lt;- as.data.frame(rasiu_pi_matrica) %&gt;% rownames_to_column(&quot;rasė&quot;) rasiu_pi_lentele ## rasė est lwr.ci upr.ci ## 1 baltoji 0.5079365 0.42005803 0.5953273 ## 2 juodoji 0.1375661 0.08730632 0.2100988 ## 3 kitos 0.3544974 0.27499693 0.4429394 Duomenis atvaizduojame. ggplot(rasiu_pi_lentele, aes(x = rasė, color = rasė)) + geom_errorbar(aes(ymin = lwr.ci, ymax = upr.ci), width = 0.2, size = 1) + geom_point(aes(y = est), size = 2) + labs(title = &quot;Proporcija ir jos 95% pasikliauties intervalas&quot;) + ylim(0, 0.7) Pavyzdys 3: grupės pagal ūgį Pavyzdys pažengusiems. Šiek tiek įdomesnis pavyzdys, kaip apsiskaičiuoti daugiareikšmio kategorinio kintamojo reikšmių proporcijos pasikliauties intervalą iš duomenų. Kad būtų aiškiau, duomenis susigeneruokime. set.seed(100) ugiu_pogrupiai &lt;- data.frame( ugiai = c(rep(&quot;Aukštas&quot;, 80), rep(&quot;Vidutinis&quot;, 120), rep(&quot;Žemas&quot;, 100)), x = rnorm(n = 300, mean = 90, sd = 5), y = rnorm(n = 300, mean = 110, sd = 6)) glimpse(ugiu_pogrupiai) ## Observations: 300 ## Variables: 3 ## $ ugiai &lt;fct&gt; Aukštas, Aukštas, Aukštas, Aukštas, Aukštas, Aukštas, Au... ## $ x &lt;dbl&gt; 87.48904, 90.65766, 89.60541, 94.43392, 90.58486, 91.593... ## $ y &lt;dbl&gt; 98.86733, 103.88861, 103.72933, 106.09227, 112.29610, 11... head(ugiu_pogrupiai) ## ugiai x y ## 1 Aukštas 87.48904 98.86733 ## 2 Aukštas 90.65766 103.88861 ## 3 Aukštas 89.60541 103.72933 ## 4 Aukštas 94.43392 106.09227 ## 5 Aukštas 90.58486 112.29610 ## 6 Aukštas 91.59315 116.19140 dazniu_lentele &lt;- ugiu_pogrupiai %&gt;% group_by(ugiai) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(is_viso = sum(n)) pander(dazniu_lentele) ugiai n is_viso AukÅtas 80 300 Vidutinis 120 300 Å½emas 100 300 Dabartinė pander versija turi problemų su tarptautinių (t.p. ir lietuviškų) simbolių dekodavimu. rez_matrica &lt;- DescTools::MultinomCI(x = dazniu_lentele$n, method = &quot;goodman&quot;) rez &lt;- as.data.frame(rez_matrica) pander(rez) est lwr.ci upr.ci 0.2667 0.2092 0.3333 0.4 0.3334 0.4705 0.3333 0.2706 0.4026 Skaičių formatavimas gali būti vykdomas funkcija sprintf(). Formato kodas %.2f iššifruojamas taip: % reiškia, kad bus formato aprašymas; todėl norint, kad būtų atvaizduotas procentų ženklas, reikia padėti du procento simbolius iš eilės, pvz., %%. .2 – du skaičiai po kablelio; f – fiksuotas skaičių formatas (mūsų atveju, visą laiką 2 skaičiai po kablelio). rez %&gt;% transmute(pi_graziau = sprintf(&quot;%.2f (%.2f–%.2f)&quot;, est, lwr.ci, upr.ci)) ## pi_graziau ## 1 0.27 (0.21–0.33) ## 2 0.40 (0.33–0.47) ## 3 0.33 (0.27–0.40) Formatuojame 3 kintamuosius (est, lwr.ci ir upr.ci), todėl formato kodo užrašą naudojome 3 kartus. Pastaba dėl %&gt;% ir . naudojimo: pavyzdyje, esančiame žemiau, taškas nurodo, kurioje vietoje į funkciją reikia įdėti duomenų lentelę rez. Plačiau apie tai rašoma paketo magrittr tinklapyje (nuoroda ). rez %&gt;% print(.) ## est lwr.ci upr.ci ## 1 0.2666667 0.2091875 0.3332834 ## 2 0.4000000 0.3333785 0.4705376 ## 3 0.3333333 0.2705523 0.4026412 Dabar visą analizę sujunkime į vieną grandinę. Joje yra funkcija do(), kuri naudojama vietoje summarize(), kai vienu metu reikia apskaičiuoti daugiau nei vieną skaičių (šiuo atveju, taškinį proporcijos įvertį ir jo pasikliauties intervalą). prop_pi &lt;- ugiu_pogrupiai %&gt;% group_by(ugiai) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(is_viso = sum(n)) %&gt;% do(data.frame(ugiai = .$ugiai, n = .$n, DescTools::MultinomCI(x = .$n, method = &quot;goodman&quot;)) ) %&gt;% mutate(ivertis_graziau = sprintf(&quot;%.1f%%&quot;, 100*est), pi_graziau = sprintf(&quot;(%.1f–%.1f)&quot;, 100*lwr.ci, 100*upr.ci)) Rezultatas: glimpse(prop_pi) ## Observations: 3 ## Variables: 7 ## $ ugiai &lt;fct&gt; Aukštas, Vidutinis, Žemas ## $ n &lt;int&gt; 80, 120, 100 ## $ est &lt;dbl&gt; 0.2666667, 0.4000000, 0.3333333 ## $ lwr.ci &lt;dbl&gt; 0.2091875, 0.3333785, 0.2705523 ## $ upr.ci &lt;dbl&gt; 0.3332834, 0.4705376, 0.4026412 ## $ ivertis_graziau &lt;chr&gt; &quot;26.7%&quot;, &quot;40.0%&quot;, &quot;33.3%&quot; ## $ pi_graziau &lt;chr&gt; &quot;(20.9–33.3)&quot;, &quot;(33.3–47.1)&quot;, &quot;(27.1–40.3)&quot; head(prop_pi) ## ugiai n est lwr.ci upr.ci ivertis_graziau pi_graziau ## 1 Aukštas 80 0.2666667 0.2091875 0.3332834 26.7% (20.9–33.3) ## 2 Vidutinis 120 0.4000000 0.3333785 0.4705376 40.0% (33.3–47.1) ## 3 Žemas 100 0.3333333 0.2705523 0.4026412 33.3% (27.1–40.3) Pasikliauties intervalus nusibraižykime: ggplot(prop_pi, aes(x = ugiai, fill = ugiai)) + geom_col(aes(y = est), color = &quot;black&quot;, width = 0.5) + geom_errorbar(aes(ymin = lwr.ci, ymax = upr.ci), color = &quot;black&quot;, size = 1, width = 0.2) + geom_text(aes(y = -0.02, label = ivertis_graziau), fontface = &quot;bold&quot;) + geom_text(aes(y = -0.06, label = pi_graziau)) + coord_cartesian(ylim = c(-0.06, 0.55), expand = TRUE) + geom_hline(yintercept = 0, color = &quot;black&quot;, linetype = 2) + labs( x = &quot;Ūgio grupė&quot;, fill = &quot;Ūgio grupė&quot;, y = &quot;Procentinė dalis&quot;, title = &quot;Pasiskirstymas pagal ūgį&quot;, subtitle = &quot;Pasikliauties intervalai apskaičiuoti Goodman metodu&quot; ) + scale_y_continuous(labels = function(x){ paste0(100 * x, &quot;%&quot;) }) + theme_bw() Proporcijas stulpeliu vaizduoti galima. Bet vidurkį, medianą ir pan. – nekorektiška, nes atsiranda dviprasmybė: vietoje stulpelio rinkitės tašką. Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["stat-testai-1.html", "9. Hipotezių tikrinimas 1-2 imtims 9.1 Parametriniai ir neparametriniai kriterijai 9.2 Rekomendacija, kaip atlikti statistinių hipotezių tikrinimą 9.3 Schemos metodams pasirinkti 9.4 Praktiniai patarimai", " 9. Hipotezių tikrinimas 1-2 imtims Užsiėmimo tikslas – susipažinti su dažnai praktikoje naudojamais statistinių hipotezių tikrinimo metodais vienai ir dviems imtims. Jūsų mokymosi tikslai: Žinoti rekomenduojamus analizės žingsnius: Klausimas → Grafikas → Prielaidų tikrinimas → Analizė; Mokėti duomenis nusibraižyti pagal grupes. Žinoti, kokios prielaidos turi būti patikrintos prieš taikant t kriterijų; Žinoti, kaip interpretuoti t ir F kriterijų taikymo metu apskaičiuotą p reikšmę; Žinoti, kur „R Commander“ meniu juostoje rasti šiuos statistinius kriterijus: Vienos imties t kriterijų (parametrinis); Priklausomų imčių t kriterijų (parametrinis); Nepriklausomų imčių t kriterijų (parametrinis); Vienos imties Wilcoxon kriterijų (neparametrinis); Priklausomų imčių Wilcoxon kriterijų (neparametrinis); Nepriklausomų imčių Mann-Whitney-Wilcoxon kriterijų (neparametrinis); Shapiro-Wilk normalumo kriterijų; Lilliefor’o (koreguotą Kolmogorov’o-Smirnov’o) normalumo kriterijų; Levene’o kriterijų dispersijoms lyginti; F kriterijų dispersijoms lyginti. Arba žinoti šių kriterijų taikymą atliekančias R komandas. Statistinių hipotezių tikrinimas yra procedūra, kurios metu pasirenkame tarp nulinės (žymima \\(H_0\\)) ir alternatyvios (žymima \\(H_1\\) arba \\(H_a\\)) hipotezės. Alternatyvi hipotezė dažnai vadinama tiesiog alternatyva. Bendrasis principas yra toks, kad – statistinė nulinė hipotezė teigia, kad kelių grupių parametrai yra lygūs, skirtumo, nuokrypio ar efekto nėra, ir ją formuluojant matematiškai gali būti naudojama lygybė arba negriežtos nelygybės \\(=, ~\\le, ~\\ge)\\) (norint pabrėžti, kad skirtumo nėra, įprastai rašoma tik lygybė). Alternatyva, atvirkščiai, teigia, kad parametrai skiriasi, skirtumas, nuokrypis ar efektas yra, ir alternatyvą užrašant matematiškai naudojamos tik griežtos nelygybės \\((\\ne,~&lt;,~&gt;)\\). Su hipotezių tikrinimu glaudžiai susijęs dydis yra p reikšmė. P reikšmė, negriežtai kalbant, yra sąlyginė tikimybė vien tik dėl atsitiktinumo gauti nemažesnį skirtumą, efektą ar nuokrypį, nei tas, kurį gavome savo tyrimo metu, jei iš tiesų to skirtumo, nuokrypio ar efekto nėra (t. y., jei \\(H_0\\) yra teisinga). P reikšmes mes lyginame su reikšmingumo lygmeniu, žymimu \\(\\alpha\\), kuris įprastai lygus \\(0,05\\). Jei p reikšmė didelė \\((p \\ge \\alpha)\\), tada teigiame, kad skirtumas, nuokrypis ar efektas yra statistiškai nereikšmingas (pastaba: nekorektiška teigti, kad skirtumo, nuokrypio ar efekto nėra). Kai p reikšmė yra maža \\((p&lt;\\alpha)\\), tada teigiame, kad tokį skirtumą, nuokrypį ar efektą gauti vien dėl atsitiktinumo yra mažai tikėtina, ir sakome, kad rezultatas yra statistiškai reikšmingas. Jau pastebėjote, kad tikrinant hipotezes yra skaičiuojamos tikimybės. Realioms situacijoms tikimybes skaičiuoti yra sudėtingas uždavinys. Todėl sudarant įvairius statistinius kriterijus daromos tam tikros prielaidos, kurioms galiojant tikimybės apskaičiuojamos pakankamai tiksliai. Jei prielaidos pažeidžiamos, kriterijau naudoti negalima. Todėl turite pasirinkti tą kriterijų, kuris tinka būtent jūsų duomenims. Dažnai daromos tokios prielaidos: duomenys yra reprezentatyvūs generalinei aibei; duomenų imtys/grupės yra nepriklausomos; kiekvienos grupės pasiskirstymas yra normalusis; grupių dispersijos yra lygios. 9.1 Parametriniai ir neparametriniai kriterijai Statistiniai kriterijai (kartais dar vadinami statistiniais testais) skirstomi į parametrinius ir neparametrinius. Jei kriterijus išvestas grindžiant prielaida, kad tiriami duomenys yra pasiskirstę pagal tam tikrą žinomą teorinį skirstinį (pvz., normalųjį) – toks kriterijus vadinamas parametriniu. Tad norint gauti korektišką rezultatą, duomenys turėtų tenkinti šią prielaidą. Ir jei: duomenų pasiskirstymas bent vienoje imtyje/grupėje nėra normalusis (kai imtys labai didelės, kai kuriems kriterijams gali būti taikomos išlygos), duomenys yra ranginiai, duomenų imtys/grupės labai mažos (tarkim, \\(n_i &lt; 20\\), kur n_i yra i-tosios grupės dydis), duomenyse yra aiškių išskirčių, tada naudojami neparametriniai kriterijai. Neparametrinių kriterijų statistinė galia yra mažesnė, tad jei galite rinktis, naudokite parametrinį kriterijų. Verta žinoti, kad taikant tiek parametrinius, tiek ir neparametrinius kriterijus, duomenys privalo tenkinti tam tikras sąlygas (reiktų atidžiai perskaityti naudojamo kriterijaus aprašymą). 9.2 Rekomendacija, kaip atlikti statistinių hipotezių tikrinimą Pav. 9.1: Rekomenduojami pagrindiniai korektiškos statistinių hipotezių tikrinimo analizės etapai. 9.3 Schemos metodams pasirinkti Žemiau pateiktos schemos yra supaprastintos ir tik rekomendacinio pobūdžio. Jų tikslas – būti „atspirties tašku“ renkantis analizės metodą. Konkrečiu atveju gali būti išlygų, papildomų sąlygų arba pasirinkimo variantų, kurie schemose nepažymėti. Pav. 9.2: Žemiau esančių schemų žymėjimai. 9.3.1 Normalumo prielaidos tikrinimas Normalaus pasiskirstymo prielaida yra viena dažniausių. Ją reikia tikrinti prieš taikant daugelį parametrinių kriterijų. Statistiniais normalumo kriterijais tikrina, ar nuokrypis nuo normaliojo pasiskirstymo yra statistiškai reikšmingas. Grafiniai būdai padeda įvertinti, ar nuokrypiai praktiškai reikšmingi. (Šia tema taip pat rašoma 7.7 skyriuje.) Statistinės hipotezės Taikant formalius kriterijus hipotezei apie normalumą tikrinti statistinės hipotezės formuluojamos taip: \\(H_0\\): pasiskirtymas yra normalusis \\(X \\sim \\mathcal{N}(\\mu, ~\\sigma^2)\\) (nuokrypio nuo normalumo nėra); \\(H_1\\): pasiskirtymas nėra normalusis, \\(X \\not\\sim \\mathcal{N}(\\mu, ~\\sigma^2)\\) (nuokrypis nuo normalumo yra). Hipotezė apie skirstinių normalumą taikoma kiekvienai grupei atskirai, tad gaunama tiek p reikšmių, kiek yra lyginamų grupių. Jei reikšmingumo lygmuo \\(\\alpha = 0,05\\), tai, kai: \\(p\\ge0.05\\), teigiame, kad nuokrypis nuo normalumo nėra statistiškai reikšmingas (neatmetame \\(H_0\\)); \\(p&lt;0.05\\), teigiame, kad nuokrypis nuo normalumo yra statistiškai reikšmingas (priimame \\(H_1\\)). Įprastai, kai \\(p \\ge 0.05\\), laikoma, kad normalumo prielaida tenkinama (nes nuokrypiai nuo normalumo nėra statistiškai reikšmingi). Pasirinkimų schema Keli normalumo prielaidos tikrinimo metodai pateikti pav. 9.3 esančioje schemoje. Pav. 9.3: Pasiskirstymo normalumo tikrinimo metodų schema. Schemoje 9.3 skaičiais pažymėtų punktų paaiškinimai: 1 Šis apribojimas galioja kriterijų taikant programa „R“; 2 Pvz., histogramos ir teorinės normaliosios kreivės palyginimas. Kaip atlikti? Pav. 9.4: Normaliojo pasiskirstymo (normalumo) prielaidos tikrinimas pogrupiams papildiniu R Commander („BioStat’18“ meniu). 9.3.2 Kriterijai dispersijoms lyginti Griežtai kalbant, skyrius turėtų vadintis „Statistiniai kriterijai hipotezei apie dispersijų lygybę tikrinti“. Kriterijus, kuriuo siekiama patikrinti, ar skirtumai tarp dispersijų yra statistiškai reikšmingi, gali būti taikomas ir kaip pagrindinis kriterijus. Tačiau dažniau šie kriterijai naudojami kaip pagalbinis būdas lygių dispersijų prielaidos pagrįstumui įvertinti. Tokiu atveju pradedantiesiems rekomenduoju Levene’o (skaitoma „Ly-vy-no“) kriterijų su Brown-Forsythe pataisa, nes jis tinka ir normaliesiems ir kitokiems duomenims. Šis ir kiti pagrindiniai dispersijų lyginimo kriterijai pateikti pav. 9.5 esančioje schemoje. Statistinės hipotezės Kai naudojamas F kriterijus hipotezei apie dviejų grupių lygybę tikrinti, statistinės hipotezės formuluojamos taip: \\(H_0\\): dispersijos lygios, \\(\\sigma^2_1 = \\sigma^2_1\\) (skirtumo nėra); \\(H_1\\): dispersijos skiriasi, \\(\\sigma^2_1 \\ne \\sigma^2_1\\) (dvipusė alternatyva), \\(\\sigma^2_1 &lt; \\sigma^2_1\\) arba \\(\\sigma^2_1 &gt; \\sigma^2_1\\) (vienpusės alternatyvos). Jei naudojami kriterijai, kuriais tikrinama hipotezė apie kelių (2 ar daugiau) dispersijų lygybę, hipotezės: \\(H_0\\): dispersijos lygios, \\(\\sigma^2_1 = \\sigma^2_1 = ... = \\sigma^2_n\\) (skirtumo nėra); \\(H_1\\): bent dviejų grupių (neaišku kurių) dispersijos skiriasi, \\(\\sigma^2_i \\ne \\sigma^2_j\\) (dvipusė alternatyva). Kriterijus lygina iš karto visų grupių dispersijas, todėl gaunama viena p reikšmė. Jei reikšmingumo lygmuo \\(\\alpha = 0,05\\), tai, kai: \\(p\\ge0.05\\), teigiame, kad skirtumas tarp dispersijų yra statistiškai nereikšmingas (neatmetame \\(H_0\\)); \\(p&lt;0.05\\), teigiame, kad skirtumas tarp dispersijų yra statistiškai reikšmingas (priimame \\(H_1\\)). Įprastai, kai \\(p \\ge 0.05\\), laikoma, kad lygių dispersijų prielaida tenkinama (nes skirtumai tarp dispersijų nėra statistiškai reikšmingi). Pasirinkimų schema Pav. 9.5: Schema, rekomenduojanti, kurį dispersijų lyginimo metodą pasirinkti. Įprastai prielaidų tikrinimui universaliausias yra Levene/Brown-Forsythe metodas, kai kiekvienos grupės centru laikoma mediana. Schemoje 9.5 skaičiais pažymėtų punktų paaiškinimai: 1 Yra keli Levene/Brown-Forsythe kriterijaus variantai: a. Klasikinis Levene‘o kriterijus, kai duomenų centru laikomas vidurkis. Labiausiai tinka, kai duomenų pasiskirstymas nedaug nukrypsta nuo normalumo; b. Brown-Forsythe kriterijus (t.y., Levene‘o kriterijus su Brown-Forsythe pataisa), kai duomenų centru laikoma mediana. Tinka ir tada, kai duomenys yra asimetriški. Tai pagrindinis kriterijaus variantas jį atliekant programa „R“ ir „R Commander“; c. Brown-Forsythe kriterijus, kai duomenų centru laikomas kiekvienos grupės 10% nupjautinis vidurkis. Labiausiai tinka, kai skirstinio tikimybės susiteklusios ties skirstinio uodegomis. Šio varianto „R Commander“ neatlieka. Kaip atlikti? Pav. 9.6: Levene ir Brown-Forsythe kriterijai naudojant R Commander. 9.3.3 Kriterijai centro padėčiai lyginti Šiame skyriuje kalbama apie statistinį imties centro padėties charakteristikų (vidurkių, medianų ar vidutinių rangų) lyginimą. Tai vieni dažniausiai naudojamų statistinių kriterijų. Jei taikomas toks kriterijus, vadinasi, ieškoma statistiškai reikšmingų rezultatų: jei pasirinktas reikšmingumo lygmuo \\(\\alpha = 0.05\\), tai skirtumai statistiškai reikšmingi, kai \\(p &lt; 0.05\\). Statistinės hipotezės: parametriniai kriterijai Parametriniams kriterijams hipotezei apie dviejų duomenų grupių centro padėties lygybę tikrinti, statistinės hipotezės formuluojamos taip: \\(H_0\\): vidurkiai yra lygūs, \\(\\mu_1=\\mu_2\\) (skirtumo nėra); \\(H_1\\): vidurkiai skiriasi, \\(\\mu_1 \\ne \\mu_2\\) (dvipusė alternatyva), \\(\\mu_1&gt;\\mu_2\\) arba \\(\\mu_1&lt;\\mu_2\\) (vienpusės alternatyvos). Sakykime, kad buvome pasirinkę dvipusę alternatyvą. Jei reikšmingumo lygmuo \\(\\alpha = 0,05\\), tai, kai: \\(p\\ge0.05\\), teigiame, kad skirtumas tarp vidurkių yra statistiškai nereikšmingas (neatmetame \\(H_0\\)); \\(p&lt;0.05\\), teigiame, kad skirtumas yra statistiškai reikšmingas (priimame \\(H_1\\)). Statistinės hipotezės: neparametriniai kriterijai Parametriniams kriterijams hipotezei apie grupių centro padėties lygybę tikrinti formuluojamos bendresnės hipotezės – ne apie konkretų parametrą, bet apskritai apie bendrą skirtumą tarp skirstinių padėties. Tarkime, lyginamos dvi duomenų grupės. Tada: \\(H_0\\): poslinkis tarp skirstinių padėties yra lygus nuliui (skirtumo nėra); \\(H_1\\): poslinkis tarp skirstinių padėties nelygus nuliui, skirstinių padėtis skiriasi (dvipusė alternatyva), pirmos grupės skirstinys yra linkęs būti didesnis nei antrosios (vienpusė alternatyva) arba pirmos grupės skirstinys yra linkęs būti mažesnis nei antrosios (vienpusė alternatyva). Sakykime, kad buvome pasirinkę dvipusę alternatyvą. Jei reikšmingumo lygmuo \\(\\alpha = 0,05\\), tai, kai: \\(p\\ge0.05\\), teigiame, kad poslinkis (skirtumas) tarp skirstinių yra statistiškai nereikšmingas (neatmetame \\(H_0\\)); \\(p&lt;0.05\\), teigiame, kad poslinkis (skirtumas) tarp skirstinių yra statistiškai reikšmingas (priimame \\(H_1\\)). Jei visų grupių skirstinių formos yra vienodos (vienoda asimetrijos kryptis bei sklaida) ir skirstiniai skiriasi tik poslinkio parametru (tokiems duomenims šie neparametriniai kriterijai yra galingiausi), tada šias hipotezes galime formuluoti apie medianų skirtumus (pvz., \\(H_0\\) – medianos vienodos, \\(H_1\\) – medianos skiriasi). Pasirinkimų schema Pav. 9.7 pateikti pirmieji kriterijaus pasirinkimo žingsniai (tad juos išnagrinėkite pirmiausiai). Pav. 9.8 pateikta detalesnė pasirinkimo schema. Schema yra supaprastinta ir tik rekomendacinio pobūdžio. Jos tikslas – būti „atspirties tašku“ renkantis analizės metodą. Konkrečiu atveju gali būti išlygų, papildomų sąlygų arba pasirinkimo variantų, kurie schemoje nepažymėti. Pav. 9.7: Bendroji schema, rekomenduojanti, kurį centro padėties lyginimo metodą pasirinkti. Skaičiais pažymėtų 9.7 schemos dalių paaiškinimai: 1 Toliau žiūrėti schemą 9.8. 2 Toliau žiūrėti schemą 10.1 (kitame skyriuje). Pav. 9.8: Centro padėties lyginimas 1-2 imtims. Schema, rekomenduojanti, kurį centro padėties lyginimo metodą pasirinkti, kai lyginamos 1-2 imtys. Schemoje 9.8 skaičiais pažymėtų punktų paaiškinimai: 1 Pasiskirstymo normalumas tikrinamas kiekvienai grupei atskirai atliekant normalumo testą (pvz., Shapiro-Wilk testą) ir nusibraižant normaliąją q-q diagramą; 2 Kai imtys yra priklausomos, iš kiekvieno pirmos imties nario galime atimti atitinkamą antrosios imties nario reikšmę. Naujai sudarytam kintamajam reiktų patikrinti normalumą. Šis būdas praktiškai greičiausias. Taip pat yra teigiama, kad jei abi pradinės imtys yra normaliosios, tai ir jų skirtumas yra normalusis. Tad galima tikrinti ir kiekvienos pradinės imties normalumą atskirai. Jei bent viena imtis nėra normalioji, tada reiktų tikrinti imčių skirtumų normalumą (kaip parašyta anksčiau); 3 Lygių dispersijų (dar vadinama dispersijų homogeniškumo) prielaida tikrinama atliekant dispersijų lyginimo testą (pvz., Levene‘o testą su Brown-Forsythe pataisa) ir padarius suvestines įvertinant, ar skirtumas tarp dispersijų (ne standartinių nuokrypių) didelis ar mažas. Jei imtis maža, testas rodo, kad lygių dispersijų prielaida tenkinama, bet dispersijos (ne standartiniai nuokrypiai) skiriasi daugiau nei 3 kartus, vadinasi, grupių imties dydžiai yra per maži ir testo rezultatai nepatikimi; 4 Šiuo atveju skirstinių forma laikoma tada, kai visų grupių skirstiniams asimetrija (jei yra) – vienos krypties, o sklaida (dispersijos) – daugmaž vienoda; 5 Jei grupių skirstinių forma vienoda ir skiriasi tik poslinkio parametru, t.y., skiriasi skirstinio padėtis (tokiems duomenims ir rekomenduojamas Mann-Whitney-Wilcoxon testas), tada galime daryti išvadas apie grupių medianas. Šiuo atveju testo rezultatai informatyvesni nei 6 punkto atveju; 6 Jei lyginamų grupių skirstinių forma skirtinga (skiriasi dispersijos, būdinga skirtingos krypties asimetrija), išvadas darome tik apie vidutinius rangus: pvz., sakome, kad grupių skirstinių padėtis yra linkusi būti kitokia – arba didesnė, arba mažesnė. Šie rezultatai mažiau informatyvūs nei 5 punkto atveju. 7 Nereikalaujama, kad dispersijos būtų lygios. 8 Žiūrėti schemą 10.1 (kitame skyriuje). Kaip atlikti? Kai išsirinksite kriterijų, naudodami R Commander jį galėsite taikyti savo duomenims (pav. 9.9). Programa R sugeneruotų rezultatų pavyzdys su paaiškinimais pateiktas pav. 9.10. Pav. 9.9: Parametrinių ir neparametrinių kriterijų grupių centro padėčiai lyginti pasirinkimo meniu R Commander’yje: \\(P_1\\) ir \\(N_1\\) – vienos imties, \\(P_2\\) ir \\(N_2\\) – priklausomų imčių, \\(P_3\\) ir \\(N_3\\) – nepriklausomų imčių kriterijai. Pav. 9.10: Programa R sugeneruotų kriterijaus taikymo rezultatų pavyzdys: Welch (Velčo) t kriterijaus taikymo ir kiti papildomos informacijos suteikiantys rezultatai. Lyginamas ląstelių terpių, kuriose yra skirtingas anglies šaltinis, optinis tankis (OD) ties 600 nanometrų. Kuo OD didesnis, tuo terpėje daugiau ląstelių. Kaip aprašyti rezultatus? Rezultatų aprašymo pavyzdys: „Lygintas dviejų terpių su ląstelėmis optinis tankis ties 600 nm. Skirtumas tarp terpės D (vidurkis 5,19) ir terpės GR (vidurkis 5,09) optinių tankių buvo statistiškai reikšmingas (Welch t, dvipusė alternatyva, t(114,2) = 2,41, p = 0,017; vidurkių skirtumas yra 0,10, 95% PI 0,02–0,18).“ Išsamiame aprašyme turi matytis išvada (statistiškai reikšmingas/nereikšmingas), jos pagrindimas: tikslus kriterijaus pavadinimas, alternatyva (vienpusė/dvipusė), statistika, parametrai ir, būtinai, p reikšmė. P reikšmes rekomenduoju rašyti arba 3 arba 4 skaičių po kablelio tikslumu. Jei p labai maža, rašykite, pvz., \\(p&lt;0,001\\), jei labai didelė – \\(p&gt;0,999\\). Taip pat turi būti paaiškinta, kad „95% PI“ – yra 95% pasikliautinasis intervalas. Visos to paties atsitiktinio dydžio statistikos (vidurkiai, medianos, standartiniai nuokrypiai, kvantiliai, pasikliautinieji intervalai, …), kurie matuojami tais pačiais matavimo vienetais, privalo būti suapvalinti tuo pačiu tikslumu. Jei taikomi parametriniai kriterijai, aprašomi grupių vidurkiai. Jei neparametriniai – medianos. Taip pat pateikiamas grupių palyginimo grafikas (grupių histogramos, stačiakampės, branduolinio tankio ar kitos tinkamos diagramos). 9.4 Praktiniai patarimai 9.4.1 Teisingas duomenų nuskaitymas Nuskaitydami mokomuosius duomenis naudodami RStudio parinktį „From Text (base)…“ (pav. 9.11), atkreipkite dėmesį, kad gali tekti paredaguoti nuskaitymo parametrus. Pav. 9.11: Duomenų nuskaitymas. \\(A_1\\), \\(A_2\\), \\(A_3\\) – tekstinių duomenų nuskaitymo meniu atidarymas. \\(B\\) – norimos tekstinių duomenų bylos pasirinkimas. Tam, kad pirma duomenų eilutė būtų nuskaityta kaip pavadinimai, ties užrašu „Heading“ turi būti pasirinkta „Yes“ (\\(C_1\\)) Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["stat-testai-2.html", "10. ANOVA ir jos analogai 10.1 Kas yra ANOVA? 10.2 Išsamios ANOVA analizės aspektai 10.3 Programos kodai analizei 10.4 Pavyzdys 1: kai duomenys normalieji ir dispersijos lygios 10.5 Pavyzdys 2: kai duomenys normalieji, bet dispersijos nėra lygios 10.6 Pavyzdys 3: neparametrinis kriterijus 2 ir daugiau grupėms lyginti 10.7 Video pavyzdys", " 10. ANOVA ir jos analogai Užsiėmimo tikslas – susipažinti su statistinių hipotezių tikrinimo būdais dviems ar daugiau imčių taikant dispersinę analizę (ANOVA) ar jai analogiškus statistinius kriterijus. Atsisiųskite naujausią paketo biostat versiją: install.packages(&quot;devtools&quot;) # Atsisiųskite iš saugyklos „GitHub“: devtools::install_github(&quot;GegznaV/biostat&quot;) # Versija 0.0.18 ar naujesnė. devtools::install_github(&quot;GegznaV/RcmdrPlugin.biostat&quot;) # Versija 0.0.20 ar naujesnė. # Bei iš saugykols „CRAN“: install.packages(&quot;PMCMR&quot;) Šio darbo metu reikalingi R paketai: # Manipuliacija su duomenimis library(tidyverse) # Analizės ir grafikų braižymo funkcijos library(biostat) library(Rcmdr) # Grafikams library(ggplot2) # Neparametriniai post-hoc kriterijai library(PMCMR) 10.1 Kas yra ANOVA? ANOVA yra trumpasis dispersinės analizės (angl. ANalysis Of VAriance) pavadinimas. ANOVA – tai t kriterijaus analogas, kai norima palyginti dviejų ar daugiau nepriklausomų imčių (grupių) vidurkius. Sakykime, kad lyginame \\(k\\) grupių. Nulinė analizės hipotezė teigia, kad visų grupių vidurkiai lygūs, o jos alternatyva – bent dviejų grupių (kurių tiksliai – pasakyti negalima) vidurkiai skiriasi: Čia \\(i\\) ir \\(j\\) – lyginamų grupių numeriai. Atlikdami ANOVA pagal dispersijas tikriname, ar skirtumai tarp vidurkių yra statistiškai reikšmingi. Jei norime patikrinti, ar skirtumai tarp dispersijų yra reikšmingi, naudojame Levene (Livyno) kriterijų. Praktiškai žiūrint, ši analizė taikoma norint atsakyti į tokius klausimus: ar kelių skirtingų irisų rūšių vidutiniai žiedlapių dydžiai skiriasi, ar kelių gydymo metodų efektyvumas skiriasi, ar ląstelės, auginamos keliose skirtingose terpėse, yra linkusios būti skirtingo dydžio. Atkreipkite dėmesį, kad yra keli ANOVA variantai. Kai lyginimas atliekamas pagal vieną kategorinį kintamąjį (t. y., pagal vieną faktorių), ANOVA vadinama vienfaktore. Jei pagal du – dvifaktorė ir t.t. Yra ir specialių ANOVA variantų, skirtų priklausomoms imtims, pvz., blokuotųjų duomenų ANOVA, bei neparametrinių variantų, pvz., Kruskal-Wallis kriterijus. Šių pratybų metu mokysimės taikyti tik vienfaktorės ANOVA modelį, skirtą nepriklausomoms duomenų imtims, bei šio modelio analogus, kai pažeidžiamos klasikinio vienfaktorės ANOVA modelio prielaidos. 10.1.1 Kurį vienfaktorės ANOVA variantą ar analogą pasirinkti? Vienfaktorė ANOVA analizė grindžiama šiomis prielaidomis: Grupių duomenys yra nepriklausomi; Kiekvienos grupės kintamieji pasiskirstę normaliai (\\(X_{gr} \\sim \\mathcal{N}(\\mu_{gr},\\sigma^2_{gr})\\)); Grupių dispersijos yra lygios. Tad prieš atliekant ANOVA, reikia patikrinti duomenims keliamas prielaidas ir pasirinkti tinkamą analizės variantą ar neparametrinį jos analogą (pav. 10.1). Kai duomenų grupės yra nepriklausomos ir jų yra bent 3, įprastai renkamasi tarp klasikinės vienfaktorės ANOVA analizės, Welch F (Velčo F) kriterijaus (dar vadinamo Welch ANOVA), kai pažeidžiama lygių dispersijų prielaida, ir Kruskal-Wallis (Kruskalo-Voliso) kriterijaus, kai smarkiai pažeidžiama normalumo prielaida. Parametriniai metodai – klasikinė ANOVA ir Walch F kriterijus – lygina duomenų vidurkius (vidurkis yra normaliojo skirstinio parametras), todėl aprašant šios analizės rezultatus reikia nurodyti grupių vidurkius. Tuo tarpu Kruskal-Wallis kriterijaus yra neparametrinis, bendresnis ir lygina, ar duomenų skirstiniai pagal savo padėtį skiriasi, t. y., ar bent viena grupė yra linkusi būti mažesnė arba didesnė už kitas. Aprašant Kruskal-Wallis analizės rezultatus nurodomos visų grupių medianos. Schema yra supaprastinta ir tik rekomendacinio pobūdžio. Jos tikslas – būti „atspirties tašku“ renkantis analizės metodą. Konkrečiu atveju gali būti išlygų, papildomų sąlygų arba pasirinkimo variantų, kurie schemoje nepažymėti. Pav. 10.1: Centro padėties lyginimas kelioms imtims. Schema, padedanti išsirinkti reikiamą vienfaktorės nepriklausomų imčių (grupių) ANOVA variantą ar jos analogą. Apatinėje dalyje pateikiami keli galimi post-hoc analizės variantai, skirti grupes lyginti poromis. Skaičiais pažymėtų schemos dalių paaiškinimas pateiktas tekste žemiau. Skaičiais pažymėtų 10.1 schemos dalių paaiškinimai: Jei imčių dydžiai vienodi arba panašūs, ANOVA atspari mažiems ir net vidutiniams normalumo ir lygių dispersijų prielaidų pažeidimams. Sprendžiant „iš akies“, dispersijos (ne standartiniai nuokrypiai) neturėtų skirtis daugiau kaip 3 kartus. „Vienodos formos“ reiškia, kad visų grupių skirstinių asimetrija (jei yra) – vienos krypties, o sklaida (dispersijos) – daugmaž vienoda. Jei visų grupių skirstinių forma vienoda ir skiriasi tik poslinkio parametru, t. y., skiriasi skirstinio padėtis (tokiems duomenims ir rekomenduojamas Kruskal-Wallis kriterijus), tada galime daryti išvadas apie grupių medianas. Šiuo atveju analizės rezultatai informatyvesni nei 5 punkto atveju. Jei lyginamų grupių skirstinių forma skirtinga (skiriasi dispersijos, būdinga skirtingos krypties asimetrija), išvadas darome tik apie tai, kad bent viena grupė yra linkusi būti kitokia (arba didesnė, arba mažesnė) nei kitos. Techniškai kalbant, išvadas darome tik apie vidutinius rangus, bet ne medianas. Todėl šie rezultatai mažiau informatyvūs nei 4 punkto atveju. Apie galimus ANOVA post-hoc analizės variantus: Tukey HSD (angl. honestly significant difference) kriterijaus taikymui duomenys turi būti normalieji, dispersijos lygios, o imties dydžiai vienodi; Games-Howell kriterijaus taikymui duomenys turi būti normalieji, tačiau lygių dispersijų ir vienodų imties dydžių nereikalaujama. Kiekvienoje lyginamoje imtyje turi būti bent 6 nariai; Galima atlikti keletą nepriklausomų imčių (Stjudento ar Welch) t kriterijaus taikymo procedūrų, bet būtina naudoti daugybinių lyginimų p reikšmių korekcijos metodus (Holm, Bonferroni ar kitą procedūrą, kuri gali būti atlikta naudojant funkciją p.adjust()); Yra ir kitų čia nepaminėtų post-hoc kriterijų. Apie galimus Welch ANOVA post-hoc analizės variantus: Games-Howell kriterijui duomenys turi būti normalieji, tačiau lygių dispersijų ir vienodų imties dydžių nereikalaujama. Kiekvienoje lyginamoje imtyje turi būti bent 6 nariai; Galima keletą kartų taikyti Welch t kriterijų grupių poroms, bet būtina naudoti daugybinių lyginimų p reikšmių korekcijos metodus (Holm, Bonferroni ar kitą procedūrą, kuri gali būti atlikta naudojant funkciją p.adjust()); Yra kitų čia nepaminėtų kriterijų. Šie kriterijai privalo nereikalauti lygių dispersijų prielaidos. Apie galimus Kruskal-Wallis kriterijaus post-hoc analizės variantus: Galima taikyti arba Conover-Iman, arba Dunn kriterijų. Tačiau Conover-Iman kriterijus yra galingesnis. Bet kuriuo atveju gautoms p reikšmėms reikia atlikti Holm ar kitą daugybinių lyginimų p reikšmių korekciją (šiame skyrelyje nurodytas metodas tokią korekciją atlieka automatiškai). Galima keletą kartų grupių poroms taikyti nepriklausomų imčių Mann-Whitney-Wilcoxon kriterijų, bet tokiu atveju būtina naudoti p reikšmių korekcijos metodus (Holm, Bonferroni ar kitą procedūrą, kuri gali būti atlikta naudojant, funkciją p.adjust()); Yra kitų čia nepaminėtų kriterijų. Jie privalo būti neparametriniai ir tikti nenormaliesiems duomenims. Tai schema 9.8. Jei imčių didumai yra vienodi (arba panašūs), vienfaktorė ANOVA yra ganėtinai atspari nedideliems ir netgi vidutiniams nuokrypiams nuo pasiskirstymo normalumo ir lygių dispersijų (dispersijų homogeniškumo) prielaidų. 10.2 Išsamios ANOVA analizės aspektai Šiame skyriuje bus pateikti atskiri vienfaktorės ANOVA ar į ją panašios analizės aspektai. 10.2.1 Eiga Jei reikia atlikti ANOVA ar į ją panašią analizę, rekomenduojama tokia eiga: tiksliai apsibrėžiamas klausimas; atliekama duomenų suvestinė ir nubraižomas grafikas, galintis padėti atsakyti į iškeltą klausimą; patikrinamos analizės prielaidos: ar duomenų imtys/grupės nepriklausomos: sprendžiame pagal tai, kaip buvo suplanuotas ir atliktas eksperimentas. ar duomenų pakankamai daug: geriausia, kai kiekvienoje grupėje bent po 15, jei grupių daug – bent po 20 atvejų; kitu atveju duomenys privalo skirstytis idealiai normaliai, grupių dispersijos tik nežymiai skirtis; jei duomenų per mažai, negalime patikimai patikrinti parametriniams kriterijams keliamų prielaidų: mažoms imtims/grupėms statistiniai kriterijai linkę rodyti, kad skirtumai yra statistiškai nereikšmingi net esant dideliems skirtumams; didelėms imtims/grupėms net maži skirtumai bus pripažįstami statistiškai reikšmingais. mažoms imtims geriau taikyti neparametrinius kriterijus; kiekvienos imties/grupės pasiskirstymo normalumo prielaida: ir į vieną liniją išsidėstę qq diagramos taškai, ir Shapiro-Wilk kriterijaus \\(p\\ge0,05\\) rodo, kad normalumo prielaida tenkinama; gali būti, kad šių dvejų metodų rezultatai nesutaps: mažoms imtims statistiniai kriterijai yra linkę rodyti, kad nuokrypis nuo normalumo yra statistiškai nereikšmingas, net kai jis yra didelis, didelėms imtims net ir nedidelis nuokrypis nuo normalumo yra pripažįstamas statistiškai reikšmingas. prielaidos tikrinimą atliekame kiekvienai grupei atskirai (qq grafikai braižomi ir Shapiro-Wilk kriterijus atliekamas tiek kartų, kiek yra lyginamų grupių).. lygių dispersijų prielaida: jei ir Levene/Brown-Forsythe kriterijaus \\(p\\ge0,05\\), ir mažiausia bei didžiausia grupių dispersijos skiriasi mažiau nei 3 kartus, lygių dispersijų prielaida tenkinama; pastaba: mažoms grupėms statistiniai kriterijai bus linkę rodyti, kad dispersijų skirtumai (net labai dideli) nėra statistiškai reikšmingi; didelėms grupėms net ir menkiausi skirtumai bus pripažįstami statistiškai reikšmingais; dispersijas apskaičiuojame kiekvienai grupei atskirai, bet Levene/Brown-Forsythe kriterijų taikome tik vieną kartą, nes jis lygina visų grupių dispersijas iš karto. teisingai pasirenkama ir atliekama pagrindinė analizė; jei rezultatas statistiškai reikšmingas (rodo, kad bent viena grupė nuo kitų skiriasi statistiškai reikšmingai), atliekama papildoma post-hoc analizė (poriniai palyginimai norint išsiaiškinti, kurios konkrečiai grupės skiriasi). rezultatai aprašomi. 10.2.2 Klausimas Sakykime, kad tiriame augalus auginami tam trimis skirtingomis sąlygomis. Pradžioje formuluojame tyrimo klausimą: ar sausa augalo masė priklauso nuo auginimo sąlygų? Po to klausimą performuluojame į formuluotę, kuri panašesnė į statistines hipotezes: ar vidutinė sausa augalo masė skiriasi priklausomai nuo to, kokiomis sąlygomis augalas buvo augintas? Matematiškai klausimą galime išgryninti iki tokios formuluotės: ar skaitinio kintamojo reikšmės didumas priklauso nuo kategorinio kintamojo reikšmių? Atkreipkite dėmesį, kad ANOVA (ir kiti statistiniai kriterijai) gali padėti atsakyti į klausimą „Ar?“ (ar skirtumas statistiškai reikšmingas?), bet norint atsakyti į klausimą „Kiek?“ (kokio dydžio šis skirtumas?) reikia papildomos analizės. 10.2.3 Duomenys Pasirenkame ir užkrauname duomenis. Pavyzdžiuose duomenis užkrausime iš R paketų naudodami funkciją data(). (Duomenų aprašymas atidaromas naudojant kodą ?PlantGrowth). data(PlantGrowth) Savo tyrime duomenis užsikrausime ne naudodami funkciją data(), o RStudio ar R Commander langus arba duomenų bylų nuskaitymui skirtus kodus, nes duomenys bus pateikti tekstinėse (.txt, .csv, .dat), Excel’io (.xls, xlsx), R (.rds, .RData) ar kitokio tipo bylose. 10.2.4 Duomenų suvestinės Įsikėlę duomenis būtinai pasižiūrime į duomenų struktūrą, viršutines ir apatines eilutes, palyginame, ar teoriniai duomenų tipai (kategiriniai ir t.t.) atitinka R duomenų klases (pvz., factor). Jei neatitinka, atliekame korekcijas. Po to atliekamos duomenų suvestinės. Jas galima atlikti papildiniu R Commander. Šiuo atveju pateikti programos kodai. dplyr::glimpse(PlantGrowth) ## Observations: 30 ## Variables: 2 ## $ weight &lt;dbl&gt; 4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5... ## $ group &lt;fct&gt; ctrl, ctrl, ctrl, ctrl, ctrl, ctrl, ctrl, ctrl, ctrl, c... summary(PlantGrowth) ## weight group ## Min. :3.590 ctrl:10 ## 1st Qu.:4.550 trt1:10 ## Median :5.155 trt2:10 ## Mean :5.073 ## 3rd Qu.:5.530 ## Max. :6.310 Suvestinė pogrupiams (gali būti, kad jums lengviau ją atlikti naudojant R Commander). PlantGrowth %&gt;% group_by(group) %&gt;% summarize(n = n(), vidurkis = mean(weight) %&gt;% round(1), nupjautinis_vid = mean(weight, trim = 0.1) %&gt;% round(1), mediana = median(weight) %&gt;% round(1), dispersija = var(weight) %&gt;% round(2), sd = sd(weight) %&gt;% round(1), mad = mad(weight) %&gt;% round(1), min = min(weight) %&gt;% round(1), max = max(weight) %&gt;% round(1)) ## # A tibble: 3 x 10 ## group n vidurkis nupjautinis_vid mediana dispersija sd mad ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ctrl 10 5 5 5.2 0.34 0.6 0.7 ## 2 trt1 10 4.7 4.6 4.6 0.63 0.8 0.5 ## 3 trt2 10 5.5 5.5 5.4 0.2 0.4 0.4 ## # ... with 2 more variables: min &lt;dbl&gt;, max &lt;dbl&gt; Matome, kad yra 2 kintamieji: skaitinis ir kategorinis. Yra 3 skirtingos kategorijos. Duomenys yra nepriklausomi, nes tas pats augalas negali būti auginamas iš karto keliomis skirtingomis sąlygomis. Yra daugiau nei 2 grupės, pagal kurias norima lyginti skaitinį kintamąjį, vadinasi, tinka kažkuris ANOVA variantas arba analogiškas kriterijus. 10.2.5 Duomenų formatas: ilgasis Vienfaktorei ANOVA analizei, kaip ir kitoms nepriklausomų imčių (žr. skyriuje 5.1.1) analizėms, duomenys turi būti pateikti ilguoju formatu (žr. skyriuje 5.1.2). Jei turime ilgojo formato duomenis, juos pertvarkome naudodami funkciją gather() iš paketo dplyr arba naudodami R Commander meniu (pav. 10.2 bei pav. 10.3). Pav. 10.2: Duomenų vertimas iš plačiojo formato į ilgąjį naudojant standartinį R Commander meniu. Pav. 10.3: Duomenų vertimas iš plačiojo formato į ilgąjį naudojant R Commander meniu „BioStat’18“. Šis būdas išlaiko visus kintamuosius, kurie nėra pertvarkomi, yra labiau automatizuotas, turi daugiau parinkčių nei pav. 10.2. 10.2.6 Modelio formulė Kai kurioms funkcijoms – ypač toms, kurios vykdo statistinę analizę – duomenis galime pateikti naudodami modelio formulę. Modelio formulę sudaro užrašas, kuriame naudojama bangelė, ir kokios dalys (pavyzdys): y ~ grupe, data = duomenys, kur duomenys yra duomenų lentelės pavadinimas, y ir grupe – toje lentelėje esančių kintamųjų pavadinimai (be kabučių). Užrašą y ~ grupe reiktų skaityti „y pagal grupe“. Pilnas užrašymas: funkcija(y ~ grupe, data = duomenys) Pavyzdys, kaip šiuo principu braižomi grafikai, pateiktas kitame skyrelyje: ten y tampa weigth, grupe → group, duomenys → PlantGrowth. 10.2.7 Grafikai ANOVA analizei atvaizduojamas duomenų pasiskirstymas pogrupiais. Tam tinka stačiakampės, branduolių tankio, smuikinės ir kitos diagramos. library(tidyverse) library(biostat) Naudodamiesi modelio formule nubraižysime stačiakampę diagramą: boxplot(weight ~ group, data = PlantGrowth) Pakete biostat yra analogiška funkcija, suteikianti daugiau informacijos. biostat::gg_boxplot_plus(weight ~ group, data = PlantGrowth) + labs(x = &quot;Grupė&quot;, y = &quot;Svoris&quot;, title = &quot;Sauso augalų svorio pasiskirstymas&quot;) Funkcija gg_boxplot_plus() nubraižo grafiką, kuriame pažymėtas vidurkis su savirankos metodu apskaičiuotu pasikliauties intervalu, stačiakampė diagrama ir x ašyje pasklaidyti (vengiama persidengimo) duomenų taškai. Grupes galima išdėlioti pagal grupių medianos dydį: biostat::gg_boxplot_plus(weight ~ group, data = PlantGrowth, sort_groups = &quot;ascending&quot;, sort_fun = median) 10.2.8 Duomenų pasiskirstymo normalumo tikrinimas grupėms Šiam tikslui siūlau naudoti iš karto 2 būdus – statistinį kriterijų ir grafinį metodą. Shapiro-Wilk kriterijus: biostat::test_normality(weight ~ group, data = PlantGrowth, test = &quot;Shapiro-Wilk&quot;) ## ## The results of Shapiro-Wilk normality test ## ## group statistic p.value ## 1 ctrl 0.957 0.747 ## 2 trt1 0.930 0.452 ## 3 trt2 0.941 0.564 ## ## *** - p &lt; 0.001, ** - p &lt; 0.01, * - p &lt; 0.05, . - p &lt; 0.1 Įprastai, kai \\(p \\ge 0.05\\), laikoma, kad normalumo prielaida tenkinama (nuokrypiai nuo normalumo nėra statistiškai reikšmingi). QQ grafikų braižymas naudojant paketo biostat funkcijas: biostat::qq_plot(weight ~ group, data = PlantGrowth, use_colors = TRUE) Įprastai, kai qq diagramos taškai išsidėstę į vieną tiesę arba nuo jos nukrypę nedaug, laikoma, kad normalumo prielaida tenkinama. Daugiau informacijos apie normalumo tikrinimą skyriuose 7.7 (teorija), 9.3.1 (pavyzdys, kaip atlikti naudojant R Commander). 10.2.9 Dispersijų homogeniškumo tikrinimas Lygių dispersijų prielaida (dar vadinama dispersijų homogeniškumu ar homoskedastiškumu), kai grupių yra dvi ar daugiau, gali būti tikrinama Levene’o (Livyno) / Brown-Forsythe kriterijais (pirmu atveju centras – vidurkis, antru – mediana). Šiais kriterijais tikrinamos hipotezės: Kriterijaus taikymas programiškai: car::leveneTest(weight ~ group, data = PlantGrowth) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 2 1.1192 0.3412 ## 27 Levene’o / Brown-Forsythe kriterijaus rezultatų lentelėje labiausiai mus dominantis dalykas yra p reikšmė. Ji pateikta stulpelyje Pr(&gt;F) ir yra lygi 0.34 (suapvalinta). Šis rezultatas rodo, kad skirtumas tarp dispersijų nėra statistiškai reikšmingas. Pav. 10.4: Levene ir Brown-Forsythe testai naudojant R Commander. Daugiau informacijos apie kriterijus dispersijų homogeniškumui tikrinti pateikta skyriuje 9.3.2. 10.2.10 Tinkamo ANOVA varianto ar analogo pasirinkimas Ši tema nagrinėjama 10.1.1 skyriuje. 10.2.11 Kompaktiškas raidinis žymėjimas (cld) Sakykime, kelias grupes lyginame poromis. Statistiškai reikšmingus rezultatus tarp grupių, kai lyginimų daug, galime pažymėti taip vadinamu kompaktišku raidiniu žymėjimu (angl., compact letter display, cld). Šio žymėjimo esmė: kiekvienai grupei suteikiama viena ar keletas raidžių. Interpretacija: su pasirinktu pasikliovimo lygmeniu \\(\\alpha\\) galime teigti, kad tarp grupių, kurios neturi bendros raidės, skirtumai yra statistiškai reikšmingi. Jei grupės turi bendrą raidę – skirtumai statistiškai nereikšmingi. Raidinis žymėjimas labai patogus, kai vienu metu poromis lyginame daug grupių. Lentelė 10.1: Kompaktiško raidinio žymėjimo (cld) pavyzdys lyginant grupes trt1, trt2, ctrl. group cld spaced_cld ctrl ab ab trt1 a a_ trt2 b _b Lentelėje 10.1 rodoma, kad statistiškai reikšmingi skirtumai tik tarp grupių trt1 ir trt2, nes jos neturi bendros raidės. Pažymėjimą cld būdu galima atidėti grafikuose. Paketo biostat funkcija tai gali padaryti automatiškai: rez_tukey &lt;- biostat::posthoc_anova(weight ~ group, data = PlantGrowth, method = &quot;Tukey&quot;) cld_tukey &lt;- biostat::make_cld(rez_tukey) # Įdedame „cld“ objektą biostat::gg_boxplot_plus(weight ~ group, data = PlantGrowth, cld = cld_tukey) 10.2.12 Rezultatų aprašymas Aprašant ANOVA arba Welch ANOVA (Welch F kriterijaus) rezultatus įprasta nurodyti visų grupių vidurkius. Jei grupių daug – vidurkiai nurodomi lentele. Aprašant neparametrinio Kruskal-Wallis kriterijaus rezultatus nurodomos visų grupių medianos. Taip pat nurodomas kriterijaus pavadinimas, kriterijaus statistika, parametrai ir p reikšmė. ANOVA rezultatai Taip pat pateikiamas taikytos analizės pavadinimas, kriterijaus statistika F, abu jos laisvės laipsniai (tiek skaitiklio, angl. numerator, tiek vardiklio, angl. denominator) ir p reikšmė 3-4 skaičių po kablelio tikslumu. Pvz., skyrelio 10.4.1 rezultatai: ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## group 2 3.766 1.8832 4.846 0.0159 * ## Residuals 27 10.492 0.3886 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Stulpelyje Df pateikti laisvės laipsniai, F value – F statistika, Pr(&gt;F) – p reikšmė. Šių rezultatų aprašymo pavyzdys: „Skirtumai tarp grupių vidurkių buvo statistiškai reikšmingi (ANOVA, F(2, 27) = 4.846, p = 0.0159). Grupių vidurkiai pateikti lentelėje /nurodome lentelės numerį/“. Papildomai reiktų nurodyti grupių vidurkius ir, geriausia, pateikti grafiką su grupių palyginimu. Welch ANOVA rezultatai Welch ANOVA rezultatų pavyzdys ir 10.3.2 skyrelio: ## ## One-way analysis of means (not assuming equal variances) ## ## data: fscore and fcategory ## F = 90.59, num df = 2.000, denom df = 25.563, p-value = 2.494e-12 Čia F – F statistika, num df – skaitiklio laisvės laipsniai, denom df – vardiklio laisvės laipsniai, p-value – p reikšmė. Tad analizės rezultatai turėtų būti apibūdinti taip: „(Welch F kriterijus, F(2, 25.563) = 90.59, p &lt; 0.0001)“. Kruskal-Wallis analizės rezultatai Aprašant neparametrinio Kruskal-Wallis kriterijaus rezultatus pateikiamas kriterijaus pavadinimas, kriterijaus statistika \\(\\chi^2\\), jos laisvės laipsniai bei p reikšmė bent 3 skaičių po kablelio tikslumu. Jei p reikšmė labai maža, tai ją rašome maždaug taip p&lt;0.001 ar p&lt;0.0001. Pvz., skyrelio 10.6.1 rezultatai, kuriuos programa R atspausdino taip: ## ## Kruskal-Wallis rank sum test ## ## data: Ozone by Month ## Kruskal-Wallis chi-squared = 29.267, df = 4, p-value = 6.901e-06 Aprašymas turėtų atrodyti maždaug taip: „Skirtumai tarp grupių buvo statistiškai reikšmingi (Kruskal-Wallis kriterijus, \\(\\chi^2(4)\\) = 29.27, p &lt; 0.0001). Grupių pasiskirstymas vaizduojamas grafike /nurodome grafiko numerį/, skaitinės suvestinės pateiktos lentelėje /nurodome lentelės numerį/“. Reikšmė chi-squared nurodo \\(\\chi^2\\) statistiką, df – parametrą pavadinimu „laisvės laipsniai“, p-value – p reikšmę. Papildomai turėtų būti pateiktos visų grupių medianos ir, geriausia, grafikai. Post-hoc analizės rezultatai Jei atlikta post-hoc analizė, jos rezultatai taip pat aprašomi ir tai daroma panašiai kaip ir t ar Wilcoxon kriterijų aprašymo atvejais. Tiksliai apibūdinamas ir analizės metodas, ir p reikšmių korekcijos metodas (jei jis taikytas). Nurodom, kurių būtent porų lyginimo rezultatas pateikiamas. Jei rezultatų daug – jie gali būti pateikiami lentele. Rekomenduoju naudoti cld žymėjimus (skyrelis 10.2.11) ir paaiškinti, ką tie žymėjimai reiškia. 10.3 Programos kodai analizei Pateikti analizę atliekančių programos kodų pavyzdžiai. Juose esančius kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims: my_data – duomenų lentelės pavadinimas (be kabučių); y – skaitinio kintamojo iš šios lentelės pavadinimas (be kabučių); group – kategorinio kintamojo iš šios lentelės pavadinimas (be kabučių). Sakykime, jei jūs tiriate ląstelių skaičiaus pasiskirstymą (kintamasis skaičius) ląsteles augindami skirtingose terpėse (kintamasis terpė), o duomenys įrašyti duomenų lentelėje ląstelės, tada vietoje y ~ group, data = my_data turite rašyti skaičius ~ terpė, data = ląstelės. 10.3.1 ANOVA Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Analizė model_anova &lt;- aov(y ~ group, data = my_data) model_anova_summary &lt;- summary(model_anova) # Rezultatų spausdinimas print(model_anova_summary) 10.3.2 Welch ANOVA (Welch F kriterijus) Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Analizė model_welch_anova &lt;- oneway.test(y ~ group, data = my_data) # Rezultatų spausdinimas print(model_welch_anova) 10.3.3 Kruskal-Wallis kriterijus Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Analizė model_kw_test &lt;- kruskal.test(y ~ group, data = my_data) # Rezultatų spausdinimas print(model_kw_test) 10.3.4 Post-hoc: Tukey HSD kriterijus Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Paketai library(biostat) # Analizė model_tukey &lt;- posthoc_anova(y ~ group, data = my_data, method = &quot;Tukey&quot;) # Rezultatų apibendrinimas „cld“ žymėjimais cld_tukey &lt;- make_cld(model_tukey) # Rezultatų spausdinimas print(model_tukey) print(cld_tukey) # Grafikas su „cld“ žymėjimais gg_boxplot_plus(y ~ group, data = my_data, cld = cld_tukey) 10.3.5 Post-hoc: Games-Howell kriterijus Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Paketai library(biostat) # Analizė model_gh &lt;- posthoc_anova(y ~ group, data = my_data, method = &quot;Games-Howell&quot;) # Rezultatų apibendrinimas „cld“ žymėjimais cld_gh &lt;- make_cld(model_gh) # Rezultatų spausdinimas print(model_gh) print(cld_gh) # Grafikas su „cld“ žymėjimais gg_boxplot_plus(y ~ group, data = my_data, cld = cld_gh) 10.3.6 Post-hoc: Conover-Iman kriterijus Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Paketai library(biostat) library(PMCMR) # Analizė model_conover_iman &lt;- posthoc.kruskal.conover.test(y ~ group, data = my_data) # Rezultatų apibendrinimas „cld“ žymėjimais cld_conover_iman &lt;- make_cld(model_conover_iman) # Rezultatų spausdinimas print(model_conover_iman) print(cld_conover_iman) # Grafikas su „cld“ žymėjimais gg_boxplot_plus(y ~ group, data = my_data, cld = cld_conover_iman) 10.4 Pavyzdys 1: kai duomenys normalieji ir dispersijos lygios 10.4.1 ANOVA (pagrindinė analizė) Pavyzdys: library(tidyverse) data(PlantGrowth) ?PlantGrowth glimpse(PlantGrowth) ## Observations: 30 ## Variables: 2 ## $ weight &lt;dbl&gt; 4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5... ## $ group &lt;fct&gt; ctrl, ctrl, ctrl, ctrl, ctrl, ctrl, ctrl, ctrl, ctrl, c... head(PlantGrowth) ## weight group ## 1 4.17 ctrl ## 2 5.58 ctrl ## 3 5.18 ctrl ## 4 6.11 ctrl ## 5 4.50 ctrl ## 6 4.61 ctrl summary(PlantGrowth) ## weight group ## Min. :3.590 ctrl:10 ## 1st Qu.:4.550 trt1:10 ## Median :5.155 trt2:10 ## Mean :5.073 ## 3rd Qu.:5.530 ## Max. :6.310 boxplot(weight ~ group, data = PlantGrowth) Normalumo prielaidos tikrinimas. Tam geriausia naudoti kelis metodus: biostat::qq_plot(weight ~ group, data = PlantGrowth, use_colors = TRUE) biostat::test_normality(weight ~ group, data = PlantGrowth) ## ## The results of Shapiro-Wilk normality test ## ## group statistic p.value ## 1 ctrl 0.957 0.747 ## 2 trt1 0.930 0.452 ## 3 trt2 0.941 0.564 ## ## *** - p &lt; 0.001, ** - p &lt; 0.01, * - p &lt; 0.05, . - p &lt; 0.1 Pagal qq diagramą grupėje „trt1“ yra keli nedaug nukrypę taškai. Bet pagal Shapiro-Wilk kriterijų nuokrypis nėra statistiškai reikšmingas. Tad, atrodo, normalumo prielaida tenkinama. Dispersijų homogeniškumo prielaidos tikrinimas: car::leveneTest(weight ~ group, data = PlantGrowth) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 2 1.1192 0.3412 ## 27 Brown-Forsythe kirterijaus (Levene kriterijus, kai centras – mediana) rezultatai lygių dispersijų prielaidai neprieštarauja (p reikšmė \\(Pr(&gt;F) = 0.34 \\ge \\alpha = 0.05\\)). ANOVA analizė: anova_modelis &lt;- aov(weight ~ group, data = PlantGrowth) summary(anova_modelis) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## group 2 3.766 1.8832 4.846 0.0159 * ## Residuals 27 10.492 0.3886 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ANOVA rodo, kad bent viena grupė nuo kitų statistiškai reikšmingai skiriasi \\(p = 0.0159&lt;0.05\\) (šie ANOVA rezultatai aprašyti skyriuje 10.2.12). Todėl verta atlikti porinius lyginimus. 10.4.2 Tukey kriterijus (post-hoc analizė) Jei duomenys normalieji, imčių dispersijos yra lygios, ir visų lyginamų grupių dydžiai (daugmaž) vienodi, Tukey HSD kriterijus yra tinkamas naudoti kaip ANOVA post-hoc analizė, kurios metu atliekami poriniai palyginimai. rez_tukey &lt;- biostat::posthoc_anova(weight ~ group, data = PlantGrowth, method = &quot;Tukey&quot;) rez_tukey ## Tukey HSD test results (ANOVA post-hoc) ## ## groups difference ci_lower ci_upper t df p ## 1 trt1-ctrl -0.371 -1.062 0.320 1.33 27.00 0.391 ## 2 trt2-ctrl 0.494 -0.197 1.185 1.77 27.00 0.198 ## 3 trt2-trt1 0.865 0.174 1.556 3.10 27.00 0.012 * ## ## group n mean variance sd cld spaced_cld ## 1 ctrl 10 5.032 0.340 0.583 ab ab ## 2 trt1 10 4.661 0.630 0.794 a a_ ## 3 trt2 10 5.526 0.196 0.443 b _b Svarbiausi rezultatai: groups – lyginamos grupės; difference – skirtumai tarp vidurkių (pagal jį galime spręsti apie praktinę naudą); ci_lower, ci_upper – skirtumo pasikliautinasis intervalas; t – testo statistika; df – parametras; p – p reikšmė; cld – kompaktiškas raidinis žymėjimas. Kompaktiškas raidinis žymėjimas (cld) atidedamas grafike: library(ggplot2) cld_tukey &lt;- biostat::make_cld(rez_tukey) biostat::gg_boxplot_plus(weight ~ group, data = PlantGrowth, cld = cld_tukey, sort_groups = &quot;ascending&quot;, sort_fun = mean) + labs(title = &quot;Svorio pasiskirstymas grupėmis&quot;, subtitle = &quot;Grupės išdėstytos vidurkių didėjimo tvarka&quot;, x = &quot;Grupė&quot;, y = &quot;Svoris&quot;, # Spalvų legendos pavadinimas fill = &quot;Grupė&quot;, color = &quot;Grupė&quot;) Su pasirinktu reikšmingumo lygmeniu \\(\\alpha\\), tarp grupių, kurios pažymėtos ta pačia raide, skirtumai nėra statistiškai patikimi. T. y. trt1 ir trt2 skiriasi statistiškai reikšmingai, o visi kiti skirtumai – nereikšmingi. 10.5 Pavyzdys 2: kai duomenys normalieji, bet dispersijos nėra lygios 10.5.1 Welch ANOVA (pagrindinė analizė) Pavyzdys: library(tidyverse) data(Moore, package = &quot;carData&quot;) ?Moore glimpse(Moore) ## Observations: 45 ## Variables: 4 ## $ partner.status &lt;fct&gt; low, low, low, low, low, low, low, low, low, lo... ## $ conformity &lt;int&gt; 8, 4, 8, 7, 10, 6, 12, 4, 13, 12, 4, 13, 7, 9, ... ## $ fcategory &lt;fct&gt; low, high, high, low, low, low, medium, medium,... ## $ fscore &lt;int&gt; 37, 57, 65, 20, 36, 18, 51, 44, 31, 36, 42, 56,... head(Moore) ## partner.status conformity fcategory fscore ## 1 low 8 low 37 ## 2 low 4 high 57 ## 3 low 8 high 65 ## 4 low 7 low 20 ## 5 low 10 low 36 ## 6 low 6 low 18 Atliekame tik mus dominančių kintamųjų suvestinę: Moore %&gt;% select(fscore, fcategory) %&gt;% summary() ## fscore fcategory ## Min. :15.00 high :15 ## 1st Qu.:35.00 low :15 ## Median :43.00 medium:15 ## Mean :43.11 ## 3rd Qu.:55.00 ## Max. :68.00 biostat::gg_boxplot_plus(fscore ~ fcategory, data = Moore) Iš grafiko galime matyti, kad grupių vidurkiai skiriasi, bet jų dispersijos nėra lygios, nes dėžutės skirtingo dydžio. Tikrinam normalumo prielaidą. Tam geriausia naudoti kelis metodus: biostat::test_normality(fscore ~ fcategory, data = Moore) ## ## The results of Shapiro-Wilk normality test ## ## fcategory statistic p.value ## 1 high 0.932 0.293 ## 2 low 0.884 0.055 . ## 3 medium 0.890 0.067 . ## ## *** - p &lt; 0.001, ** - p &lt; 0.01, * - p &lt; 0.05, . - p &lt; 0.1 biostat::qq_plot(fscore ~ fcategory, data = Moore) Duomenys normalumo prielaidą tenkina, nors yra ir ne visiško normalumo požymių. Tikrinam dispersijų homogeniškumo (t. y., lygių dispersijų) prielaidą: car::leveneTest(fscore ~ fcategory, data = Moore) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 2 6.9845 0.002406 ** ## 42 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Lygių dispersijų prielaida aiškiai pažeista \\(p = 0.002406&lt;0.05\\) Welch ANOVA analizė: oneway.test(fscore ~ fcategory, data = Moore) ## ## One-way analysis of means (not assuming equal variances) ## ## data: fscore and fcategory ## F = 90.59, num df = 2.000, denom df = 25.563, p-value = 2.494e-12 Rezultatas – statistiškai reikšmingas skirtumas (\\(p = 2.5 \\cdot10^{-12} &lt; \\alpha =0.05\\)). Todėl verta atlikti post-hoc analizę. 10.5.2 Games-Howell kriterijus (post-hoc analizė) Jei imčių dispersijos nėra lygios, bet duomenys yra daugmaž normalieji, Games-Howell kriterijus yra tinkamas atlikti Welch ANOVA post-hoc analizę (porinius palyginimus). rez_games_howell &lt;- biostat::posthoc_anova(fscore ~ fcategory, data = Moore, method = &quot;Games-Howell&quot;) rez_games_howell ## Games-Howell test results (ANOVA post-hoc) ## ## groups difference ci_lower ci_upper t df p ## 1 low-high -31.600 -37.763 -25.437 12.85 22.85 &lt;0.001 *** ## 2 medium-high -14.667 -18.493 -10.841 9.55 24.99 &lt;0.001 *** ## 3 medium-low 16.933 11.115 22.752 7.40 18.69 &lt;0.001 *** ## ## group n mean variance sd cld spaced_cld ## 1 high 15 58.533 23.838 4.882 a a__ ## 2 low 15 26.933 66.924 8.181 b _b_ ## 3 medium 15 43.867 11.552 3.399 c __c Svarbiausių rezultatų aprašymas pateiktas skyriuje 10.4.2. Matome, kad tarp visų grupių skirtumai yra statistiškai reikšmingi. Kompaktiškas raidinis žymėjimas (cld) atidedamas grafike: library(ggplot2) cld_gh &lt;- biostat::make_cld(rez_games_howell) biostat::gg_boxplot_plus(fscore ~ fcategory, data = Moore, cld = cld_gh, sort_groups = &quot;ascending&quot;) + labs(title = &quot;Grupių palyginimo grafikas&quot;, subtitle = &quot;Grupės išdėstytos medianų didėjimo tvarka&quot;) Kiekvienai lyginamai grupei priskirtos cld žymėjimo raidės skirtingos, vadinasi – skirtumai tarp visų lygintų grupių yra statistiškai reikšmingi. 10.6 Pavyzdys 3: neparametrinis kriterijus 2 ir daugiau grupėms lyginti 10.6.1 Kruskal-Wallis kriterijus (pagrindinė analizė) Kruskal-Wallis kriterijus – tai neparametrinis ANOVA analogas, skirtas ranginiams arba normalumo kriterijaus netenkinantiems duomenims lygini. Į šį kriterijų taip pat galima žiūrėti kaip į apibendrintą Mann-Whitney-Wilcoxon kriterijaus variantą, kai imčių daugiau negu dvi. Pavyzdys: data(airquality) head(airquality) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 biostat::gg_boxplot_plus(Ozone ~ factor(Month), data = airquality, add_mean_ci = FALSE) ## Warning: Removed 37 rows containing non-finite values (stat_boxplot). ## Warning: Removed 37 rows containing missing values (geom_point). Pašalinome vidurkių pasikliautinuosius intervalus (add_mean_ci = FALSE), nes analizė, kurią naudosime, nelygina vidurkių. kruskal.test(Ozone ~ Month, data = airquality) ## ## Kruskal-Wallis rank sum test ## ## data: Ozone by Month ## Kruskal-Wallis chi-squared = 29.267, df = 4, p-value = 6.901e-06 Skirtumas yra statistiškai reikšmingas (bent viena grupė skiriasi nuo kitų), nes \\(p = 6.9\\cdot10^{-6} &lt; 0.05\\). Šie Kruskal-Wallis kriterijaus taikymo rezultatai aprašyti skyriuje 10.2.12. Atliekame post-hoc analizę. 10.6.2 Conover-Iman kriterijus (post-hoc analizė) Conover-Iman kriterijus naudojamas atlikti Kurskal-Wallis kriterijaus post-hoc analizę (porinius palyginimus). Conover-Iman kriterijų galima taikyti tada ir tik tada, kai Kurskal-Wallis kriterijaus taikymo rezultatai yra statistiškai reikšmingi. library(PMCMR) rez_conover &lt;- posthoc.kruskal.conover.test(Ozone ~ Month, data = airquality) ## Warning in posthoc.kruskal.conover.test.default(c(41L, 36L, 12L, 18L, ## 28L, : Ties are present. Quantiles were corrected for ties. rez_conover ## ## Pairwise comparisons using Conover&#39;s-test for multiple ## comparisons of independent samples ## ## data: Ozone by Month ## ## 5 6 7 8 ## 6 0.8843 - - - ## 7 1.9e-05 0.0721 - - ## 8 6.7e-05 0.1109 1.0000 - ## 9 0.5424 1.0000 0.0031 0.0084 ## ## P value adjustment method: holm Rezultatų apibendrinimas kompaktišku žymėjimu. cld_conover &lt;- biostat::make_cld(rez_conover) cld_conover ## group cld spaced_cld ## 1 5 a a_ ## 2 6 ab ab ## 3 7 b _b ## 4 8 b _b ## 5 9 a a_ Kompaktiškas raidinis žymėjimas (cld) gali būti pateiktas grafike. biostat::gg_boxplot_plus(Ozone ~ factor(Month), data = airquality, cld = cld_conover, cld_color = &quot;blue&quot;, add_mean_ci = FALSE) ## Warning: Removed 37 rows containing non-finite values (stat_boxplot). ## Warning: Removed 37 rows containing missing values (geom_point). 10.7 Video pavyzdys Šio pavyzdžio analizė skirta atsakyti į klausimą, ar skirtingų organų vėžiu sergančių žmonių išgyvenimo trukmė skiriasi. Duomenis galite atsisiųsti iš čia: duomenys . Preliminarus video epizodo siužetas: Susiformuojame klausimą, į kurį norime atsakyti. Duomenys jau yra parsiųsti ir įkelti į aplanką su RStudio projektu. Atsidarome projektą ir patikriname, ar jis tinkamai sukonfigūruotas. Atsidarome Rcmdr (reikalinga RcmdrPlugin.biostat versija 0.0.17 arba naujesnė). Įsikeliame duomenis iš reikiamo Excel bylos lapo ir apžiūrime juos. Duomenyse yra viena visiškai tuščia eilutė (vien tik NA reikšmės). Pašaliname tuščią eilutę. Duomenys nepriklausomi (nes kiekvienoje grupėje vis kiti pacientai), bet pateikti plačiuoju formatu, todėl pasiverčiame į ilgąjį. Išgyvenamumo trukmė pateikta dienomis. Ją pasiversime į metus padalindami iš 365 dienų metams. Nusibraižome duomenis, atliekame skaitinę suvestinę. Duomenų mažai, grupės skirtingo dydžio, duomenų pasiskirstymas nėra idealiai normalusis, todėl analizei pasirinktas neparametrinis Kruskal-Wallis (KW) kriterijus. Jis vykdomas nukopijuojant kodą iš pratybų tinklapio ir jį pritaikant savo reikmėms. KW analizės rezultatas rodo, kad yra statistiškai reikšmingas skirtumas bent tarp dviejų grupių, todėl atliekame porinius lyginimus nukopijuodami reikiamos post-hoc analizės kodą ir jį pakeisdami. Aprašome rezultatus (aprašymo pavyzdys pateiktas po video epizodu). Video epizodas 10.1 Vienfaktorės ANOVA tipo analizės pavyzdys, kai duomenys nėra normalieji. Duomenys pateikti panašiu formatu kaip ir įskaitinėje užduotyje apie žirnius. Pastaba: epizode nėra komentarų bei pasakojimo. Rezultatų aprašymas galėtų būti daugmaž toks: „Tirta žmonių, sergančių bronchų, krutų, kiaušidžių, skrandžio, žarnų vėžiu, išgyvenimo trukmė. Atlikus statistinę analizę paaiškėjo, kad ši trukmė sergant skirtingų organų vėžiu statistiškai reikšmingai skiriasi (Kruskal-Wallis kriterijus, \\(\\chi^2\\)(4) = 14.95, p = 0.005). Poriniai lyginimai (Conover-Iman post-hoc kriterijus su Holm korekcija p reikšmėms) atskleidė, kad statistiškai reikšmingai skiriasi krutų ir bronchų (p = 0.006) bei krutų ir skrandžio (p = 0.014) vėžiu sergančių pacientų išgyvenamumo trukmė. Abiem paminėtais atvejais sergantys krutų vėžiu išgyveno ilgiau (lentelė … bei pav. …).“ (Porinių lyginimų p reikšmės paimtos iš lentelės-matricos, kurią sugeneravo Conover-Iman analizę vykdančios funkcijos). Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["kintamuju-rysys.html", "11. Ryšys tarp kintamųjų 11.1 Bendrieji principai 11.2 Koreliacinė analizė 11.3 Sąsaja tarp kategorinių kintamųjų reikšmių 11.4 Ryšio tarp kintamųjų analizė naudojant R Commander", " 11. Ryšys tarp kintamųjų Užsiėmimo tikslas – išmokti įvertinti sąsajos tarp kintamojo reikšmių stiprumą. Šiame skyriuje bus mokoma atlikti analizę, kuria tiriamas ryšys (sąsaja) tarp kintamųjų. Tokia analizė gali padėti atsakyti į klausimą, ar pasikeitus vieno kintamojo reikšmėms, tikėtina, kad pasikeis ir kito kintamojo reikšmės. Pvz., nustatyti, ar yra ryšys tarp į terpę įdėtos gliukozės kiekio ir ląstelių dydžio, tarp padarytų pritūpimų skaičiaus ir pulso dažnumo, tarp ląstelių rūšies ir dydžio (didelės/mažos). 11.1 Bendrieji principai 11.1.1 Sąsaja neparodo priežastingumo Sąsaja tarp kelių kintamųjų reikšmių neparodo priežastingumo. Koreliacija neparodo priežastingumo. Tai, kad dviejų kintamųjų reikšmės yra susijusios ar koreliuoja, dar nereiškia, kad vienas kintamasis yra kito kintamojo priežastis. To nei koreliacinė, nei kitokia požymių nepriklausomumo analizė savaime neparodo. Ji pasako tik tai, kad kintant vieno požymio reikšmėms, kinta kito požymio reikšmės. Norint daryti priežastinio tipo išvadas būtinas tikslingai suplanuotas eksperimentas. (Prisiminkite, ko buvo mokoma „DataCamp“ kurso „Introduction to Data“ pamokose). 11.1.2 Statistinis sąryšio reikšmingumas Norint patikrinti, ar ryšys tarp kintamųjų yra statistiškai reikšmingas, tikrinama statistinė hipotezė, kuri bendruoju atveju, gali būti formuluojama taip: \\(H_0\\): dviejų požymių reikšmės nėra susijusios (skirtumo nėra); \\(H_1\\): dviejų požymių reikšmės yra susijusios (skirtumas yra). „Požymių reikšmės susijusios“ reiškia, kad žinodami vieno požymio reikšmes (ir jų kitimą) gauname papildomos informacijos ir apie kito požymio reikšmės (ir jų kitimą). Pvz., kad padidėjus vieno kintamojo reikšmėms (atliktų pritūpimų skaičiui), tikėtina, padidės ir kito kintamojo (pulso dažnis) reikšmės. Jei reikšmingumo lygmuo \\(\\alpha = 0,05\\), tai, kai: \\(p&lt;0.05\\), teigiame, kad požymiai susiję (priimame \\(H_1\\)); \\(p\\ge0.05\\), teigti, kad požymiai susiję negalime (neatmetame \\(H_0\\)). Koreliacinės analizės (kuri yra skirta įvertinti tiesinį arba monotoninį ryšį tarp skaitinių kintamųjų) atveju statistines hipotezes galima formuluoti taip: \\(H_0\\): koreliacijos koeficientas lygus nuliui, koreliacijos nėra; \\(H_1\\): koreliacijos koeficientas nelygus nuliui, kintamieji yra koreliuoti (dvipusė alternatyva). Galimos ir vienpusės alternatyvos: koreliacijos koeficientas mažesnis už nulį, kintamieji koreliuoti neigiamai (vienpusė alternatyva); koreliacijos koeficientas didesnis už nulį, kintamieji koreliuoti teigiamai (vienpusė alternatyva). Nors yra 3 alternatyvų variantai, jei neturime pagrindo rinktis kitaip, įprastai renkamės dvipusę. 11.1.3 Ryšio stiprumas Visiems šiame skyriuje minimiems ryšio matams (koreliacijos koeficientams ir kitiems) galioja tokios taisyklės: kuo absoliučioji koeficiento vertė didesnė, tuo priklausomybė tarp požymių reikšmių yra stipresnė; įprastai maksimali absoliučioji koeficientų vertė būna 1 (t. y., \\(|1|\\) arba \\(|-1|\\), čia \\(|...|\\) – modulio ženklas); kuo ši vertė arčiau nulio, tuo priklausomybė silpnesnė. 11.2 Koreliacinė analizė Koreliacinė analizė yra viena iš analizės rūšių, skirtų įvertinti statistinę sąsają (ryšį) tarp dviejų kintamųjų. Tinka, kai statistinis ryšys tarp kintamųjų yra monotoninis (negriežtai sakant, arba nuolat didėjantis, arba nuolat mažėjantis) ir netinka, kai ryšys yra kitokio pobūdžio (pvz., iš pradžių mažėja, o po to didėja, pvz., pav. 11.1 trečia eilutė). Iš to išplaukia, kad kintamieji turi būti skaitiniai arba ranginiai (bet turėti pakankamai daug skirtingų reikšmių. Kitu atveju naudojama kategorinių kintamųjų ryšiui tirti skirta analizė). Koreliacijos koeficientas parodo tiesinio (arba ranginio, jei ranginė koreliacija) sąryšio tarp 2 kintamųjų stiprumą: t. y., ar tikėtina, kad padidėjus vieno kintamojo reikšmėms, padidės (arba sumažės) ir kito kintamojo reikšmės (ką tai reiškia ir ko nereiškia vaizduojama pirmoje ir antroje pav. 11.1 eilutėse). Įprastai, jei neminima, apie kurį koreliacijos koeficientą kalbama, omenyje turimas Pearson (Pirsono) tiesinės koreliacijos koeficientas. Visgi aprašant savo tyrimo rezultatus rekomenduoju vengti dviprasmybės ir aiškiai nurodyti, kurį koreliacijos koeficientą naudojate. Keletas teiginių apie koreliacinę analizę: Koreliacijos koeficientas nepriklauso nuo kintamųjų matavimo vienetų. Kinta nuo -1 iki +1; Koeficiento ženklas: teigiamas koeficientas rodo tiesioginę priklausomybę (padidėjus X reikšmėms, tikėtina, padidėja ir Y reikšmės), neigiamas – atvirkštinę (padidėjus X reikšmėms, tikėtina, Y reikšmės sumažėja); Koreliacijos stiprumą rodo absoliučioji koeficiento reikšmė. Konkreti interpretacija priklauso nuo tyrimo srities. Preliminarus vertinimas pateiktas 11.1 lentelėje. Jei dydžiai koreliuoja, vadinasi – jie yra priklausomi, bet jei nekoreliuoja, tada gali būti visaip: ir priklausomi ir nepriklausomi. Koreliacija laikoma statistiškai reikšminga, kai p reikšmė yra maža (p &lt; 0,05, kai \\(\\alpha = 0,05\\)). Iš principo toks rezultatas rodo, kad koreliacijos koeficientas (žymėkime \\(\\varrho\\)) statistiškai reikšmingai skiriasi nuo 0 \\((\\varrho \\ne 0)\\). Pav. 11.1: Grafiškai atvaizduoti dviejų kintamųjų priklausomybės variantai (sklaidos diagramos) ir Pearson (Pirsono) koreliacijos koeficientas (skaičius virš grafikų). Kiekviena eilutė vaizduoja tam tikrus koreliacinės analizės aspektus. (1) Pirmoji eilutė – ką Pearson koreliacijos koeficientas parodo tiesinės sąsajos stiprumą, t. y., kuo sąsaja stipresnė, tuo glaudžiau taškai išsidėsto į vieną tiesę. (2) Antroji eilutė – ko neparodo, tai geriausiai taškus atitinkančios regresijos tiesės pokrypio kampo. (3) Trečioji eilutė – kada netinka: kai statistinė priklausomybė tarp kintamųjų nėra tiesinė, didėjant X reikšmėms, Y ir didėja, ir mažėja. Tokiais atvejais priklausomybė yra, bet koreliacijos koeficientas jos neparodys. Antros eilutės vidutiniam grafikui (horizontali linija) koreliacijos koeficientas negali būti apibrėžtas, nes y ašies reikšmių pokytis lygus nuliui. Iliustracijos šaltinis: (nuoroda), autorius: DenisBoigelot, licencija: Creative Commons, CC0. Lentelė 11.1: Preliminarus Pearson koreliacijos koeficiento vertinimas. Preliminarus koreliacijos vertinimas Koreliacijos koeficiento reikšmės koreliacijos nėra 0 labai silpna [-0.2; 0) arba (0; 0.2] silpna [-0.4; -0.2) arba (0.2; 0.4] vidutinė [-0.7; -0.4) arba (0.4; 0.7] stipri [-0.9; -0.7) arba (0.7; 0.9] labai stipri [-1.0; -0.9) arba (0.9; 1.0] tiesinis sąryšis -1 arba 1 11.2.1 Kurį koreliacijos variantą pasirinkti? Praktikoje dažniausiai naudojami keli koreliacinės analizės variantai: Tiesinė koreliacija (Pearson (Pirsono) koreliacijos koeficientas \\(\\varrho\\)) – tinka, kai duomenys visiškai normalieji, nėra išskirčių ir kai imties dydis didesnis nei 20: angl. Pearson product-moment. Ranginė koreliacija (Spearman (Spirmeno) koeficientas \\(\\varrho_s\\) arba Kendall (Kendalo) koeficientas \\(\\tau\\)) – tinka, kai duomenys nebūtinai normalieji arba ranginiai, bei kai stebėjimų skaičius mažas: Spirmeno ranginės koreliacijos koeficientas (angl. Spearman rank-order) – jautresnis duomenų neatitikimui ir klaidoms; Kendalo koreliacijos koeficientas (angl. Kendall’s tau) – mažiau jautrus klaidoms, lengviau interpretuojamas, esant mažai imčiai tiksliau apskaičiuojamos p reikšmės; Absoliučiąją reikšme Kendall koreliacijos koeficientas yra šiek tiek mažesnis už Spearman, bet padarytos išvados yra vienodai reikšmingos. Schemoje 11.2 pateikiamas siūlymas, kaip išsirinkti tinkamą koreliacinės analizės variantą. Jei duomenys tenkina reikiamas prielaidas, įprastai pasirenkamas Pirsono koreliacijos koeficientas. Schema yra supaprastinta ir tik rekomendacinio pobūdžio. Jos tikslas – būti „atspirties tašku“ renkantis analizės metodą. Konkrečiu atveju gali būti išlygų, papildomų sąlygų arba pasirinkimo variantų, kurie schemoje nepažymėti. Pav. 11.2: Schema, rekomenduojanti, kurį (Pearson, Spearman ar Kendall) koreliacijos koeficientą pasirinkti. 11.2.2 Rezultatų aprašymas: koreliacinė analizė Aprašant rezultatus nurodomas tikslus koreliacijos koeficiento pavadinimas, jo didumas, bei statistinį koreliacijos reikšmingumą apibūdinanti p reikšmė, jei reikia, nurodoma, ar vienpusė ar dvipusė alternatyva. Taip pat pateikiama sklaidos diagrama. Keli aprašymo pavyzdžiai pateikti skyriuje 11.2.3. 11.2.3 Pavyzdžiai Pradžioje bus pateikiamas programos kodas ir R rezultatai, po jų – rezultatų aprašymo pavyzdys. Pavyzdys 1 data(anorexia, package = &quot;MASS&quot;) glimpse(anorexia) ## Observations: 72 ## Variables: 3 ## $ Treat &lt;fct&gt; Cont, Cont, Cont, Cont, Cont, Cont, Cont, Cont, Cont, C... ## $ Prewt &lt;dbl&gt; 80.7, 89.4, 91.8, 74.0, 78.1, 88.3, 87.3, 75.1, 80.6, 7... ## $ Postwt &lt;dbl&gt; 80.2, 80.1, 86.4, 86.3, 76.1, 78.1, 75.1, 86.7, 73.5, 8... anorexia_long &lt;- gather(anorexia, &quot;laikas&quot;, &quot;svoris&quot;, Prewt, Postwt) test_normality(svoris ~ laikas, data = anorexia_long) ## ## The results of Shapiro-Wilk normality test ## ## laikas statistic p.value ## 1 Postwt 0.967 0.058 . ## 2 Prewt 0.992 0.948 ## ## *** - p &lt; 0.001, ** - p &lt; 0.01, * - p &lt; 0.05, . - p &lt; 0.1 cor.test(~ Prewt + Postwt, data = anorexia, method = &quot;pearson&quot;) ## ## Pearson&#39;s product-moment correlation ## ## data: Prewt and Postwt ## t = 2.9488, df = 70, p-value = 0.004334 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.1091425 0.5237424 ## sample estimates: ## cor ## 0.3324062 Aprašymo pavyzdys. „Atlikta 72 anoreksija sergančių pacienčių svorio prieš gydymą ir svorio po gydymo Pirsono koreliacinė analizė. Tarp šių kintamųjų pastebėta silpna teigiama koreliacija (r = 0,33, 95% PI 0,11–0,52, p = 0,004). Sąryšis tarp kintamųjų atvaizduotas pav. … (nurodote paveikslo numerį).“ arba „Tarp pacienčių svorio prieš ir po gydymo nustatyta silpna koreliacija (r = 0,33, 95% PI 0,11–0,52, p = 0,004).“ Taip pat turi būti nurodomi trumpinių paaiškinimai: n – imties dydis, r – Pirsono (Pearson) koreliacijos koeficientas, PI – pasikliautinasis intervalas. ggplot(anorexia, aes(x = Prewt, y = Postwt)) + geom_point() + labs(x = &quot;Svoris prieš gydymą, svarai&quot;, y = &quot;Svoris po gydymo, svarai&quot;) + geom_smooth(method = lm, se = FALSE) + # pridėta regresijos tiesė theme_classic() Pavyzdys 2 library(tidyverse) data(cabbages, package = &quot;MASS&quot;) glimpse(cabbages) ## Observations: 60 ## Variables: 4 ## $ Cult &lt;fct&gt; c39, c39, c39, c39, c39, c39, c39, c39, c39, c39, c39, ... ## $ Date &lt;fct&gt; d16, d16, d16, d16, d16, d16, d16, d16, d16, d16, d20, ... ## $ HeadWt &lt;dbl&gt; 2.5, 2.2, 3.1, 4.3, 2.5, 4.3, 3.8, 4.3, 1.7, 3.1, 3.0, ... ## $ VitC &lt;int&gt; 51, 55, 45, 42, 53, 50, 50, 52, 56, 49, 65, 52, 41, 51,... cor.test(~ HeadWt + VitC, data = cabbages, method = &quot;kendall&quot;) ## ## Kendall&#39;s rank correlation tau ## ## data: HeadWt and VitC ## z = -5.6745, p-value = 1.391e-08 ## alternative hypothesis: true tau is not equal to 0 ## sample estimates: ## tau ## -0.5169041 Aprašymo pavyzdys. „Tiriant sąsają tarp kopūsto galvos svorio ir vitamino C koncentracijos toje galvoje atlikta ranginė Kendall koreliacinė analizė, kuri atskleidė neigiamą vidutinio stiprumo koreliaciją tarp šių kintamųjų (\\(\\tau\\) = -0,52, p &lt; 0.001). Priklausomybė atvaizduota sklaidos diagrama (skliaustuose nurodomas paveikslo numeris).“ arba „Tarp kopūsto galvos svorio ir vitamino C koncentracijos toje galvoje aptikta koreliacija (Kendall \\(\\tau\\) = -0,52, p &lt; 0.001).“ Taip pat turi būti nurodomi trumpinių paaiškinimai: \\(\\tau\\) – Kendall koreliacijos koeficientas. ggplot(cabbages, aes(x = HeadWt, y = VitC)) + geom_point() + labs(x = &quot;Kopūsto galvos svoris, kg&quot;, y = &quot;Vitamino C koncentracija, sant. vnt.&quot;) + theme_classic() 11.2.4 Informacijos šaltiniai Šiame konspekte pateikti tik esminiai koreliacinės analizės bruožai. Išsamiau teorija išdėstyta šiuose vadovėliuose: V. Čekanavičius, G. Murauskas „Statistika ir jos taikymai“ I dalis: 97-98, 124-126, 165-169 psl. (tiesinė koreliacija); V. Čekanavičius, G. Murauskas „Statistika ir jos taikymai“ II dalis: 33-40 psl. (ranginė koreliacija); Jonė Venclovienė „Statistiniai metodai medicinoje“ (2010): 66-68, 167-183 psl. 11.3 Sąsaja tarp kategorinių kintamųjų reikšmių 11.3.1 Požymių nepriklausomumo tikrinimas Prieš tiriant sąsają tarp kategorinių kintamųjų, įprasta sudaryti porinę dažnių lentelę. Tai atlieka funkcija table(). Įprasta naudoti tokią sintaksę: with(duomenų_lentelė, table(požymis_1, požymis_2)). Pavyzdyje tirsime duomenų lentelės mtcars (32 atsitiktinai pasirinkti automobiliai) kintamuosius cyl(cilindrų skaičius) ir am (pavarų dėžė: 0 – automatinė, 1 – rankinė). data(mtcars) dazniu_lentele &lt;- with(mtcars, table(cyl, am)) dazniu_lentele ## am ## cyl 0 1 ## 4 3 8 ## 6 4 3 ## 8 12 2 Kategorinių požymių nepriklausomumui tirti naudojami šie kriterijai: Pirsono \\(\\chi^2\\) kriterijus. \\(\\chi^2\\) požymių nepriklausomumo kriterijus laikomas tinkamu naudoti, kai imties dydis bent 30, o 75% dažnių lentelės langelių dažnis yra 5 arba daugiau. Plačiau apie \\(\\chi^2\\) tinkamumą skaitykite Čekanavičiaus ir Murausko vadovėlio „Statistika ir jos taikymai I“ 213-214 psl. Fišerio tikslusis kriterijus. Taikomas mažoms imtims kaip \\(\\chi^2\\) kriterijaus alternatyva. Atkreipkite dėmesį, kad šie kriterijai gali padėti atsakyti į klausimą „Ar požymiai susiję?“, bet neatsako į klausimą „Kaip labai? Koks sąsajos stiprumas?“. \\(\\chi^2\\) požymių nepriklausomumo kriterijus taikymas: chisq.test(dazniu_lentele) ## Warning in chisq.test(dazniu_lentele): Chi-squared approximation may be ## incorrect ## ## Pearson&#39;s Chi-squared test ## ## data: dazniu_lentele ## X-squared = 8.7407, df = 2, p-value = 0.01265 Atkreipkite dėmesį į perspėjimą, kad \\(\\chi^2\\) kriterijų naudoti tikriausiai nekorektiška: Chi-squared approximation may be incorrect. Alternatyva – Fišerio tikslusis kriterijus: fisher.test(dazniu_lentele) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: dazniu_lentele ## p-value = 0.009105 ## alternative hypothesis: two.sided Gavome, kad p &lt; 0,05, tad galime teigti, kad kintamieji (šiuo atveju cyl, am) yra priklausomi. Rezultatus galime aprašyti taip: „Ryšys tarp cilindrų skaičiaus ir pavarų dėžės tipo yra statistiškai reikšmingas (Fišerio tikslusis kriterijus, p = 0.009).“ 11.3.2 Kategorinių kintamųjų ryšio stiprumas Ryšio stiprumą galime įvertinti naudodami vieną iš kelių galimų kategorinių kintamųjų ryšio matų (apie šios koeficientus plačiau rašoma Čekanavičiaus ir Murausko vadovėlio „Statistika ir jos taikymai I“ 216-221 psl.): Koeficientas \\(\\phi\\) (Phi-Coefficient) – tarpusavio sutapimo rodiklis. Skaičiuojamas tik \\(2 \\times 2\\) dažnių lentelėms. Kinta nuo 0 iki 1. Kontingencijos koeficientas (Contingency Coeff.). Niekada neviršija 1. Didžiausia reikšmė priklauso nuo dažnių lentelės stulpelių ir eilučių skaičiaus. Kramerio koeficientas \\(V\\) (Cramer's V). Kinta nuo 0 iki 1. \\(2 \\times 2\\) dažnių lentelei \\(V = \\phi\\). Juos galite apskaičiuoti naudodami paketo vcd funkciją assocstats(), kuriai pateikiama funkcija table() apskaičiuota dažnių lentelė: vcd::assocstats(dazniu_lentele) ## X^2 df P(&gt; X^2) ## Likelihood Ratio 9.2948 2 0.0095865 ## Pearson 8.7407 2 0.0126466 ## ## Phi-Coefficient : NA ## Contingency Coeff.: 0.463 ## Cramer&#39;s V : 0.523 Apskaičiavę ryšio stiprumo koeficientą, rezultatų aprašymą galime papildyti: „Analizuodami duomenis nustatėme vidutinio stiprumo statistinę sąsają tarp automobilių cilindrų skaičiaus ir pavarų dėžės tipo (Fišerio tikslusis kriterijus, p = 0.009, Cramer’io V = 0.52).“ Jei sąsaja būtų statistiškai nereikšminga, taip ir rašytume: „Sąsaja tarp kintamųjų buvo statistiškai nereikšminga (Pirsono \\(\\chi^2\\) kriterijus, \\(\\chi^2\\)(1) = 0.415, p = 0.519).“ arba „Sąsaja tarp kintamųjų buvo statistiškai nereikšminga (Fišerio tikslusis kriterijus, p = 0.408).“ 11.3.3 Programos kodai Žemiau pateikti programos kodai, kurie yra skirti atlikti sąsajos tarp kategorinių kintamųjų analizę. Jums reikiamose vietose reikia įrašyti savo duomenų bei kintamųjų pavadinimus bei pasirinkti tik jūsų atvejui tinkamus metodus. library(vcd) duomenys &lt;- ...duomenų_užkrovimo_kodas... dazniu_lentele &lt;- with(duomenys, table(kintamasis_1, kintamasis_2)) dazniu_lentele chisq.test(dazniu_lentele) fisher.test(dazniu_lentele) vcd::assocstats(dazniu_lentele) 11.3.4 Informacijos šaltiniai Šiame konspekte pateikti tik esminiai sąsajos tarp kategorinių kintamųjų aspektai. Išsamiau teorija išdėstyta vadovėlyje: V. Čekanavičius, G. Murauskas „Statistika ir jos taikymai“ I dalis: 197-223 psl. (skyrius „5. Dažnių lentelės“). 11.4 Ryšio tarp kintamųjų analizė naudojant R Commander Prieš žiūrėdami video epizodus, iš VMA parsisiųskite šioms pratyboms skirtus duomenis (nuoroda ), susikurkite sukonfigūruotą RStudio projektą ir duomenis įsikelkite į šio projekto aplanką. Video epizodas 11.1 Duomenų lentelių stulpelių sujungimas pagal eilučių identifikacijos numerius bei kelių duomenų lentelių eilučių sujungimas (R Commander). Video epizodas 11.2 Koreliacinė analizė (R Commander). Video epizodas 11.3 Koreliacinė analizė kelių kintamųjų poroms: koreliacijos koeficientų matrica ir sklaidos diagramų matrica (R Commander). Video epizodas 11.4 Kintamojo reikšmių perkodavimas, kintamojo klasės keitimas (R Commander). Atliekant kategorinių kintamųjų analizę, šių kintamųjų R klasė privalo būti factor (nominalusis) arba ordered (ranginis). Kitu atveju reikiamus kintamuosius reikia pasiversti į faktorius arba R Commander gali neleisti sudaryti dažnių lentelės. Video epizodas 11.5 Sąryšio tarp kategorinių kintamųjų tikrinimas (R Commander). Užduotis 11.2 Duomenų lentelėje „LungCapData.xlsx“ (ją parsisiuntėte iš VMA) pateikti vaikų plaučių tūrio (lung capacity) duomenys: Kiekvienai skaitinių kintamųjų porai atlikite koreliacinę analizę: parinkite tinkamą koreliacijos variantą ir rezultatus aprašykite. Kiekvienai kategorinių kintamųjų porai atlikite analizę, kuri parodytų, ar šie kintamieji yra priklausomi. Įvertinkite sąsajos stiprumą. Rezultatus aprašykite. Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["tiesine-regresija.html", "12. Tiesinė regresija 12.1 Regresinė analizė 12.2 Informacijos šaltiniai 12.3 Regresinė analizė naudojant R Commander 12.4 Išsamios tiesinės regresinės analizės pavyzdys", " 12. Tiesinė regresija Užsiėmimo tikslas – praktiškai susipažinti su išsamios tiesinės regresinės analizės principais. Pratybų metu reikalingi R paketai: library(tidyverse) library(biostat) library(data.table) library(Rcmdr) library(RcmdrMisc) library(car) library(Hmisc) library(lmtest) # Kalibracijos uždavniui library(chemCal) 12.1 Regresinė analizė Koreliacinė analizė parodo, ar dviejų kintamųjų reikšmės yra susijusios ir koks tos sąsajos stiprumas. Jei šito užtenka, šioje vietoje analizę ir baigiame. Jei norime griežčiau apsirašyti šią sąsają, galime atliki regresinę analizę. Regresijos modelis – statistinis modelis, leidžiantis vieno kintamojo reikšmes prognozuoti pagal kito kintamojo reikšmes. Regresija — statistinė vieno atsitiktinio dydžio reikšmių priklausomybė nuo kito – neatsitiktinio – dydžio (arba kelių kitų dydžių), turinti griežtą funkcinį ryšį (t. y., aprašoma lygtimi). Pavyzdžiai: pirmas pavyzdys, kuris ateina į galvą – yra kalibravimas, kai paruošiame žinomos koncentracijos tirpalus, supilstome į kiuvetes bei išmatuojame šviesos sugertį. Susidarome koncentracijos ir šviesos sugerties priklausomybės (t. y., kalibracinę) kreivę bei lygtį. Vėliau į mėgintuvėlį įpylę nežinomos koncentracijos tirpalą pagal šviesos sugerties intensyvumą galime nustatyti koncentraciją. Tai dažnas uždavinys per biochemijos laboratorinius darbus; regresija gali būti naudojama ir tada, kai, tarkime, norime nustatyti, koks įprastai būna pulsas padarius tam tikrą kiekį pritūpimų; koks būna vabzdžio šarvo storis, jei žinome vabzdžio svorį ir ilgį; kaip svoris priklauso nuo amžiaus; kaip plaučių tūris priklauso nuo per savaitę surūkomų cigarečių skaičiaus. Paprastosios tiesinės regresijos modelis užrašomas lygtimi: \\[Y = a + bX + \\varepsilon\\] Čia: \\(Y\\) ir \\(X\\) – mūsų tiriami kintamieji: \\(Y\\) – vadinamas priklausomu, arba atsako, kintamuoju, nes jį modeliuojame; \\(X\\) – nepriklausomu, arba aiškinamuoju, kintamuoju, arba regresoriumi, nes pagal jį modeliuojame \\(Y\\) reikšmes. Daroma prielaida, kad \\(X\\) yra matuojamas be paklaidų (t. y., nėra atsitiktinis dydis); \\(a\\) ir \\(b\\) – lygties koeficientai: \\(a\\) – laisvasis narys, kartais vadinamas konstanta (angl., intercept). Paprastosios regresijos atveju parodo, kurioje vietoje regresijos tiesė kerta y ašį, kai \\(X = 0\\); \\(b\\) – koeficientai, dar vadinami krypties koeficientais (angl., slope) arba svertiniais koeficientais. Parodo, kiek pakinta Y reikšmė, kai X reikšmė pakinta vienu vienetu. Atliekant regresinę analizę mūsų tikslas apskaičiuoti šiuos koeficientus. \\(\\varepsilon\\) liekamosios paklaidos, dar vadinamos likučiais (angl., residuals): tai visa kita, nuo ko gali priklausyti Y reikšmės; šios paklaidos – tai kintamojo \\(Y\\) matavimo paklaidos (nes modelyje laikoma, kad \\(X\\) matuojamas be paklaidų); pagal paklaidas galime patikrinti daugelį tiesinės regresijos modelio prielaidų. Daugialypės tiesinės regresijos modelis panašus, tik yra daugiau nepriklausomų kintamųjų ir \\(b\\) koeficientų: \\[Y = a + b_1X_1 + b_2X_2 + b_3X_3 + \\varepsilon\\] 12.1.1 Regresinės analizės eiga Visą regresinę analizę galima suskirstyti į 3 pagrindinius etapus: Pirmiausia modelis yra sudaromas (parenkami kintamieji, užrašoma regresijos lygtis, apskaičiuojami koeficientai). Tada vykdoma modelio diagnostika (patikrinamas modelio tinkamumas duomenims, duomenų tinkamumas modeliui, modelio prielaidos): jei reikia – modelis tobulinamas. Galiausiai tinkamai sudarytas modelis aprašomas ir naudojamas prognozuoti: ateityje žinodami visų X’ų reikšmes, galėsime prognozuoti, kokia, tikėtina, bus kintamojo Y reikšmė. 12.1.2 Tinkamo tiesinės regresijos modelio rodikliai Tinkamo tiesinės regresijos modelio, pagal kurį galima daryti pagrįstas išvadas, rodikliai (labai išsami regresinė analizė): Determinacijos koeficientas \\(R^2 \\ge 0,20\\): kuo \\(R^2\\) didesnis, tuo glaudžiau taškai išsidėsto apie regresijos tiesę; naudojame tik vieną determinacijos koeficientą, kuris labiau tinka: arba įprastinį: tinka paprastajai tiesinei regresijai arba daugialypei, kai duomenų pakankamai daug – pvz., vienam nepriklausomam kintamajam \\(X_i\\) tenka bent 7 duomenų taškai; arba koreguotąjį: kai modelyje yra daug nepriklausomų kintamųjų \\(X_i\\) (ir palyginus mažai taškų), įprastinis \\(R^2\\) gali būti nepagrįstai didelis. ANOVA \\(p &lt; 0,05\\): parodo, kad bent vienas regresorius yra reikalingas, t. y., bent vieno koeficiento vertė statistiškai reikšmingai skiriasi nuo nulio; Visiems regresoriams t kriterijų \\(p &lt; 0,05\\): parodo, kurių konkrečiai koeficientų vertė statistiškai reikšmingai skiriasi nuo 0; Nėra išskirčių, jei: Bonferroni išskirčių kriterijaus koreguotoji \\(p \\ge 0,05\\) (arba NA); Kuko matas d (Cook‘s distance) visiems stebėjimams \\(d &lt; 1\\). Liekamosios paklaidos normalios: Sprendžiant pagal q-q grafiką bei Shapiro-Wilk testo \\(p \\ge 0,05\\). Liekamųjų paklaidų vidurkis lygus 0: Sprendžiant iš liekamųjų paklaidų pagal prognozuojamas reikšmes grafiko bei Vienos imties t testo \\(p \\ge 0,05\\). Nėra heteroskedastiškumo problemos: Sprendžiant iš liekamųjų paklaidų grafikų bei Breusch-Pagan (Breušo-pagano) testo \\(p \\ge 0,05\\). Nėra multikolinearumo problemos, dėl kurios neteisingai apskaičiuojami lygties koeficientai (tik daugialypei regresijai), jei: regresijos koeficientų ženklai atitinka koreliacijos koef. ženklus tarp Y ir kiekvieno X; visi \\(VIF \\le 4\\) (VIF – dispersijos mažėjimo daugiklis, angl., variance inflation factor). Nėra autokoreliacijos: Tikriname tik tada, jei dirbame su laiko eilutėmis (pvz., mėnesiais, sekundėmis) arba dėl kitokių priežasčių įtariame, kad reikšmės gali būti priklausomos; Durbin-Watson autokoreliacijos kriterijaus \\(p\\ge0,05\\), kai alternatyva \\(\\varrho \\ne 0\\) (čia \\(\\varrho\\) – (auto)koreliacijos koeficientas); arba Durbin-Watson statistikos reikšmė yra tarp 1,5-2,5. Jei turime daugialypę regresiją, papildomai apskaičiuojame standartizuotuosius (beta) koeficientus: kuo absoliučioji koeficiento vertė didesnė, tuo atitinkamas regresorius daro didesnę įtaką priklausomam kintamajam. Nestandartizuoti koeficientai tokios informacijos neteikia. Analogišką (bet šiek tiek glaustesnį) apibendrinimą galite rasti regresijos vadovėlio 36 psl. (). Pastabos: visi kintamieji regresinėje analizėje turi būti skaitiniai arba pseudokintamieji; regresijos vadovėlyje skaitiniai kintamieji vadinami intervaliniais; pseudokintamieji (angl. dummy variables) – tai kategoriniai kintamieji, tam tikru būdu perkoduoti į skaitinius. Kuriant tiesinės regresijos modelį R tai atlieka automatiškai, todėl galite pamatyti neįprastai apibūdintų koeficientų, jei naudojate kategorinį kintamąjį; apie pseudokintamuosius šio kurso metu plačiau nesimokysime). Užduotis 12.1 Sąsiuvinyje arba atskirame lape pasidarykite atmintinę, ką reikia patikrinti vykdant išsamią regresinę analizę. Apibūdinkite, kokie turi būti šios patikros rezultatai, kad būtų korektiška naudoti regresinės analizės modelį. Užduotį atlikite raštu. 12.1.3 Regresijos modelio grafikas ggplot2 sistema Paprastosios tiesinės regresijos modelį \\(Y = a + bX\\) galima nubraižyti naudojant tokį ggplot2 kodą: data(birthwt, package = &quot;MASS&quot;) library(ggplot2) ggplot(birthwt, aes(x = age, y = bwt)) + geom_point() + geom_smooth(method = lm, se = FALSE) Pasirinkus parametrą se = TRUE bus braižomas tiesės pasikliauties intervalas. Jei reikalinga tokio tipo kreivė, kuri eina per tašką (0; 0) – \\(Y = 0 + bX\\),– tada reikia tokio kodo geom_smooth(method = lm, se = FALSE, formula = y ~ 0 + x): ggplot(birthwt, aes(x = age, y = bwt)) + geom_smooth(method = lm, se = FALSE, formula = y ~ 0 + x) + geom_point() + coord_cartesian(xlim = c(0, 45), ylim = c(0, 5500)) Be abejo, šiuo atveju toks modelis mums nėra tinkamas. Tai tik pavyzdys. Užduotis 12.2 Išbandykite šiame skyriuje pateiktus programos kodus. 12.1.4 Rezultatų aprašymas: tiesinė regresinė analizė Standartinių tiesinės regresijos modelio aprašymų pavyzdžių galite rasti regresijos vadovėlio () skyriuje „2.1.8. Standartiniai tiesinės regresijos modelio aprašymai“ 40-41 psl., skyriuje „2.5.6. Išvados“ 114 psl. Užduotis 12.3 Atsiverskite nurodytus vadovėlio puslapius ir perskaitykite, kaip turi atrodyti regresinės analizės aprašymas. Raštu įvardinkite svarbiausias tiesinės regresijos modelio aprašymo principus. 12.2 Informacijos šaltiniai Šiame konspekte itin glaustai pateikti tik esminiai regresinės analizės bruožai. Teorinė dalis išdėstyta šiuose vadovėliuose: Čekanavičius ir Murauskas „Taikomoji regresinė analizė socialiniuose tyrimuose“ 28-41 ir 127 psl. (išdėstyti praktiniai modelio taikymo aspektai vengiant matematinių detalių) ; Čekanavičius ir Murauskas „Taikomoji regresinė analizė socialiniuose tyrimuose“ 100-123 psl. analizės pavyzdys naudojant R; Čekanavičius ir Murauskas „Statistika ir jos taikymai II“ 123-147 ir 151-179 psl. (pateikti ir matematiniai modelio aspektai). Papildomi informacijos šaltiniai, kuriuose mokoma, kaip interpretuoti regresinės analizės rezultatus: Straipsnis, kuriame mokoma, kaip interpretuoti keturis pagrindinius tiesinės regresijos modelio diagnostikos grafikus (nuoroda ); Tinklaraščio straipsnis, kuriame supažindinama, kaip naudojantis R susidaryti tiesinės regresijos modelį ir kaip interpretuoti skaitinius modelio rezultatus (nuoroda ); Atsakymas diskusijų forume „Cross Validated“, kuriame aiškinama, kaip interpretuoti liekamųjų paklaidų pagal prognozuojamas reikšmes grafiką (nuoroda ); Atsakymas diskusijų forume „Cross Validated“, kuriame aiškinama, kaip interpretuoti liekamųjų paklaidų pagal įtakos indeksą grafiką (nuoroda ). 12.3 Regresinė analizė naudojant R Commander Prieš žiūrėdami video epizodus, iš VMA parsisiųskite šioms pratyboms skirtus duomenis (nuoroda ), susikurkite sukonfigūruotą RStudio projektą ir duomenis įsikelkite į šio projekto aplanką. 12.3.1 Paprastoji tiesinė regresija Epizode su kalibracijos uždaviniu nekorektiškai sudarytas regresijos modelis. Sprendžiant kalibracijos uždavinį korektiška nepriklausomu kintamuoju (X) pasirinkti koncentraciją (tai, ką išmatavome patys), o priklausomu (Y) – optinį tankį (tai, ką išmatavo kalibruojamasis prietaisas). Korektiška modelio lygtis: \\[optinis\\_tankis = a + b \\times koncentracija\\] Korektiškas kalibracijos uždavinio sprendimas po epizodu. Video epizodas 12.1 Išsamios paprastosios tiesinės regresijos pavyzdys (R Commander). Užduotis 12.4 Duomenų lentelėje „smoking.xlsx“ (ją parsisiuntėte iš VMA) pateikti skirtingų šalių duomenys apie rūkymą ir plaučių vėžio atvejus. Su šiais duomenimis atkartokite video epizode 12.1 parodytą regresinę analizę: sudarykite prasmingą modelį, užrašykite jo lygtį, patikrinkite, ar modelį korektiška naudoti. Modelį aprašykite. Kintamieji: lungca – mirčių nuo plaučių vėžio skaičius milijonui gyventojų; cigs – per metus surūkytų cigarečių skaičius, tenkantis vienam gyventojui. Kalibracijos uždavinio sprendimas Kalibracijos uždavinio sprendimo pavyzdys. Šiame pavyzdyje modelio prielaidos tikrinamos tik grafiškai. # Duomenys kalibracijos_duomenys &lt;- data.frame( koncentracija = c( 1, 1, 0.75, 0.75, 0.5, 0.5, 0.25, 0.25, 0.125, 0.125, 0.0625, 0.0625), OD = c(0.98, 0.96, 0.746, 0.751, 0.46, 0.475, 0.23, 0.245, 0.123, 0.126, 0.0615, 0.0626)) Modelio sudarymas: \\(X\\) (nepriklausomas kintamasis) turi būti koncentracija (t. y., tai, ką dedame į prietaisą). Darome prielaidą, kad ši koncentracija išmatuota visiškai tiksliai, t.y., be klaidų. \\(Y\\) (priklausomas kintamasis) turi būti optinis tankis ar kitas rodmuo, kurį išmatuoja prietaisas. Prietaisas matuoja su paklaidomis, o modelis į šias paklaidas atsižvelgia. Sudarome tokios formos lygtį: \\(Y = a + bX\\), t. y., \\(OD = a + b \\times koncentracija\\). # Modelio sudarymas: modelis &lt;- lm(OD ~ koncentracija, data = kalibracijos_duomenys) # Regresijos lygties koeficientai: modelis ## ## Call: ## lm(formula = OD ~ koncentracija, data = kalibracijos_duomenys) ## ## Coefficients: ## (Intercept) koncentracija ## -0.002598 0.976982 # Modelio suvestinė: summary(modelis) ## ## Call: ## lm(formula = OD ~ koncentracija, data = kalibracijos_duomenys) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.025893 -0.011081 0.003414 0.005831 0.020862 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.002598 0.006662 -0.39 0.705 ## koncentracija 0.976982 0.011855 82.41 1.69e-15 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.01393 on 10 degrees of freedom ## Multiple R-squared: 0.9985, Adjusted R-squared: 0.9984 ## F-statistic: 6792 on 1 and 10 DF, p-value: 1.692e-15 Tad gauname \\(OD = -0.0026 + 0.9770\\times koncentracija\\), \\(R^2 = 0.999\\). # Prielaidų tikrinimas grafiškai: op &lt;- par(mfrow = c(2, 2)); plot(modelis); par(op) Kalibracijos kreivė su pasikliauties ir prognozės intervalais # Kalibracinė kreivė: chemCal::calplot(modelis, xlab = &quot;Koncentracija&quot;, ylab = &quot;OD&quot;) Pagal sudarytą modelį apskaičiuosime koncentraciją (t. y., \\(X\\)), kai duotas OD (t. y., \\(Y\\)). Tam reikia persitvarkyti mūsų modelio lygtį į tokios formos lygtį: \\(X = \\frac{Y - a}{b}\\), t. y., \\(koncentracija = \\frac{OD - a}{b}\\). naujas_OD &lt;- c(0.701, 0.394, 0.095) (naujas_OD + 0.0026)/0.9770 ## [1] 0.72016377 0.40593654 0.09989765 Paketo chemCal funkcija inverse.predict() šiuos skaičiavimus gali atlikti už mus. Ši funkcija papildomai įvertina paklaidas bei ir apskaičiuoja pasikliauties intervalą. naujas_OD_1 &lt;- 0.701 chemCal::inverse.predict(modelis, naujas_OD_1) ## $Prediction ## [1] 0.720175 ## ## $`Standard Error` ## [1] 0.01581414 ## ## $Confidence ## [1] 0.04390708 ## ## $`Confidence Limits` ## [1] 0.6762680 0.7640821 Tad šiuo atveju koncentracija yra 0.720 (95% pasikliauties intervalas 0.676-0.764). Kaip pastebite, šis atsakymas paklaidų ribose sutampa su tuo, kuris video epizode pateikiamas ties 7:30 min. Visgi epizode lygtis sudaryta nekorektiškai. Daugiau pavyzdžių: naujas_OD_2 &lt;- 0.394 chemCal::inverse.predict(modelis, naujas_OD_2) ## $Prediction ## [1] 0.4059422 ## ## $`Standard Error` ## [1] 0.01514999 ## ## $Confidence ## [1] 0.04206312 ## ## $`Confidence Limits` ## [1] 0.3638791 0.4480053 naujas_OD_3 &lt;- 0.095 chemCal::inverse.predict(modelis, naujas_OD_3) ## $Prediction ## [1] 0.0998978 ## ## $`Standard Error` ## [1] 0.01623088 ## ## $Confidence ## [1] 0.04506416 ## ## $`Confidence Limits` ## [1] 0.05483364 0.14496196 Papildomai paketas gali apskaičiuoti mažiausią statistiškai reikšmingai aptinkamą koncentraciją: chemCal::lod(modelis) ## $koncentracija ## [1] 0.05690188 ## ## $OD ## 1 ## 0.05299375 Ši koncentracija yra apie 0.057, kai optinis tankis yra apie 0.053. Jei žinome, kad mūsų lygties laisvasis narys yra lygus nuliui (pvz., „nusinulinome“ prietaisą, kad rodytų 0, kai koncentracija yra 0), tada modelyje papildomai įrašome + 0 ir analizę atliekame iš naujo. # Modelio sudarymas: modelis_2 &lt;- lm(OD ~ koncentracija + 0, data = kalibracijos_duomenys) modelis_2 ## ## Call: ## lm(formula = OD ~ koncentracija + 0, data = kalibracijos_duomenys) ## ## Coefficients: ## koncentracija ## 0.9733 Atsakyme nebėra laisvojo nario („(Intercept)“). 12.3.2 Daugialypė tiesinė regresija Šiame skyriuje demonstuojamas pavyzdys taip pat aprašomas ir 12.4 skyriuje. Video epizodas 12.2 Išsamios daugialypės tiesinės regresijos pavyzdys (R Commander). Užduotis 12.5 Duomenų lentelėje „auction.xlsx“ (ją parsisiuntėte iš VMA) pateikti sendaikčių aukciono duomenys. Sudarykite knygos kainos (Price) priklausomybės nuo knygos amžiaus (Age) ir dalyvių skaičiaus (Bidders) modelį. Įvertinkite, kuris požymis yra reikšmingesnis prognozei. Rezultatus aprašykite. 12.3.3 Modelio tobulinimas Keli paprasti pavyzdžiai, ką daryti, jei netenkinami kai kurie tiesinės regresijos modelio reikalavimai, pateikti video epizode 12.3. Daugiau informacijos apie modelio tobulinimą galite rasti regresijos vadovėlyje (nuoroda pateikta 12.2 skyriuje). Pastaba: tobulindami modelį vienu metu pašalinkite ne daugiau kaip vieną kintamąjį arba vieną duomenų tašką. Tada sudarykite modelį iš naujo ir atlikite naujojo modelio diagnostiką. To gali pakakti, kad reikalavimai modeliui vėl būtų tenkinami. Be aiškaus pagrindimo ir argumetacijos duomenų, neatitinkamčių modelio, šalinti negalima! Video epizodas 12.3 Tiesinės regresijos modelio tobulinimas: keli pavyzdžiai (R Commander). Užduotis 12.6 Duomenų lentelėje „LungCapData.xlsx“ (ją parsisiuntėte iš VMA) pateikti vaikų plaučių tūrio (lung capacity) duomenys. Sudarykite plaučių tūrio priklausomybės nuo amžiaus ir ūgio modelį. Jei reikia, modelį koreguokite. Tinkamai aprašykite galutinį modelį. 12.4 Išsamios tiesinės regresinės analizės pavyzdys Šiame poskyryje pateikiamas išsamios daugialypės tiesinės regresinės analizės pavyzdys. 12.4.1 Klausimas / Problema Mums reikalingas modelis, kuriuo galime įvertinti medienos tūrio priklausomybę nuo medžio aukščio ir medžio apimties. 12.4.2 Duomenys Užkraunami duomenys, kuriose užregistruotas medžio aukštis, medžio apimtis ir medienos tūris. data(&quot;trees&quot;) ?trees Susidarome vaizdą apie duomenis. Pasižiūrime į duomenų struktūrą ir duomenų tipus: dplyr::glimpse(trees) ## Observations: 31 ## Variables: 3 ## $ Girth &lt;dbl&gt; 8.3, 8.6, 8.8, 10.5, 10.7, 10.8, 11.0, 11.0, 11.1, 11.2... ## $ Height &lt;dbl&gt; 70, 65, 63, 72, 81, 83, 66, 75, 80, 75, 79, 76, 76, 69,... ## $ Volume &lt;dbl&gt; 10.3, 10.3, 10.2, 16.4, 18.8, 19.7, 15.6, 18.2, 22.6, 1... Visi kintamieji yra skaitiniai (dbl, angl. double). Pasižiūrime į pirmas ir paskutine eilutes: head(trees) ## Girth Height Volume ## 1 8.3 70 10.3 ## 2 8.6 65 10.3 ## 3 8.8 63 10.2 ## 4 10.5 72 16.4 ## 5 10.7 81 18.8 ## 6 10.8 83 19.7 tail(trees) ## Girth Height Volume ## 26 17.3 81 55.4 ## 27 17.5 82 55.7 ## 28 17.9 80 58.3 ## 29 18.0 80 51.5 ## 30 18.0 80 51.0 ## 31 20.6 87 77.0 Padarome kintamųjų suvestinę: summary(trees) ## Girth Height Volume ## Min. : 8.30 Min. :63 Min. :10.20 ## 1st Qu.:11.05 1st Qu.:72 1st Qu.:19.40 ## Median :12.90 Median :76 Median :24.20 ## Mean :13.25 Mean :76 Mean :30.17 ## 3rd Qu.:15.25 3rd Qu.:80 3rd Qu.:37.30 ## Max. :20.60 Max. :87 Max. :77.00 Mūsų modelis galioja tik toms kintamųjų reikšmėms, kurios patenka tarp minimalių ir maksimalių kiekvieno modeliuojamo kintamojo ribų. Tarkim, girth turėtų būti tarp 8.30 ir 20.60. Jei sudarę modelį vėliau turėsime medį, kurio apimtis yra 25, tada jam taikyti modelį bus nekorektiška. 12.4.3 Nusibraižome kintamuosius Nusibraižome sklaidos diagramų matricą, kurioje visi analizuojami kintamieji viename grafike (susidarome bendrą vaizdą, ar priklausomybė tarp kintamųjų tiesinė): pairs(trees) Į kai kurias diagramas pasižiūrime atidžiau – sukuriame atskiras sklaidos diagramas, kuriose priklausomo kintamojo reikšmės y ašyje atidedamos pagal kiekvieną nepriklausomo kintamojo (regresoriaus) reikšmes. Pridedame papildomus grafiko elementus – pakraštines stačiakampes diagramas ir regresijos kreivę,– kurie padeda tiksliau vertinti grafikus: car::scatterplot(Volume ~ Height, data = trees, boxplots = &#39;xy&#39;, smooth = FALSE ) car::scatterplot(Volume ~ Girth, data = trees, boxplots = &#39;xy&#39;, smooth = FALSE ) 12.4.4 Įvertiname koreliaciją tarp kintamųjų Nusibraižome koreliacijos koeficientų matricą, kurioje atidėti kiekvienos kintamųjų poros koreliacijos koeficientai bei atlikta koreliacijos patikimumo analizė (pridėta p reikšmių matrica, korektiškiau p reikšmes vertinti pagal koreguotų p reikšmių matricą). Priklausomas kintamasis turėtų bent šiek tiek koreliuoti su kiekvienu iš regresorių, kitaip regresoriaus įtraukimas į modelį labai abejotinas. Tuo tarpu regresoriai tarpusavyje neturėtų per smarkiai koreliuoti, nes kitu atveju galime susidurti su multikolinearumo problema. RcmdrMisc::rcorr.adjust(trees) 12.4.5 Regresijos lygties sudarymas Modelis sudaromas naudojant funkciją lm() (angl. linear model), jos viduje modeliuojamą sąryšį tarp kintamųjų užrašant R formulės sąsajos pavidalu: regresijos_modelis &lt;- lm(Volume ~ Girth + Height, data = trees) 12.4.6 Modelio suvestinė Suvestinėje pažiūrime į: Determinacijos koeficientą \\(R^2\\) (standartinį „Multiple R-squared“ arba koreguotąjį „Adjusted R-squared“). Kuo šis rodiklis arčiau 1, tuo modelis tinkamesnis; ANOVA testo p reikšmę („p-value“). Jei ANOVA \\(p &lt; 0.05\\), vadinasi lygtyje yra bent vienas reikalingas regresorius. Jei \\(p \\ge 0.05\\) vadinasi regresoriai ne pakankamai gerai aprašo priklausomą kintamąjį ir regresijos lygtis yra bevertė; regresijos koeficientus („Coefficients“ → „Estimate“) ir jiems atlikto t-testo p reikšmes („Coefficients“ → „Pr(&gt;|t|)“). Jei regresoriaus \\(p &lt; 0.05\\), galima manyti, jog regresorius yra reikalingas. Kitu atveju – regresorius šalintinas iš lygties; Suvestinė atliekama šitaip: summary(regresijos_modelis) ## ## Call: ## lm(formula = Volume ~ Girth + Height, data = trees) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.4065 -2.6493 -0.2876 2.2003 8.4847 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -57.9877 8.6382 -6.713 2.75e-07 *** ## Girth 4.7082 0.2643 17.816 &lt; 2e-16 *** ## Height 0.3393 0.1302 2.607 0.0145 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.882 on 28 degrees of freedom ## Multiple R-squared: 0.948, Adjusted R-squared: 0.9442 ## F-statistic: 255 on 2 and 28 DF, p-value: &lt; 2.2e-16 12.4.7 Standartizuotieji koeficientai Apskaičiuojame standartizuotuosius beta koeficientus, pagal kurių absoliučiąją vertę sprendžiame, kurie kintamieji yra įtakingiausi (daro didžiausią įtaką priklausomo kintamojo vertėms): library(biostat) coef_standardized(regresijos_modelis) ## Standardized Regression Coefficients: ## Girth Height ## 0.899 0.132 Šiuo atveju regresorius „Girth“ yra įtakingesnis už „Height“. summary(coef_standardized(regresijos_modelis)) ## Summary of Standardized Regression Coefficients: ## regressor coeff standardized_coeff influence_rank ## 1 (Intercept) -57.9876589 NA NA ## 2 Girth 4.7081605 0.899 1 ## 3 Height 0.3392512 0.132 2 12.4.8 Liekamųjų paklaidų analizė Liekamosios modelio paklaidos (įprastai žymimos \\(\\varepsilon\\)) gali būti vadinamos tiesiog paklaidomis arba likučiais (angl. „residuals“). Pagal jas tikrinamos kelios tiesinės regresinės analizės prielaidos. 1. Išskirčių paieška Bonferroni išskirčių testas regresinei analizei. Jei išskirčių nėra, testo Bonferroni būdu koreguota \\(p\\) reikšmė (Bonferonni p) \\(p \\ge 0.05\\) (arba \\(p =\\) NA): outlierTest(regresijos_modelis) ## No Studentized residuals with Bonferonni p &lt; 0.05 ## Largest |rstudent|: ## rstudent unadjusted p-value Bonferonni p ## 31 2.765603 0.010122 0.31377 Kuko mato (angl. „Cook’s distance“) įverčiai ir jų grafikai. Kuko mato reikšmės kiekvienam kintamajam turi būti \\(&lt; 1\\). Jei Kuko mato reikšmė konkrečiam taškui didesnė už vienetą, taškas laikomas išskirtimi. Pirmame – liekamųjų paklaidų pagal įtakos indeksą (angl., „Residuals vs. Leverage Plot“) – grafike x ašyje – įtakos indeksas (angl. „leverage“), y ašyje – standartizuotosios paklaidos. Grafiko zonos, kuriose Kuko mato vertė lygi 0.5 bei 1.0, žymimos raudonais punktyrais. Jei taškas nėra išskirtis, jis nepatenka į zoną, kurioje Kuko mato reikšmė didesnė už 1 (šiame grafike šios srities net ir nesimato, pavaizduota tik 0.5 riba): plot(regresijos_modelis, which = 5) Antrame (papildomame) – Kuko mato pagal stebėjimo (taško) indeksą – grafike x ašyje atidedamas taško (duomenų eilutės) numeris, o y ašyje – Kuko mato vertė. Taip galime matyti, kurios taškus galima įtarti kaip išskirtis. plot(regresijos_modelis, which = 4) 2. Paklaidų normalumo prielaidos tikrinimas Kvantilių palyginimo (qq) grafikas standartizuotoms paklaidoms. Jei paklaidos išsidėstyto „ant“ tiesės (arba kuo arčiau jos), prielaida nėra pažeidžiama: plot(regresijos_modelis, which = 2) Shapiro-Wilk kriterijus paklaidų pasiskirstymo normalumui tikrinti. Prielaida nepažeidžiama, jei \\(p \\ge 0.05\\): shapiro.test(residuals(regresijos_modelis)) ## ## Shapiro-Wilk normality test ## ## data: residuals(regresijos_modelis) ## W = 0.97431, p-value = 0.644 3. Prielaidos, kad paklaidų vidurkis lygus nuliui, tikrinimas Liekamųjų paklaidų pagal prognozuojamas reikšmes grafikas (angl. „Residuals vs. Fitted Plot“). Jei prielaida nepažeidžiama, jame likučiai turi barstytis apie nulį. plot(regresijos_modelis, which = 1) Stjudento t kriterijus, kuriuo tikrinama hipotezė, kad paklaidų likučių vidurkis lygus nuliui. Prielaida nepažeidžiama, jei \\(p \\ge 0.05\\): t.test(residuals(regresijos_modelis)) ## ## One Sample t-test ## ## data: residuals(regresijos_modelis) ## t = 2.2336e-16, df = 30, p-value = 1 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## -1.375587 1.375587 ## sample estimates: ## mean of x ## 1.504453e-16 p-value = 1 &gt; 0,05, tad prielaida nepažeidžiama. 4. Homoskedastiškumo prielaidos tikrinimas Homoskedartiškumo (arba lygių dispersijų prielaida) prielaida – tai prielaida, kad kiekvienai fiksuotai X reikšmei liekamųjų paklaidų dispersijos turėtų būti vienodos. (Terminai „homoskedastiškas“/„heteroskedastiškas“ būdingi regresinei analizei). Liekamųjų paklaidų grafikai kiekvienam regresoriui (daliniai įtakos grafikai, angl. „Added-Variable Plots“), kuriuose, esant homoskedastiškumui (lygioms dispersijoms), taškai aplink regresijos tiesę turėtų išsidėstyti tolygiai, tarsi sudarydami juostelę. Jei išsibarstymas platėja, siaurėja ar kitokiu būdu kinta, galima įtarti, kad prielaida pažeidžiama. # car::avPlots(regresijos_modelis, main = &quot;Liekamųjų paklaidų grafikai&quot;) car::avPlots(regresijos_modelis) Kitas grafinio vertinimo būdas – sklaidos-padėties grafikas (angl. „Scale-Location Plot“). Tai vienas iš standartizuotųjų prognozuojamų reikšmių – liekamųjų paklaidų grafiko variantų. Jame likučiai turėtų išsidėstyti tolygiai ir lygiagrečiai x ašiai. Jei matoma tendencija, kad grafiko taškai kyla arba leidžiasi (t. y., nėra lygiagretūs x ašiai) arba jų išsibarstymas siaurėja, platėja arba kitaip kinta, galima numanyti esant heteroskedastiškumą: plot(regresijos_modelis, which = 3) Breusch-Pagan kriterijus, atliekamas prognozuojamų reikšmių (angl. „fitted values“) atžvilgiu. Stjudentizuota kriterijaus versija (tokią pagal nutylėjimą atlieka žemiau pateikta R funkcija) yra robastiškesnė (labiau atspari nukrypimams). Tikrinamos hipotezės: \\(H_0\\): dispersijos lygios (homoskedastiški duomenys) \\(H_1\\): dispersijos skiriasi (heteroskedastiški duomenys) Jei kriterijaus \\(p \\ge 0.05\\), tada homoskedastiškumo prielaida tenkinama: lmtest::bptest(Volume ~ Girth + Height, data = trees, varformula = ~ fitted.values(regresijos_modelis)) ## ## studentized Breusch-Pagan test ## ## data: Volume ~ Girth + Height ## BP = 2.2763, df = 1, p-value = 0.1314 Rezultatai rodo, kad skirtumas tarp dispersijų statistiškai nereikšmingas, tad homoskedastiškumo prielaida tenkinama. 12.4.9 Tikrinimas dėl multikolinearumo Multikolinearumo problemos nėra, kai kiekvienam kintamajam VIF &lt; 4 (VIF – dispersijos mažėjimo daugiklis, angl., „variance inflation factor“): car::vif(regresijos_modelis) ## Girth Height ## 1.36921 1.36921 12.4.10 Prognozavimas Kai modelis sudarytas ir patikrintas, jį galima naudoti prognozavimui. Šiuo atveju sudarėme modelį, kuriuo pagal medžio apimtį ir aukštį prognozuojamas vidutinis medienos tūris. Prognozuoti galime naudodamiesi funkcija predict. Pavyzdys, kai prognozė (kiekvienai duomenų eilutei) atliekama naudojant pradinius duomenis: medienos_turis &lt;- predict(regresijos_modelis, newdata = trees) medienos_turis ## 1 2 3 4 5 6 7 ## 4.837660 4.553852 4.816981 15.874115 19.869008 21.018327 16.192688 ## 8 9 10 11 12 13 14 ## 19.245949 21.413021 20.187581 22.015402 21.468465 21.468465 20.506154 ## 15 16 17 18 19 20 21 ## 23.954110 27.852203 31.583966 33.806482 30.600978 28.697035 34.388184 ## 22 23 24 25 26 27 28 ## 36.008319 35.385260 41.768998 44.877702 50.942868 52.223751 53.428513 ## 29 30 31 ## 53.899329 53.899329 68.515305 Aišku, modelį sudarėme tam, kad galėtume prognozuoti naujas reikšmes. Tam mums reikalingi nauji duomenys, kuriuose būtinai turi būti regresorių pavadinimai (mūsų atveju „Girth“ ir „Height“). Pavyzdžiai, kai prognozė atliekama naudojant naujus duomenis (nurodomos naujos regresorių, pagal kuriuos buvo modeliuota, reikšmės): medienos_turis2 &lt;- predict(regresijos_modelis, newdata = data.frame(Girth = 20, Height = 75)) medienos_turis2 ## 1 ## 61.61939 nauji_duomenys &lt;- data.table::fread( &quot;Girth Height 11 60 17 60 20 60 20 75&quot; ) medienos_turis3 &lt;- predict(regresijos_modelis, newdata = nauji_duomenys) medienos_turis3 ## 1 2 3 4 ## 14.15718 42.40614 56.53063 61.61939 Prognozuotąsias vertes įdedame į duomenų lentelę šalia regresorių: nauji_duomenys$`Spėjamas_vidutinis_medienos_tūris` &lt;- medienos_turis3 nauji_duomenys ## Girth Height Spėjamas_vidutinis_medienos_tūris ## 1: 11 60 14.15718 ## 2: 17 60 42.40614 ## 3: 20 60 56.53063 ## 4: 20 75 61.61939 Prisiminkite, kad regresijos lygtimi modeliuojamos tik vidutinės priklausomo kintamojo reikšmės. Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["kas-toliau.html", "Kas toliau?", " Kas toliau? Kurso metu mokėmės taikyti keletą statistinės analizės metodų. Norintiems gilinti žinias rekomenduoju šiuos šaltinius: Statistikos teorija biologiniams tyrimams http://rcompanion.org/handbook/ Statistiniai metodai naudojant R http://rcompanion.org/rcompanion/ Statistiniai metodai naudojant R http://www.biostathandbook.com/ Mokomiji medžiaga, kaip įvykdyti įvairias analizes naudojant R http://www.sthda.com/english/wiki "],
["programu-diegimas.html", "A Reikiamų programų diegimas A.1 Programa R A.2 Programa RStudio A.3 Programa Pandoc A.4 Video instrukcijos: atsisiuntimas ir diegimas A.5 RStudio konfigūravimas A.6 R paketų diegimas A.7 Mac vartotojams", " A Reikiamų programų diegimas Prieš pradėdami dirbti programomis, pirmiausia turime jas parsisiųsti, įsidiegti ir susikonfigūruoti. Žemiau pateiktos instrukcijos, kaip tai atlikti. Tikslas – atsisiųsti, įsidiegti ir susikonfigūruoti R ir kitas darbui šia programa reikiamas programas bei papildinius. Šiame skyriuje nurodytos programos yra visiškai nemokamos naudoti akademiniais tikslais. Pastaba 1: ši knyga (ir joje esančios instrukcijos) orientuota į operacinės sistemos Windows vartotojus. Kitų sistemų vartotojams kai kurios instrukcijos gali šiek tiek skirtis. Pastaba 2: aplanko, į kurį bus įdiegtos programas „R“, „RStudio“ bei jų papildiniai, pavadinimuose esančios raidės gali būti tik angliškos, t.y., nei vienoje pavadinimo dalyje negali būti nei lietuviškų, nei rusiškų, nei kiniškų simbolių: BLOGAI: C:/ĄĄĄĄČĘ C:/dokumentai/Žygimantas/R D:/biostatistiką/R GERAI: C:/AAAACE C:/dokumentai/Zygimantas/R D:/biostatistika/R Įsidiegti pavyks, bet kils problemų dirbant. Tad pasirinkite tinkamą aplanko pavadinimą. A.1 Programa R Pirmiausia parsisiųsite programą R. Be jos negalėsite atlikti analizės. Programą rasite tinklapyje: https://cloud.r-project.org/ Pav. A.1: Programos R parsisiuntimas. Nueikite į tinklapį https://cloud.r-project.org/. Atsidarys langas, kurio fragmentą matote A dalyje. Pasirinktie nuorodą pagal savo kompiuterio operacinę sistemą (Linux, Mac ar Windows). Naujai atsidariusiame lange (B) rinkitės „base“ (bazinis R paketas). Kitame lange (C) bus rodoma naujausia R versija (tarkim, 3.4.1). Spauskite „Download“ ir pradėkite siųstis programą. Pastaba: dabartinė programos versija naujesnė nei 3.4.1. Diegdami „R“ atkreipkite dėmesį į du dalykus: Pasirinkite aplanką, kurio pavadinime esančios raidės yra tik angliškos, t.y., nėra nei lietuviškų, nei rusiškų, nei kiniškų simbolių. Į tokį aplanką programas įdiegti pavyks, bet kils problemų dirbant. Pasirinkite jūsų kompiuteriui tinkamas programos bylas, kaip pavaizduota paveiksle A.2. Pav. A.2: Programos R diegimas. Programos branduolio („Core“) bylas įdiegti būtina. Taupantiems vietą kietajame diske: pasirinkite įsidiegti arba vien tik 64 bitų (A), arba 32 bitų (B) versiją, kuri labiau tinkama jūsų kompiuteriui. Jei jūsų kompiuteris naujesnis nei 3 metų, rinkitės 64 bitų versiją. Jei dvejojate, kurią rinktis, rinkitės abi. Užduotis A.1 Atsisiųskite ir įsidiekite programą R. A.2 Programa RStudio Programa RStudio palengvina darbą su R. Yra 2 RStudio tipai Desktop (skirtas asmeniniam kompiuteriui) ir server (skirtas serveriui). Mums reikalingas pirmasis. Parsisiuntimo tinklapis: https://www.rstudio.com/products/rstudio/download/ (pav. A.3) Pav. A.3: Programos RStudio parsisiuntimo tinklapio fragmentas. Tinklapio apačioje yra skiltis „RStudio Desktop“, kurioje išvardintos asmeniniam kompiuteriui skirtos versijos: pasirinkite tą, kuri pritaikyta jūsų kompiuterio operacinei sistemai (Linux, Mac ar Windows). Pastaba: dabartinė programos versija gali būti naujesnė nei 1.1.419. Užduotis A.2 Atsisiųskite ir įsidiekite naujausią programos RStudio versiją. A.3 Programa Pandoc Programa Pandoc skirta duomenų analizės ataskaitas paversti į įvairius formatus (pvz., į Microsoft Word ar tinklapio formatą). Parsisiuntimo tinklapis: https://github.com/jgm/pandoc/releases Pav. A.4: Programos Pandoc parsisiuntimo tinklapio fragmentas. Pasirinkite savo kompiuterio operacinei sistemai (Linux, Mac ar Windows) skirtą versiją. Windows sistemai skirtos versijos pabaigoje rašoma .msi. Pastaba: dabartinė programos versija gali būti naujesnė nei 2.1.1. Užduotis A.3 Atsisiųskite ir įsidiekite programą Pandoc. A.4 Video instrukcijos: atsisiuntimas ir diegimas Video medžiagą žiūrėdami pagreitintai – bent ×1,5 greičiu – taupysite laiką. Rekomenduojamas peržiūros greitis – ×2. Video medžiagoje A.1 pateikti pavyzdžiai, kaip atsisiųsti, įsidiegti ir atsidaryti reikiamas programas. Atkreipkite dėmesį, kad rodoma, kaip įsidiegti šiek tiek senesnes programų versijas, tad aukščiau pateiktos ir video epizode esančios nuorodos gali nesutapti. Epizodo pabaigoje (po 9:58 min.) esanti informacija skirta senesnei RStudio versijai, tad jau nebeaktuali. Video epizodas A.1 „R“, „RStudio“, „Pandoc“ diegimas. A.5 RStudio konfigūravimas Parsisiuntę programą R Studio, ją susikonfigūruokite. Vienintelis privalomas dalykas yra UTF-8 standarto pasirinkimas. Visa kita – tik rekomenduojama dėl patogumo. Detalios instrukcijos video medžiagoje, santrauka – paveiksle žemiau. Tam, kad išvengtume kai kurių problemų, susijusių su lietuvių kalbos atpažinimu, parinktį RStudio → Tools → Global Options → Code → Saving → Default text encoding nustatykite į UTF-8. Pav. A.5: Schema, demonstruojanti, kaip pasirinkti, kad bylos RStudio aplinkoje būtų nuskaitomos naudojant UTF-8 standartą. Video medžiagą žiūrėdami pagreitintai – bent ×1,5 greičiu – taupysite laiką. Rekomenduojamas peržiūros greitis – ×2. Video epizode A.2 rodoma, kaip sukonfigūruoti RStudio, kurios versija 1.0.x (x – versijos papildymo numeris). Todėl naudojant naujausią 1.1.x versiją nustatymų išdėstymas ir ikonų paveikslai skiriasi, tačiau principai liko tie patys. Video epizodas A.2 Programos „RStudio“ parengimas darbui (konfigūravimas). Pav. A.6: Priedas prie video medžiagos: programos R Studio konfigūracija, naudojama kompiuterių klasėje (R209). Geltonai pažymėti nustatymai, kurie skiriasi nuo numatytųjų. (Dėkoju Stepan Avdevič už pagalbą rengiant iliustraciją.) Pav. A.7: Priedas prie video medžiagos: programos R Studio parinktis (pažymėta tamsiai mėlynai), skirta įdiegti daugiau rašybos tikrinimo žodynų. Norintys daugiau paaiškinimų, ką reiškia konkretūs nustatymai, juos gali rasti šiame straipsnyje (nuoroda ). Užduotis A.4 Sukonfigūruokite RStudio taip, kad pagal nutylėjimą tekstinės bylos būtų dekoduojamos pagal UTF-8 standartą. Pagal rekomendacijas atlikite kitus RStudio konfigūracijos veiksmus. A.6 R paketų diegimas Dauguma programos „R“ funkcijų yra papildiniuose, vadinamuose paketais (angl. packages). Dabar atsisiųsite labiausiai reikalingus paketus. Dar kelis atsisiųsime vėliau, pratybų metu. Atsidarykite programą RStudio, į langą, pavadintą „Console“, nukopijuokite iš karto visas žemiau parašytas R paketų diegimo komandas ir paspauskite „Enter“ klavišą. Bus įdiegti kai kurie R papildiniai, vadinami funkcijų paketais. Normalu, jei parsisiuntimo ir diegimo procesas užtruks iki 20-40 minučių ir prireiks apie 1 GB vietos kietajame diske. Pavyzdys, kaip įdiegiamas paketas devtols, pateiktas pav. A.8. Pav. A.8: R paketo devtools diegimas programiškai. Lange „Console“ \\((A)\\) parašomas/įklijuojamas programos kodas \\((B)\\) ir paspaudžiamas klavišas „Enter“. Atsiranda „STOP“ ženkliukas \\((C)\\), užrašai, rodantys, kad paketai parsiunčiami ir diegiami \\((D)\\) bei atsisiuntimo progreso juosta (čia neparodyta). Sėkmingai įsidiegus paketui atsiranda apie tai pranešantys užrašai \\((E)\\) bei išnyksta „STOP“ ženkliukas bei atsiranda „&gt;“ ženkliukas \\((F)\\), rodantis, kad „R“ laukia naujos komandos. Jei paketas nebūtų įdiegtas sėkmingai, „R“ taip pat parašytų priežastį. Jei dega „STOP“ ženkliukas, bet atrodo, kad diegimas nevyksta, įsitikinkite, kad nėra lentelės, pavaizduotos pav. A.9 (ši lentelė gali būti „pasislėpusi“ už kitų langų) bei kad programa nelaukia jūsų sprendimo (pav. A.10). Labai dažnai painiojami 2 terminai: „paketas“ ir „biblioteka“. „Paketas“ yra tam tikras standartizuotas programos papildinys, kuriame yra funkcijų, duomenų lentelių, mokomosios medžiagos ir kitokių programos R ar RStudio funkcionalumą padidinančių priedų rinkinys. Terminas „biblioteka“ (angl. library) reiškia aplanką jūsų kompiuteryje, kuriame saugomi paketai. Hadley Wickham (vienas iš žinomiausių ir įtakingiausių programos R papildinių kūrėjų) yra pasakęs, kad „biblioteka“ yra kaip biblioteka, o „paketas“ kaip knyga: jūs nueinate į biblioteką tam, kad pasiimtumėte knygą. Kodėl apie šios du terminus rašau? Ogi todėl, kad jei programa R parodys klaidą, skaitydami klaidos žinutę galėsite įvertinti, ar problemą sukėlė papildinys, aplankas ar kokia nors kita strigtis. Pav. A.9: R siūlo paketus įdiegti į asmeninę biblioteką. Pamatę analogišką lentelę, įsitikinkite, kad aplanko pavadinime nėra neangliškų (pvz., lietuviškų) raidžių ir spauskite „Yes“. Pav. A.10: R klausia, ar įdiegti paketus, kuriuos reikia kompiliuoti (atlikti procedūrą, kurios pagalba paketai pritaikomi veikti jūsų kompiuteryje). Jei pasirodys analogiškas klausimas, įrašykite raidę „y“ ir paspauskite „Enter“. # R paketų diegimo komandos # ----------------------------------------------------------------------------- # Paketų parsisiuntimui install.packages(c(&quot;devtools&quot;, &quot;ctv&quot;)) # Rekomenduojami R paketai list_of_packages &lt;- c(# Vizualizavimui &quot;ggplot2&quot; , &quot;ggedit&quot; , &quot;ggpubr&quot; , &quot;ggrepel&quot; , &quot;ggthemes&quot; , &quot;ggplotgui&quot; , &quot;plotly&quot; , &quot;RColorBrewer&quot; # Statistinei analizei , &quot;aplpack&quot; , &quot;arm&quot; , &quot;coda&quot; , &quot;leaps&quot; , &quot;lmtest&quot; , &quot;matrixcalc&quot; , &quot;mi&quot; , &quot;multcomp&quot; , &quot;mvtnorm&quot; , &quot;Rcmdr&quot; , &quot;RcmdrMisc&quot; , &quot;RcmdrPlugin.EZR&quot; , &quot;RcmdrPlugin.KMggplot2&quot; , &quot;rgl&quot; , &quot;PMCMR&quot; , &quot;sem&quot; , &quot;TH.data&quot; # Kiti , &quot;data.table&quot; , &quot;tidyselect&quot; , &quot;tidyverse&quot; , &quot;broom&quot; , &quot;RCurl&quot; , &quot;checkmate&quot; , &quot;stringi&quot; , &quot;descriptr&quot; , &quot;DescTools&quot; , &quot;shiny&quot; ) # Paketų diegimo komanda install.packages(list_of_packages, dependencies = c(&quot;Depends&quot;, &quot;Imports&quot;)) # Paketų diegimas pagal temas ctv::update.views(c(&quot;ReproducibleResearch&quot;, &quot;Graphics&quot;)) # Paketų diegimas iš GitHub saugyklos devtools::install_github(&quot;GegznaV/addin.tools&quot;) devtools::install_github(&quot;GegznaV/addins.rmd&quot;) devtools::install_github(&quot;GegznaV/addins.rs&quot;) devtools::install_github(&quot;majkamichal/easyPlot&quot;) devtools::install_github(&quot;rsquaredacademy/descriptr@develop&quot;) devtools::install_github(&quot;GegznaV/RcmdrPlugin.EZR@unmodified_Rcmdr_menu&quot;) devtools::install_github(&quot;GegznaV/biostat&quot;) devtools::install_github(&quot;GegznaV/RcmdrPlugin.biostat&quot;) # Paketų, priklausančių kolekcijai „tidyverse“, diegimas: # http://tidyverse.org/ library(&quot;tidyverse&quot;) # ----------------------------------------------------------------------------- message(&quot;Atlikta!&quot;) # ----------------------------------------------------------------------------- Užduotis A.5 Įsidiekite nurodytus programos R paketus. A.6.1 Kilus problemų dėl paketų diegimo… Jei jums neleidžiama diegti R paketų dėl to, kad R rekomenduojamos bibliotekos (aplanko) pavadinime yra lietuviškų raidžių, gali padėti pav. A.11 esanti informacija, kaip nurodyti kitą aplanką. ATSARGIAI: tai pažengusiųjų lygio modifikacijos sistemai Windows. Atidarytuose languose nieko papildomai nekeiskite ir neištrinkite, nebent suprantate, ką darote. Pav. A.11: Numatytojo aplanko R paketams keitimas. Jums paieškos lange reikia rasti „Advanced system settings“, atsidariusiame aplinkos kintamųjų lange „Environment variables“ (aplinkos kintamieji) ir sukurti naują vartotojo aplinkos kintamąjį („New user variable“) Langelyje „Variable name“ \\((A)\\) reikia įrašyti „R_LIBS_USER“, o „Variable value“ \\((B)\\) – aplanko, į kurį turi būti diegiami paketai, pavadinimą. Pavadinimą galima įrašyti, įkopijuoti arba susirasti naudojant „Browse Directory“ mygtuką. Tai – pažengusiųjų lygio modifikacijos, tad būkite atidūs ir keiskite tik tai, ką keisti būtina. Išsaugoję nustatymus, kompiuterį perkraukite. PASTABA. Pakeitus šiuos nustatymus būtina perkrauti (angl. restart) kompiuterį ir tik tada tikrinti, ar jie išsprendė problemą. A.7 Mac vartotojams Mac vartotojams papildomai reikia atsisiųsti ir įsidiegti programą XQuartz (http://www.xquartz.org/), nes be jos neveiks papildinys R Commander. Daugiau instrukcijų galite rasti šiame tinklapyje: nuoroda . Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["zodynai.html", "B Žodynėliai B.1 Statistikos terminai (aiškinamasis žodynas) B.2 Statistikos terminai (anglų-lietuvių) B.3 Simbolių pavadinimai (anglų-lietuvių) B.4 Programavimo ir matematikos terminai (anglų-lietuvių)", " B Žodynėliai B.1 Statistikos terminai (aiškinamasis žodynas) http://www.statistika.mif.vu.lt/zodynelis/ B.2 Statistikos terminai (anglų-lietuvių) B.3 Simbolių pavadinimai (anglų-lietuvių) B.4 Programavimo ir matematikos terminai (anglų-lietuvių) Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["priedas-r-sesijos-info.html", "C R sesijos informacija", " C R sesijos informacija R ir šios programos paketų versijos bei kita techninė R sesijos informacija šios knygos kūrimo metu. devtools::session_info() ## Session info ------------------------------------------------------------- ## setting value ## version R version 3.5.0 (2018-04-23) ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate Lithuanian_Lithuania.1257 ## tz Europe/Helsinki ## date 2018-06-06 ## Packages ----------------------------------------------------------------- ## package * version date ## abind 1.4-5 2016-07-21 ## acepack 1.4.1 2016-10-29 ## assertthat 0.2.0 2017-04-11 ## backports 1.1.2 2017-12-13 ## base * 3.5.0 2018-04-23 ## base64enc 0.1-3 2015-07-28 ## bindr 0.1.1 2018-03-13 ## bindrcpp 0.2.2 2018-03-29 ## bookdown 0.7.12 2018-06-03 ## boot 1.3-20 2017-08-06 ## broom 0.4.4 2018-03-29 ## Cairo 1.5-9 2015-09-26 ## cellranger 1.1.0.9000 2018-05-21 ## checkmate 1.8.5 2017-10-24 ## class 7.3-14 2015-08-30 ## cli 1.0.0 2017-11-05 ## cluster 2.0.7-1 2018-04-13 ## colorspace 1.3-2 2016-12-14 ## compiler 3.5.0 2018-04-23 ## cowplot 0.9.2 2017-12-17 ## crayon 1.3.4 2017-09-16 ## crosstalk 1.0.0 2016-12-21 ## curl 3.2 2018-03-28 ## data.table 1.11.4 2018-05-27 ## datasets * 3.5.0 2018-04-23 ## devtools 1.13.5 2018-02-18 ## digest 0.6.15 2018-01-28 ## dplyr 0.7.5 2018-05-19 ## e1071 1.6-8 2017-02-02 ## evaluate 0.10.1 2017-06-24 ## expm 0.999-2 2017-03-29 ## fitdistrplus 1.0-9 2017-03-24 ## forcats 0.3.0 2018-02-19 ## foreign 0.8-70 2017-11-28 ## ggedit 0.2.1 2017-04-06 ## ggplot2 2.2.1.9000 2018-06-03 ## glue 1.2.0 2017-10-29 ## graphics * 3.5.0 2018-04-23 ## grDevices * 3.5.0 2018-04-23 ## grid 3.5.0 2018-04-23 ## gridExtra 2.3 2017-09-09 ## gtable 0.2.0 2016-02-26 ## haven 1.1.1 2018-01-18 ## highr 0.6 2016-05-09 ## hms 0.4.2.9000 2018-06-05 ## htmlTable 1.12 2018-05-26 ## htmltools 0.3.6 2017-04-28 ## htmlwidgets 1.2.1 2018-04-30 ## httpuv 1.4.3 2018-05-10 ## httr 1.3.1 2017-08-20 ## icon 0.1.0 2018-05-21 ## jpeg 0.1-8 2014-01-23 ## jsonlite 1.5 2017-06-01 ## knitr * 1.20.3 2018-06-03 ## labeling 0.3 2014-08-23 ## later 0.7.2 2018-05-01 ## lattice 0.20-35 2017-03-25 ## latticeExtra 0.6-28 2016-02-09 ## lazyeval 0.2.1 2017-10-29 ## lubridate 1.7.4 2018-04-11 ## magrittr * 1.5 2014-11-22 ## manipulate 1.0.1 2014-12-24 ## MASS 7.3-49 2018-02-23 ## Matrix 1.2-14 2018-04-13 ## memoise 1.1.0 2017-04-21 ## methods * 3.5.0 2018-04-23 ## mime 0.5 2016-07-07 ## mnormt 1.5-5 2016-10-15 ## modelr 0.1.2 2018-05-11 ## multcompView 0.1-7 2015-07-31 ## munsell 0.4.3 2016-02-13 ## mvtnorm 1.0-8 2018-05-31 ## nlme 3.1-137 2018-04-07 ## nnet 7.3-12 2016-02-02 ## nortest 1.0-4 2015-07-30 ## openxlsx 4.1.0 2018-05-26 ## parallel 3.5.0 2018-04-23 ## pillar 1.2.3 2018-05-25 ## pkgconfig 2.0.1 2017-03-21 ## plyr 1.8.4 2016-06-08 ## png 0.1-7 2013-12-03 ## promises 1.0.1 2018-04-13 ## psych 1.8.4 2018-05-06 ## purrr 0.2.5 2018-05-29 ## R6 2.2.2 2017-06-17 ## RColorBrewer 1.1-2 2014-12-07 ## Rcpp 0.12.17 2018-05-18 ## readr 1.2.0 2018-06-05 ## readxl 1.1.0 2018-04-20 ## reshape2 1.4.3 2017-12-11 ## rio 0.5.10 2018-03-29 ## rJava 0.9-10 2018-05-29 ## rlang 0.2.1 2018-05-30 ## rmarkdown 1.9.17 2018-06-03 ## rpart 4.1-13 2018-02-23 ## rprojroot 1.3-2 2018-01-03 ## rstudioapi 0.7 2017-09-07 ## rvest 0.3.2 2016-06-17 ## scales 0.5.0.9000 2018-04-30 ## shiny 1.1.0 2018-05-17 ## shinyBS 0.61 2015-03-31 ## splines 3.5.0 2018-04-23 ## stats * 3.5.0 2018-04-23 ## stringi 1.2.2 2018-05-02 ## stringr 1.3.1 2018-05-10 ## survival 2.41-3 2017-04-04 ## tibble 1.4.2 2018-01-22 ## tidyr 0.8.1 2018-05-18 ## tidyselect 0.2.4 2018-02-26 ## tools 3.5.0 2018-04-23 ## utf8 1.1.4 2018-05-24 ## utils * 3.5.0 2018-04-23 ## viridisLite 0.3.0 2018-02-01 ## withr 2.1.2 2018-05-27 ## xfun 0.1 2018-01-22 ## xlsx 0.5.7 2014-08-02 ## xlsxjars 0.6.1 2014-08-22 ## xml2 1.2.0.9000 2018-05-21 ## xtable 1.8-2 2016-02-05 ## yaml 2.1.19 2018-05-01 ## zip 1.0.0 2017-04-25 ## zoo 1.8-1 2018-01-08 ## source ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## local ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (rstudio/bookdown@2262390) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (rsheets/cellranger@7ecde54) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## local ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## local ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (tidyverse/ggplot2@cc48035) ## CRAN (R 3.5.0) ## local ## local ## local ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (tidyverse/hms@14e74ab) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (ramnathv/htmlwidgets@e3097fa) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (ropenscilabs/icon@1f3d0ed) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (yihui/knitr@490b82a) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## local ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## local ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (tidyverse/readr@c662432) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (rstudio/rmarkdown@9885f5e) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (hadley/scales@d767915) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## local ## local ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## local ## CRAN (R 3.5.0) ## local ## CRAN (R 3.5.0) ## Github (jimhester/withr@70d6321) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## Github (hadley/xml2@ba3511f) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) ## CRAN (R 3.5.0) "],
["priedas-projektas.html", "D Projekto šablonas D.1 RStudio projekto šablonas D.2 Konfigūracijos byla .Rprofile", " D Projekto šablonas D.1 RStudio projekto šablonas RStudio projekto šablonas (nuoroda atsisiųsti ). Atsisiųskite ir aplanką tinkamai persivadinkite. Projekte yra R Commander konfigūravimo nurodymai (juos galite rasti skyriuje D.2). Atsidarę projektą galėsite užsikrauti „Rcmdr“ (R Commander) 3 langų režimu, Windows ir Mac sistemoms automatiškai bus įjungta lietuviška lokalė (Linux vartotojams gali tekti pagal instrukcijas modifikuoti kodą). Prieš naudodami šį projektą įsitikinkite, kad RStudio nustatytas UTF-8 dekodavimo standartas. Apie tai rašoma skyriuje A.5 „RStudio konfigūravimas“. D.2 Konfigūracijos byla .Rprofile Byla su nustatymais, kuriuos R aktyvuoja programos užkrovimo metu, vadinama „.Rprofile“ (prieš tašką nieko nerašoma, tai specialios paskirties byla). Šio kurso studentams rekomenduojamos komandos šioje byloje: # Projekto nustatymai ======================================================== # Šiame dokumente esantis kodas automatiškai vykdomas paleidžiant projektą. # Jis sukonfigūruoja „R“: # 1. „R Commander“ ima veikti 3 langų režimu; # 2. „R Commander“ meniu pridedamos parinktys: # a. „KMggplot2“; # b. „EZR“; # c. „BioStat“. # 3. Nustatoma lietuviškoji lokalė. # DĖMESIO: naudoti TIK projekto viduje!!! # Norint naudoti šią konfigūraciją, turi būti įdiegti paketai: # # Rcmdr, # iš CRAN # RcmdrPlugin.KMggplot2, # iš CRAN # RcmdrPlugin.EZR, # iš CRAN # RcmdrPlugin.EZR.2, # iš GitHub # biostat, # iš GitHub # RcmdrPlugin.biostat # iš GitHub # Atnaujinta: 2018-03-08 18:35 # R Commander (Rcmdr) nustatymai --------------------------------------------- # Rcmdr ataskaitos šablono vieta ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ .rmd_template_filenamename &lt;- system.file(&quot;etc/biostat-RMarkdown-Template.Rmd&quot;, package = &quot;RcmdrPlugin.biostat&quot;) # Pradinė konfigūracija ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ options(Rcmdr = list( # Pridedamos meniu parinktys: plugins = c(&quot;RcmdrPlugin.KMggplot2&quot;, &quot;RcmdrPlugin.EZR.2&quot;, &quot;RcmdrPlugin.biostat&quot;, NULL) # Parenkamas 3 arba 1 lango režimas: , console.output = FALSE # FALSE - Rcmdr 3 langų režimas, # TRUE - Rcmdr 1 lango režimas. # Ar naudoti papildomą 3D grafikų sistemą? , use.rgl = FALSE # Nustatomas pagrindinis Rcmdr anaskaitos šablonas: , rmd.template = .rmd_template_filenamename # Jei kils problemų, # šią eilutę užkomentuokite )) # Skliaustai privalo likti neužkomentuoti. # Nustatoma lietuviškoji lokalė ---------------------------------------------- # if (.Platform$OS.type == &quot;windows&quot;) { # Jei sistema &quot;Windows&quot;: Sys.setlocale(locale = &quot;Lithuanian&quot;) } else { # Jei sistema &quot;Linux&quot; arba “Mac“, lokalę gali reikti patikslinti # pagal konkrečią operacinę sistemą. Galimi variantai: # lt_LT.utf8, lt_LT.utf-8 ar lt_LT.UTF-8. # # Kodas `Sys.getlocale()` parodys, kaip atrodo dabartinė jūsų lokalė. # Naudokite tai kaip pavyzdį pasirinkti tai, kaip turi būti nurodyta # lietuviškoji lokalė. Sys.setlocale(locale = &quot;lt_LT&quot;) } # ============================================================================ Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["priedas-papildomas-diegimas.html", "E Papildomų papildinių diegimas", " E Papildomų papildinių diegimas Tai laikinas pagalbinis kodas. install.packages(&quot;devtools&quot;) install.packages(c(&quot;Rcmdr&quot;, &quot;tidyverse&quot;), dependencies = c(&quot;Depends&quot;, &quot;Imports&quot;, &quot;Suggests&quot;)) # Paketo `ggplot2` priedai install.packages(c(&quot;plotly&quot;, &quot;ggedit&quot;, &quot;ggplotgui&quot;)) # Paketo `Rcmdr` priedai install.packages(c(&quot;coda&quot; , &quot;arm&quot; , &quot;matrixcalc&quot; , &quot;mi&quot; , &quot;mvtnorm&quot; , &quot;TH.data&quot; , &quot;sem&quot; , &quot;rgl&quot; , &quot;multcomp&quot; , &quot;lmtest&quot; , &quot;leaps&quot; , &quot;aplpack&quot;)) # Ataskaitų rengimui, kodo formatavimui install.packages(&quot;stringi&quot;) devtools::install_github(&quot;GegznaV/addin.tools&quot;) devtools::install_github(&quot;GegznaV/addins.rmd&quot;) devtools::install_github(&quot;GegznaV/addins.rs&quot;) # Interaktyvus grafikų braižymo įrankis install.packages(&quot;shiny&quot;) devtools::install_github(&quot;majkamichal/easyPlot&quot;) # R Commander papildiniai install.packages(&quot;RcmdrPlugin.KMggplot2&quot;) install.packages(&quot;RcmdrPlugin.EZR&quot;) devtools::install_github(&quot;GegznaV/RcmdrPlugin.EZR@unmodified_Rcmdr_menu&quot;) devtools::install_github(&quot;GegznaV/biostat&quot;) # Versija bent 0.0.17 devtools::install_github(&quot;GegznaV/RcmdrPlugin.biostat&quot;) # Versija bent 0.0.17 Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["priedas-darbo-eiga.html", "F Darbo eiga (atmintinės) F.1 Duomenų apsauga nuo praradimo F.2 Programos kodo rašymo eiga F.3 Analizės eiga F.4 R Commander užkrovimas per RStudio", " F Darbo eiga (atmintinės) F.1 Duomenų apsauga nuo praradimo Pasidarykite atsarginę duomenų kopiją. Jei analizė svarbi – net ne vieną: kitame kompiuteryje; USB atmintinėje; „DropBox“ sistemoje; „Google Drive“ sistemoje; kitur. Analizę atlikite tik su duomenų kopija. Pradiniai duomenys turi likti saugūs, jei reiktų atkurti jų kopiją. Turėkite atsarginę duomenų kopiją. F.2 Programos kodo rašymo eiga Tam, kad programos kodas, aprašanti analizę, veiktų sklandžiai (arba veiktų apskritai), privalo būti užtikrinta tokia analizės veiksmų seka: Užkraunami reikiami R paketai; Užrašomi/Keičiami nustatymai; Įkeliami duomenys; Vykdoma tolimesnė analizė. Jei kažkurios reikiamos dalies trūks arba bus sumaišyta jų eilės tvarka, programos kodas rengiant ataskaitą gali neveikti. Analizės kodo elementai eilės tvarka (anmintinė): Paketai. Nustatymai. Duomenys. Visa kita. F.3 Analizės eiga Įsikėlus duomenis, rekomenduojama tokia eiga: Aiškiai žinokite klausimą, kurį norime išspręsti (kitaip analizė bus be tikslo); Nusibraižykite duomenis grafiškai (šitaip greičiau pastebėsite esminius duomenų bruožus, ypač – neatitikimus); Patikrinkite prielaidas ir pasirinkite tinkamą analizės metodą; Ir tik po to atlikite pagrindinę analizę. Nuoseklios duomenų analizės eiga: Klausimas. Grafikas. Prielaidos. Pagrindinė analizė. F.4 R Commander užkrovimas per RStudio Jei norite, kad papildinys R Commander veiktų trijų langų režimu ir jame būtų papildomos meniu parinktys, rekomenduojama tokia darbo eiga: Atsidarykite RStudio projektą, kuriame dirbote anksčiau; Įsitikinkite, kad pagrindiniame projekto aplanke yra „.Rprofile“ byla su reikiamu programos kodu; Užsikraukite papildinį Rcmdr. Jei neveikia trijų langų režimas, trūksta užkrautų įskiepių arba norite naujo projekto, tada tinkamesnė tokia eiga: Sukurkite naują arba pasirinkite jau egzistuojantį RStudio projektą. Atsidarykite šį projektą. Įsitikinkite, kad projekto aplanke yra „.Rprofile“ byla, kurioje – R Commander nustatymai, skirti atidaryti trijų langų režimą ir reikiamus įskiepius, pvz., RcmdrPlugin.biostat. jei bylos nėra, ją susikurkite arba nusikopijuokite, pvz., iš priedo D „Projekto šablonas“; jei „.Rprofile“ modifikuojama arba sukuriama iš naujo, ją išsaugokite, tada perkraukite RStudio. Perkrovus nustatymai iš bylos nuskaitomi automatiškai. Užsikraukite papildinį Rcmdr (R Commander); Jei atsidarius R Commander reikia papildomų įskiepių, jie turi būti užkraunami ne per RStudio, o per R Commander meniu: R Commander meniu → Tools → Load Rcmdr Plug-in(s)…; keli įskiepiai gali būti pasirinkti laikant nuspaudus „Ctrl“ (control) klavišą ir pele pasirenkant įskiepių pavadinimus; pasirinkus įskiepius ir paspaudus „Ok“, R Commander paklaus, ar sutinkate perkrauti. Sutikite. Persikrovus papildiniui atsiras naujos meniu komandos. Sukonfigūruoto R Commander užkrovimas: Atidaromas RStudio projektas; Patikrinama, ar yra „.Rprofile“ byla su reikiamu kodu; Užkraunamas Rcmdr. Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "],
["priedas-rcmdr-resursai.html", "G R Commander resursai", " G R Commander resursai Šiame priede nurodomi resursai, kaip naudotis R Commander. Kaip įsidiegti ir tinkamai atsidaryti R Commander: „YouTube“ grojaraštis . Tinklapio turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija. "]
]
